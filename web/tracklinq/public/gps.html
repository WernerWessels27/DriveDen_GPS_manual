<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TrackLinq GPS</title>
  <link rel="manifest" href="/manifest.webmanifest">

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root{
      --black:#0b0b0b; --white:#ffffff; --border:#e5e7eb33;
      --brand:#14532d; --brand-2:#166534; --accent:#16a34a;
      --muted:#6b7280;
      --chip:#e6f6ea; --chipText:#14532d;
    }
    html, body { height: 100%; margin: 0; background: #000; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; }
    #map { width: 100%; height: 100%; }

    /* Top full-width course banner */
    .banner {
      position: absolute; top: 0; left: 0; right: 0; z-index: 1100;
      background: #111; color: var(--white);
      border-bottom: 1px solid var(--border);
      display: grid; grid-template-columns: 80px 1fr 80px; align-items: center;
      padding: 8px 10px;
    }
    .banner h1 { margin: 0; text-align: center; font-size: 16px; font-weight: 800; }
    .banner .left, .banner .right { display: flex; align-items: center; justify-content: center; gap: 6px; }
    .exitBtn {
      cursor: pointer; padding: 8px 10px; border-radius: 10px;
      border: 1px solid var(--border); background: #111; color: #fff; font-weight: 800;
    }

    /* Hole number bar */
    .holeBar {
      position: absolute; top: 56px; left: 50%; transform: translateX(-50%);
      z-index: 1050; display: inline-flex; align-items: center; gap: 10px;
      background: #111; color: #fff; border: 1px solid var(--border);
      padding: 6px 10px; border-radius: 12px; font-weight: 800;
    }
    .holeBtn {
      cursor: pointer; padding: 4px 8px; border-radius: 8px; border: 1px solid var(--border);
      background: #111; color: #fff; font-weight: 800;
    }

    /* Distances stack (top-left) */
    .distStack {
      position: absolute; top: 112px; left: 12px; z-index: 1050;
      display: grid; gap: 8px; min-width: 180px;
    }
    .chipV {
      display: grid; grid-template-columns: 14px 1fr auto; align-items: center;
      gap: 8px; padding: 10px 12px; border-radius: 14px;
      background: #111; border: 1px solid var(--border); color: #fff;
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .midTxt { font-size: 18px; font-weight: 900; }
    .smallTxt { font-size: 12px; font-weight: 700; }
    .unitToggle {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 8px 10px; border-radius: 999px; background: #111;
      border: 1px solid var(--border); color: #fff; font-weight: 800; cursor: pointer; width: max-content;
    }

    /* Layup info chip */
    .layupBox {
      display:none; grid-template-columns: 1fr auto; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 12px; background: #111; color:#fff; border:1px solid var(--border);
      width: max-content; max-width: 92vw;
    }
    #layupText { white-space: nowrap; overflow: hidden; text-overflow: clip; font-weight: 800; }
    .clearLayupBtn { cursor:pointer; padding:6px 10px; border-radius:10px; background:#111; color:#fff; border:1px solid var(--border); }

    /* Bottom-left stacked icons: flag & cart */
    .viewIcons {
      position: absolute; left: 12px; bottom: 12px; z-index: 1050;
      display: grid; gap: 8px;
    }
    .viewBtn {
      width: 52px; height: 52px; display: grid; place-items: center;
      border-radius: 14px; background: #111; border: 1px solid var(--border); color: #fff; cursor: pointer;
      font-size: 24px; user-select: none;
    }
    .viewBtn:active { transform: translateY(1px); }

    /* Bottom-center bubbles: Scorecard & History */
    .bottomBubbles {
      position: absolute; left: 50%; transform: translateX(-50%); bottom: 12px; z-index: 1050;
      display: flex; gap: 10px;
    }
    .bubbleBtn {
      cursor: pointer; padding: 10px 14px; border-radius: 999px; background: #111; border: 1px solid var(--border); color: #fff; font-weight: 800;
    }

    /* Top-right: Penalties toggle */
    .topRightCol { position:absolute; top:108px; right:10px; z-index:1300; display:flex; flex-direction:column; gap:8px; }
    .btnMini {
      border:1px solid #e5e7eb; background:#ffffffee; color:#111827;
      border-radius:12px; padding:10px 14px; font-weight:800; cursor:pointer;
      box-shadow:0 4px 16px rgba(0,0,0,.12);
    }
    .penRow{ display:flex; align-items:center; gap:10px; }
    .penSwitch{ position:relative; width:48px; height:26px; border-radius:999px; background:#ddd; border:1px solid #cfcfcf; flex:0 0 auto; }
    .penSwitch .knob{ position:absolute; top:3px; left:3px; width:20px; height:20px; border-radius:999px; background:#fff; transition:all .2s; }

    /* Modals (score/history) */
    .modalBack { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; place-items: center; z-index: 1600; }
    .modal { width: min(92vw, 920px); max-height: 84vh; overflow: auto; background: #0b0b0b; color: #fff; border: 1px solid var(--border); border-radius: 16px; padding: 14px; }
    .modal h2 { margin: 0 0 10px; font-size: 18px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 8px; border-bottom: 1px solid #1f2937; text-align: center; }
    input.strokes, input.nameInp, input.hcapInp { width: 70px; padding: 6px; border-radius: 8px; border: 1px solid #374151; background: #111; color: #fff; text-align: center; }
    .modalActions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px; }
    .btn { cursor: pointer; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: #111; color: #fff; font-weight: 800; }
    .btn.green { background: #14532d; border-color: #166534; }
    .btn.red   { background: #3f1b1b; border-color: #7f1d1d; }

    /* Hide Leaflet default UI */
    .leaflet-control-container { display: none !important; }
    .leaflet-bottom.leaflet-right { display: none !important; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Top course banner -->
  <div class="banner">
    <div class="left"></div>
    <h1 id="courseTitle">Course</h1>
    <div class="right">
      <button class="exitBtn" id="exitBtn">Exit</button>
    </div>
  </div>

  <!-- Center hole bar -->
  <div class="holeBar">
    <button class="holeBtn" id="prevHole">â—€ï¸Ž</button>
    <div>
      <span class="smallTxt">Par</span> <span id="par">4</span> &nbsp; â€¢ &nbsp;
      <span style="font-size:18px;font-weight:900;">Hole <span id="holeNo">1</span></span> &nbsp; â€¢ &nbsp;
      <span class="smallTxt">Stroke</span> <span id="stroke">1</span>
    </div>
    <button class="holeBtn" id="nextHole">â–¶ï¸Ž</button>
  </div>

  <!-- Distances stack -->
  <div class="distStack">
    <div class="chipV">
      <span class="dot" style="background:#ffffff"></span>
      <span class="smallTxt">FRONT</span>
      <span id="dFront" class="smallTxt">â€“</span>
    </div>
    <div class="chipV">
      <span class="dot" style="background:#fbbf24"></span>
      <span class="midTxt">MID</span>
      <span id="dMid" class="midTxt">â€“</span>
    </div>
    <div class="chipV">
      <span class="dot" style="background:#ef4444"></span>
      <span class="smallTxt">BACK</span>
      <span id="dBack" class="smallTxt">â€“</span>
    </div>

    <div class="unitToggle" id="unitBtn">Units: <span id="unitChip">m</span></div>

    <!-- Layup info appears when there is a layup point -->
    <div class="layupBox" id="layupBox">
      <div id="layupText">Layup: CARTâ†’P â€”  â€¢  Pâ†’MID â€”</div>
      <button class="clearLayupBtn" id="clearLayupBtn">CLEAR LAYUP</button>
    </div>
  </div>

  <!-- Bottom-left stacked view icons -->
  <div class="viewIcons">
    <button title="Hole View (TEEâ†”BACK)" class="viewBtn" id="holeViewBtn">â›³</button>
    <button title="Cart View (CARTâ†”BACK)" class="viewBtn" id="cartViewBtn">ðŸ›º</button>
  </div>

  <!-- Bottom-center bubbles -->
  <div class="bottomBubbles">
    <button class="bubbleBtn" id="scoreBtn">Scorecard</button>
    <button class="bubbleBtn" id="historyBtn">History</button>
  </div>

  <!-- Top-right controls -->
  <div class="topRightCol">
    <button class="btnMini" id="penBtnMini">
      <div class="penRow">
        <span>Penalties</span>
        <div class="penSwitch" id="penSwitch"><div class="knob"></div></div>
      </div>
    </button>
  </div>

  <!-- Scorecard modal -->
  <div class="modalBack" id="scoreModal">
    <div class="modal">
      <h2 id="scoreTitle">Scorecard</h2>
      <div id="scoreSetup">
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:10px;">
          <label>Players:</label>
          <select id="playerCount">
            <option>1</option><option>2</option><option selected>3</option><option>4</option>
          </select>
          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="useHandicaps" checked/> Use handicaps
          </label>
        </div>
        <div id="playersGrid" style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-bottom:10px;"></div>
        <div class="modalActions">
          <button class="btn green" id="createCard">Create scorecard</button>
          <button class="btn" id="closeSetup">Close</button>
        </div>
        <hr style="border-color:#1f2937; margin:12px 0;">
      </div>
      <div id="scoreBody" style="display:none;">
        <div style="overflow:auto;">
          <table id="scoreTable"></table>
        </div>
        <div class="modalActions">
          <button class="btn" id="closeScore">Close</button>
          <button class="btn green" id="saveRound">Save Round</button>
        </div>
      </div>
    </div>
  </div>

  <!-- History modal -->
  <div class="modalBack" id="histModal">
    <div class="modal">
      <h2>Last 10 Rounds</h2>
      <div id="histList"></div>
      <div class="modalActions">
        <button class="btn" id="closeHist">Close</button>
        <button class="btn red" id="clearHist">Clear History</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" style="display:none; position: absolute; left: 50%; transform: translateX(-50%); bottom: 12px; z-index: 1300; background: #000; color:#fff; border:1px solid var(--border); padding:8px 12px; border-radius:10px; font-size:12px;"></div>

  <script>
    // Register SW (PWA)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => navigator.serviceWorker.register('/sw.js').catch(()=>{}));
    }

    // Helpers
    const $  = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);
    function q(name){ return new URL(location.href).searchParams.get(name); }
    function toast(msg, ms=1600){ const t=$('#toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', ms); }

    // Dot icon
    function dotIcon(color='#ffffff', size=12){
      const r=Math.floor(size/2);
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'>
          <circle cx='${r}' cy='${r}' r='${r}' fill='${color}' />
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[r,r] });
    }

    // Modern cart icon (SVG)
    const CART_SVG = `
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 40'>
        <rect x='6' y='10' width='36' height='12' rx='4' fill='#10b981' stroke='#065f46' stroke-width='2'/>
        <circle cx='18' cy='28' r='6' fill='#111' stroke='#444' stroke-width='2'/>
        <circle cx='36' cy='28' r='6' fill='#111' stroke='#444' stroke-width='2'/>
        <path d='M42 12h12l4 8h-10' fill='none' stroke='#065f46' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'/>
        <path d='M10 10v-6h8' fill='none' stroke='#065f46' stroke-width='3' stroke-linecap='round'/>
      </svg>`;
    function cartIcon(size=44){
      const svg=encodeURIComponent(CART_SVG);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size, size*0.625], iconAnchor:[size*0.5, size*0.625] });
    }

    // Mid flag icon (modern)
    const MID_FLAG_SVG = `
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'>
        <path d='M12 6v36' stroke='#0f172a' stroke-width='4' stroke-linecap='round'/>
        <path d='M14 8h18l-4 6 4 6H14z' fill='#fbbf24' stroke='#0f172a' stroke-width='2' />
        <circle cx='12' cy='42' r='3' fill='#0f172a'/>
      </svg>`;
    function flagIcon(size=42){
      const svg=encodeURIComponent(MID_FLAG_SVG);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[10,40] });
    }

    // Toilet / Taps icons (square sign)
    function largeSymbolIcon(svgPath, size=44){
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 40 40'>${svgPath}</svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[size/2,size/2] });
    }
    const TOILET_SVG = `
      <rect x='2' y='2' width='36' height='36' rx='8' fill='#6b7280'/>
      <path d='M14 26h2l1-6 1 6h2l-2-10h-2l-2 10Zm8 0h2v-4h2v4h2V16h-2v4h-2v-4h-2v10Z' fill='white'/>
    `;
    const TAP_SVG = `
      <rect x='2' y='2' width='36' height='36' rx='8' fill='#0ea5e9'/>
      <path d='M10 18h10v-2h2v-2h8v2h-6v2h-4v4h4v2h-8v-2h2v-4h-8v-2h0Z' fill='white'/>
    `;

    const ICONS = {
      TEE: dotIcon('#16a34a', 14),            // mapper tee; hidden on GPS
      FRONT: dotIcon('#ffffff', 12),          // hidden on GPS
      MID: flagIcon(42),                      // visible on GPS
      BACK: dotIcon('#ef4444', 12),           // hidden on GPS
      TOILET: largeSymbolIcon(TOILET_SVG, 44),
      TAPS: largeSymbolIcon(TAP_SVG, 44),
      STAKE_WHITE: dotIcon('#ffffff', 10),
      STAKE_RED: dotIcon('#ef4444', 10),
      STAKE_YELLOW: dotIcon('#fbbf24', 10),
      CART: cartIcon(46),
      LAYUP: dotIcon('#ffffff', 12)
    };

    // Map
    const map = L.map('map', { zoomControl:false, attributionControl:false }).setView([-25.746, 28.229], 17);
    window.__leafletMap = map;
    L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19 }
    ).addTo(map);

    // Data helpers (cache-first)
    async function getIndex(){
      let res=await caches.match('/courses/index.json');
      if(!res) res=await fetch('/courses/index.json', { cache:'reload' });
      return res.json();
    }
    async function loadCourseJson(id){
      const url=`/courses/${id}.json`;
      let res=await caches.match(url);
      if(!res) res=await fetch(url, { cache:'reload' });
      return res.json();
    }
    async function pickCourseFromIndex(idx){
      const want=(q('course')||'').trim();
      if(want){
        const c=(idx.courses||[]).find(x=>x.id.toUpperCase()===want.toUpperCase());
        if(c) return c;
      }
      return (idx.courses||[])[0]||null;
    }

    // State
    const state = {
      meta:null, course:null, hole:1,
      markers:[], cartMarker:null,
      unit:'m',
      layupMarker:null,
      stakeMarkers:[]
    };

    // Distances
    const toRad = d => d*Math.PI/180;
    function haversine(a,b){
      const R=6371000, dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
      const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
      const aa=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
      return 2*R*Math.atan2(Math.sqrt(aa),Math.sqrt(1-aa));
    }
    const fmt = m => state.unit==='yd' ? Math.round(m*1.09361) : Math.round(m);
    function fromCart(){ if(state.cartMarker){ const ll=state.cartMarker.getLatLng(); return {lat:ll.lat,lng:ll.lng}; } return null; }
    function fromPoint(pins, pref='CART'){
      if(pref==='TEE' && pins.TEE) return { lat:pins.TEE.lat, lng:pins.TEE.lng };
      return fromCart();
    }
    function updateChips(pins){
      const f=$('#dFront'), m=$('#dMid'), b=$('#dBack');
      f.textContent=m.textContent=b.textContent='â€“';
      const from = fromPoint(pins, 'CART') || fromPoint(pins,'TEE');
      if(!from) return;
      if(pins.FRONT) f.textContent=fmt(haversine(from, pins.FRONT));
      if(pins.MID)   m.textContent=fmt(haversine(from, pins.MID));
      if(pins.BACK)  b.textContent=fmt(haversine(from, pins.BACK));
      $('#unitChip').textContent = state.unit;
      updateLayupBox();
    }

    // Markers
    function clearMarkers(){ state.markers.forEach(m=>m.remove()); state.markers=[]; }
    function addMarker(lat,lng,icon,title=''){ const m=L.marker([lat,lng],{icon,title}).addTo(map); state.markers.push(m); return m; }
    function addStakeMarker(lat,lng,color){
      const icon = color==='red' ? ICONS.STAKE_RED : (color==='yellow'? ICONS.STAKE_YELLOW : ICONS.STAKE_WHITE);
      const m=L.marker([lat,lng],{icon,title:`stake-${color}`}).addTo(map);
      state.markers.push(m); state.stakeMarkers.push(m); return m;
    }
    function fitBetween(a,b){ const bounds=L.latLngBounds(L.latLng(a[0],a[1]),L.latLng(b[0],b[1])); map.fitBounds(bounds,{padding:[60,60]}); }

    // Penalties toggle
    let penaltiesOn = (localStorage.getItem('penalties_show') === '1');
    function paintPenToggle(){
      const sw = $('#penSwitch'); if(!sw) return;
      sw.style.background = penaltiesOn ? '#16a34a' : '#ddd';
      sw.style.borderColor = penaltiesOn ? '#16a34a' : '#cfcfcf';
      const k = sw.querySelector('.knob');
      if(k) k.style.transform = penaltiesOn ? 'translateX(22px)' : 'translateX(0)';
    }
    function applyPenaltiesVisibility(){
      try{
        state.stakeMarkers.forEach(m => {
          if (penaltiesOn) { if (!map.hasLayer(m)) m.addTo(map); }
          else             { if (map.hasLayer(m))  map.removeLayer(m); }
        });
      }catch(e){}
    }
    $('#penBtnMini').addEventListener('click', ()=>{
      penaltiesOn = !penaltiesOn;
      localStorage.setItem('penalties_show', penaltiesOn ? '1' : '0');
      paintPenToggle();
      applyPenaltiesVisibility();
    });
    paintPenToggle();

    // Render
    function renderHole(){
      clearMarkers();
      state.stakeMarkers.forEach(m=>m.remove()); state.stakeMarkers=[];

      const h = state.course.holes[String(state.hole)];
      $('#holeNo').textContent = state.hole;
      $('#par').textContent = h?.par ?? '-';
      $('#stroke').textContent = h?.stroke ?? '-';
      if(!h) return;

      const p = h.pins || {};
      if (p.TEE)   addMarker(p.TEE.lat, p.TEE.lng, ICONS.TEE, 'TEE');
      if (p.FRONT) addMarker(p.FRONT.lat, p.FRONT.lng, ICONS.FRONT, 'FRONT');
      if (p.MID)   addMarker(p.MID.lat, p.MID.lng, ICONS.MID, 'MID');
      if (p.BACK)  addMarker(p.BACK.lat, p.BACK.lng, ICONS.BACK, 'BACK');

      if (p.TOILET) addMarker(p.TOILET.lat, p.TOILET.lng, ICONS.TOILET, 'Toilet');
      (p.TAPS || []).forEach(t => addMarker(t.lat, t.lng, ICONS.TAPS, 'Drinking water'));
      (p.STAKE_WHITE || []).forEach(s => addStakeMarker(s.lat, s.lng, 'white'));
      (p.STAKE_RED   || []).forEach(s => addStakeMarker(s.lat, s.lng, 'red'));
      (p.STAKE_YELLOW|| []).forEach(s => addStakeMarker(s.lat, s.lng, 'yellow'));

      // Hole fit preference
      if (p.TEE && p.BACK) fitBetween([p.TEE.lat,p.TEE.lng],[p.BACK.lat,p.BACK.lng]);
      else {
        const latlngs = state.markers.map(m => m.getLatLng());
        if (latlngs.length) map.fitBounds(L.latLngBounds(latlngs), { padding: [40,40] });
      }

      // Hide FRONT/BACK on GPS view
      try{
        state.markers.forEach(m=>{
          const t=(m && m.options && m.options.title)? String(m.options.title).toLowerCase() : '';
          if (t==='front' || t==='back'){ if (m._map) map.removeLayer(m); }
        });
      }catch(e){}

      updateChips(p);
      updateLayupBox();
      applyPenaltiesVisibility();
    }

    // View buttons
    $('#holeViewBtn').addEventListener('click', ()=>{
      const p = state.course.holes[String(state.hole)]?.pins || {};
      if (p.TEE && p.BACK) fitBetween([p.TEE.lat,p.TEE.lng],[p.BACK.lat,p.BACK.lng]);
    });
    $('#cartViewBtn').addEventListener('click', ()=>{
      const p = state.course.holes[String(state.hole)]?.pins || {};
      if (!p.BACK || !state.cartMarker) return;
      const ll = state.cartMarker.getLatLng();
      fitBetween([ll.lat,ll.lng],[p.BACK.lat,p.BACK.lng]);
    });

    // Hole nav
    $('#prevHole').addEventListener('click', ()=>{
      const min=1; state.hole=Math.max(min, state.hole-1); renderHole();
    });
    $('#nextHole').addEventListener('click', ()=>{
      const max=Math.max(...Object.keys(state.course.holes||{}).map(k=>+k).filter(Number.isFinite));
      state.hole=Math.min(max||state.hole+1, state.hole+1); renderHole();
    });

    // Units
    $('#unitBtn').addEventListener('click', ()=>{
      state.unit = state.unit==='m' ? 'yd' : 'm';
      const p = state.course.holes[String(state.hole)]?.pins || {};
      updateChips(p);
    });

    // Exit -> back to login
    $('#exitBtn').addEventListener('click', ()=>{ location.href = '/index.html'; });

    // Geolocation (watch for live CART updates)
    function updateCartAndChips(){
      const p = state.course.holes[String(state.hole)]?.pins || {};
      updateChips(p);
    }
    if (navigator.geolocation){
      navigator.geolocation.watchPosition((pos)=>{
        const { latitude, longitude } = pos.coords;
        if (!state.cartMarker) state.cartMarker = L.marker([latitude,longitude], { icon: ICONS.CART, title:'CART' }).addTo(map);
        else state.cartMarker.setLatLng([latitude,longitude]);
        updateCartAndChips();

        // Keep CART & BACK in frame while moving
        const p = state.course.holes[String(state.hole)]?.pins || {};
        if (p.BACK){
          const ll = state.cartMarker.getLatLng();
          fitBetween([ll.lat,ll.lng],[p.BACK.lat,p.BACK.lng]);
        }
      }, ()=>{}, { enableHighAccuracy:true, maximumAge:5000, timeout:10000 });
    }

    // LAYUP: click map to drop a layup marker + distances CARTâ†’Layup and Layupâ†’MID
    map.on('click', (e)=>{
      const { lat, lng } = e.latlng;
      if (state.layupMarker) state.layupMarker.remove();
      state.layupMarker = L.marker([lat,lng], { icon: ICONS.LAYUP, title:'LAYUP' }).addTo(map);
      updateLayupBox();
    });
    function updateLayupBox(){
      const box = $('#layupBox');
      const text = $('#layupText');
      const h = state.course?.holes?.[String(state.hole)];
      const mid = h?.pins?.MID || null;
      if (!state.layupMarker){ box.style.display='none'; return; }
      const ll = state.layupMarker.getLatLng();
      const P = { lat: ll.lat, lng: ll.lng };
      let cartDist = 'â€”', midDist = 'â€”';
      const cart = fromCart();
      if (cart) cartDist = fmt(haversine(cart, P));
      if (mid)  midDist  = fmt(haversine(P, mid));
      text.textContent = `Layup: CARTâ†’P ${cartDist} ${state.unit}   â€¢   Pâ†’MID ${midDist} ${state.unit}`;
      box.style.display='grid';
    }
    $('#clearLayupBtn').addEventListener('click', ()=>{
      if (state.layupMarker){ state.layupMarker.remove(); state.layupMarker=null; }
      updateLayupBox();
    });

    // ---------- Scorecard ----------
    function scoreKey(){ return `score_${state.course?.course?.id || state.meta?.id || 'course'}`; }
    function histKey(){ return `history_${state.course?.course?.id || state.meta?.id || 'course'}`; }

    function rebuildPlayersGrid(){
      const grid = $('#playersGrid');
      const count = parseInt($('#playerCount').value,10);
      grid.innerHTML = '';
      for (let i=0;i<count;i++){
        const wrap = document.createElement('div');
        wrap.innerHTML = `
          <div style="display:grid; gap:6px; padding:8px; border:1px solid #1f2937; border-radius:12px; background:#0f0f0f;">
            <div style="font-weight:800; text-align:center;">Player ${i+1}</div>
            <input class="nameInp" placeholder="Name" value="P${i+1}">
            <input class="hcapInp" type="number" step="1" min="0" max="54" placeholder="Handicap" value="${i===0?12: (i===1?18:(i===2?24:10))}">
          </div>
        `;
        grid.appendChild(wrap);
      }
    }
    $('#playerCount').addEventListener('change', rebuildPlayersGrid);

    function strokesReceived(hcap, holeStrokeIndex){
      const base = Math.floor(hcap / 18);
      const rem = hcap % 18;
      return base + (holeStrokeIndex <= rem ? 1 : 0);
    }
    function stablefordPoints(par, gross, recv){
      if (!Number.isFinite(par) || !Number.isFinite(gross)) return 0;
      const net = gross - (recv||0);
      const diff = net - par;
      if (diff >= 2) return 0;
      if (diff === 1) return 1;
      if (diff === 0) return 2;
      if (diff === -1) return 3;
      if (diff === -2) return 4;
      return 5;
    }
    function buildScoreTable(players, useHcaps){
      const holes = state.course?.holes || {};
      const ordered = Object.keys(holes).map(k=>+k).sort((a,b)=>a-b);
      const tbl = $('#scoreTable');
      let html = '<tr><th>Hole</th>';
      ordered.forEach(n=> html += `<th>${n}</th>`);
      html += '</tr><tr><th>Par</th>';
      ordered.forEach(n=> html += `<td>${holes[n]?.par ?? ''}</td>`);
      html += '</tr><tr><th>Stroke</th>';
      ordered.forEach(n=> html += `<td>${holes[n]?.stroke ?? ''}</td>`);
      html += '</tr>';
      players.forEach((p, idx)=>{
        html += `<tr><th style="text-align:left">${p.name} ${useHcaps?`(H${p.hcap})`:''}</th>`;
        ordered.forEach(n=>{ html += `<td><input class="strokes" data-player="${idx}" data-hole="${n}" value=""></td>`; });
        html += '</tr>';
      });
      html += '<tr><th>Gross</th>' + ordered.map(()=>'<td class="grossCell">â€“</td>').join('') + '</tr>';
      html += '<tr><th>Net</th>'   + ordered.map(()=>'<td class="netCell">â€“</td>').join('')   + '</tr>';
      html += '<tr><th>Points</th>'+ ordered.map(()=>'<td class="ptsCell">â€“</td>').join('')   + '</tr>';
      tbl.innerHTML = html;
    }
    function collectRound(players, useHcaps){
      const holes = state.course?.holes || {};
      const ordered = Object.keys(holes).map(k=>+k).sort((a,b)=>a-b);
      const round = players.map(p => ({ name:p.name, hcap:p.hcap, gross:0, net:0, points:0 }));
      $$('#scoreTable input.strokes').forEach(inp=>{
        const playerIdx = parseInt(inp.dataset.player,10);
        const holeNo = parseInt(inp.dataset.hole,10);
        const v = parseInt(inp.value,10);
        if (!Number.isFinite(v)) return;
        const par = holes[holeNo]?.par ?? null;
        const strokeIdx = holes[holeNo]?.stroke ?? null;
        const recv = useHcaps ? strokesReceived(round[playerIdx].hcap, strokeIdx||18) : 0;
        const net = v - recv;
        const pts = stablefordPoints(par, v, recv);
        round[playerIdx].gross += v;
        round[playerIdx].net   += Number.isFinite(net) ? net : 0;
        round[playerIdx].points+= pts;
      });
      return round;
    }

    function openScore(){
      $('#scoreTitle').textContent = `Scorecard â€” ${state.course?.course?.name || 'Course'}`;
      $('#scoreSetup').style.display = 'block';
      $('#scoreBody').style.display  = 'none';
      rebuildPlayersGrid();
      $('#scoreModal').style.display='grid';
    }
    function closeScore(){ $('#scoreModal').style.display='none'; }

    $('#createCard').addEventListener('click', ()=>{
      const count = parseInt($('#playerCount').value,10);
      const useH = $('#useHandicaps').checked;
      const ps = [];
      const nameEls = $$('.nameInp');
      const hcapEls = $$('.hcapInp');
      for (let i=0;i<count;i++){
        const name = (nameEls[i].value||`P${i+1}`).trim();
        let hcap = parseInt(hcapEls[i].value,10);
        if (!Number.isFinite(hcap) || hcap<0) hcap = 0;
        ps.push({ name, hcap });
      }
      buildScoreTable(ps, useH);
      $('#scoreBody').dataset.players = JSON.stringify(ps);
      $('#scoreBody').dataset.useH = useH ? '1' : '0';
      $('#scoreSetup').style.display = 'none';
      $('#scoreBody').style.display  = 'block';
    });
    $('#closeSetup').addEventListener('click', closeScore);
    $('#closeScore').addEventListener('click', closeScore);

    $('#saveRound').addEventListener('click', ()=>{
      const ps = JSON.parse($('#scoreBody').dataset.players || '[]');
      const useH = $('#scoreBody').dataset.useH === '1';
      const results = collectRound(ps, useH);
      const entry = {
        course: state.course?.course?.name || 'Course',
        id    : state.course?.course?.id   || state.meta?.id || 'course',
        ts    : Date.now(),
        useHandicaps: useH,
        players: results
      };
      const key = histKey();
      const arr = JSON.parse(localStorage.getItem(key) || '[]');
      arr.unshift(entry);
      while (arr.length>10) arr.pop();
      localStorage.setItem(key, JSON.stringify(arr));
      toast('Round saved');
      closeScore();
    });

    function openHist(){
      const div = $('#histList');
      const arr = JSON.parse(localStorage.getItem(histKey()) || '[]');
      if (!arr.length){ div.innerHTML = '<p style="margin:10px 0; color:#9ca3af;">No rounds yet.</p>'; }
      else {
        const out = arr.map(r=>{
          const dt = new Date(r.ts).toLocaleString();
          const rows = r.players.map(p=>`
            <div style="display:grid;grid-template-columns:1fr auto auto auto;gap:10px;">
              <div><strong>${p.name}</strong>${r.useHandicaps?` <span style="color:#9ca3af;">(H${p.hcap})</span>`:''}</div>
              <div>Gross: <strong>${p.gross}</strong></div>
              <div>Net: <strong>${p.net}</strong></div>
              <div>Pts: <strong>${p.points}</strong></div>
            </div>
          `).join('');
          return `
            <div style="border-bottom:1px solid #1f2937; padding:10px 0;">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                <div><strong>${r.course}</strong></div>
                <div style="color:#9ca3af;font-size:12px;">${dt}</div>
              </div>
              ${rows}
            </div>
          `;
        }).join('');
        div.innerHTML = out;
      }
      $('#histModal').style.display='grid';
    }
    function closeHist(){ $('#histModal').style.display='none'; }
    function clearHistory(){
      if (!confirm('Clear the last 10 rounds history?')) return;
      localStorage.removeItem(histKey());
      $('#histList').innerHTML = '<p style="margin:10px 0; color:#9ca3af;">History cleared.</p>';
    }
    $('#historyBtn').addEventListener('click', openHist);
    $('#closeHist').addEventListener('click', closeHist);
    $('#clearHist').addEventListener('click', clearHistory);
    $('#scoreBtn').addEventListener('click', openScore);

    // No-go zones (NOGO / NO_GO / NO_GO_ZONES)
    function pointInPoly(pt, poly){
      let x=pt.lat, y=pt.lng, inside=false;
      for (let i=0,j=poly.length-1; i<poly.length; j=i++){
        let xi=poly[i].lat, yi=poly[i].lng, xj=poly[j].lat, yj=poly[j].lng;
        let intersect=((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12) + xi);
        if (intersect) inside=!inside;
      }
      return inside;
    }
    window.__nogoZones = [];
    function loadNoGoForHole(h){
      window.__nogoZones = [];
      const pins = (h && h.pins) || {};
      const cand = [].concat(pins.NOGO||[], pins.NO_GO||[], pins.NO_GO_ZONES||[]);
      cand.forEach(zone => {
        if (Array.isArray(zone) && zone.length && zone[0].lat!==undefined) window.__nogoZones.push(zone);
        else if (Array.isArray(zone)) zone.forEach(z=> Array.isArray(z) && z.length && z[0].lat!==undefined && window.__nogoZones.push(z));
      });
    }

    // Boot
    (async function boot(){
      try{
        const idx = await getIndex();
        const meta = await pickCourseFromIndex(idx);
        if (!meta){ alert('No courses in index.json'); return; }
        const course = await loadCourseJson(meta.id);

        state.meta = meta; state.course = course;
        $('#courseTitle').textContent = course.course?.name || meta.name || 'Course';

        const startHole = parseInt(q('hole') || '1', 10);
        state.hole = startHole;

        // Load initial no-go data
        const h0 = course.holes[String(state.hole)];
        loadNoGoForHole(h0||{});

        renderHole();
        toast(navigator.onLine ? 'Course loaded (online)' : 'Course loaded (offline cached)');
      }catch(e){
        console.error(e);
        alert('Failed to load course data');
      }
    })();

    // Track cart movement for no-go alert + dynamic frame
    if (!window.__patchedUpdateCart){
      window.__patchedUpdateCart = true;
      window.__wasInNoGo = false;
      const origUpdate = updateCartAndChips;
      updateCartAndChips = function(){
        origUpdate();
        try{
          const cm = state.cartMarker;
          if (!cm) return;
          const ll = cm.getLatLng();
          const pt = {lat: ll.lat, lng: ll.lng};
          let inside = false;
          for (const poly of (window.__nogoZones||[])){ if (pointInPoly(pt, poly)) { inside = true; break; } }
          if (inside && !window.__wasInNoGo){
            window.__wasInNoGo = true;
            try{
              const ctx = new (window.AudioContext || window.webkitAudioContext)();
              const o = ctx.createOscillator(); const g = ctx.createGain();
              o.type='sine'; o.frequency.value=880; o.connect(g); g.connect(ctx.destination);
              o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, 350);
            }catch(e){}
            const t = document.getElementById('toast');
            if (t){ t.textContent='Please stay clear of greens / no-go zones.'; t.style.display='block'; setTimeout(()=> t.style.display='none', 2500); }
          }
          if (!inside) window.__wasInNoGo = false;

          // Keep CART & BACK in frame when moving
          const p = state.course.holes[String(state.hole)]?.pins || {};
          if (p.BACK){
            fitBetween([ll.lat,ll.lng],[p.BACK.lat,p.BACK.lng]);
          }
        }catch(e){}
      };
    }

    // Re-load no-go when hole changes (after renderHole runs)
    const _origRender = renderHole;
    renderHole = function(){
      _origRender();
      try{
        const h = state.course?.holes?.[String(state.hole)];
        loadNoGoForHole(h||{});
      }catch(e){}
    };
  </script>
</body>
</html>
