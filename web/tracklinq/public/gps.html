<!DOCTYPE html>
<html lang="en">
<head>

<link rel="manifest" href="/manifest.webmanifest?v=5">
<meta name="theme-color" content="#000000">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="/icons/icon-192.png">

  
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TrackLinq GPS</title>

  <link rel="manifest" href="/manifest.webmanifest">

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    /* THEME */
    :root{
      /* light-green default */
      --bg: #f7faf7;
      --panel: #ffffff;
      --text: #0a0a0a;
      --muted:#6b7280;
      --border:#dbe5d9;
      --chip:#ffffff;
      --chip-border:#dbe5d9;
      --accent:#16a34a;
      --accent-2:#22c55e;
      --accent-3:#86efac;
      --danger:#ef4444;
      --warning:#f59e0b;
      --info:#0ea5e9;
      --shadow: 0 6px 18px rgba(0,0,0,0.08);
    }
    body[data-theme="dark"]{
      --bg:#000;
      --panel:#0b0b0b;
      --text:#fff;
      --muted:#9ca3af;
      --border:#2a2a2a;
      --chip:#0b0b0b;
      --chip-border:#2a2a2a;
      --accent:#16a34a;
      --accent-2:#10b981;
      --accent-3:#064e3b;
      --danger:#ef4444;
      --warning:#fbbf24;
      --info:#60a5fa;
      --shadow: 0 6px 18px rgba(0,0,0,0.4);
    }

    html, body { height: 100%; margin: 0; background: var(--bg); color:var(--text); font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; }
    #map { width: 100%; height: 100%; }

    /* Top full-width course banner */
    .banner {
      position: absolute; top: 0; left: 0; right: 0; z-index: 1100;
      background: var(--panel); color: var(--text);
      border-bottom: 1px solid var(--border);
      display: grid; grid-template-columns: 80px 1fr 80px; align-items: center;
      padding: 8px 10px; box-shadow: var(--shadow);
    }
    .banner h1 { margin: 0; text-align: center; font-size: 16px; font-weight: 800; }
    .banner .left, .banner .right { display: flex; align-items: center; justify-content: center; gap: 6px; }
    .btn {
      cursor: pointer; padding: 8px 10px; border-radius: 10px;
      border: 1px solid var(--border); background: var(--chip); color: var(--text); font-weight: 800;
    }

    /* Hole bar: Par | HOLE | Stroke */
    .holeBar {
      position: absolute; top: 56px; left: 50%; transform: translateX(-50%);
      z-index: 1050; display: inline-flex; align-items: center; gap: 14px;
      background: var(--panel); color: var(--text); border: 1px solid var(--border);
      padding: 8px 12px; border-radius: 12px; font-weight: 800; box-shadow: var(--shadow);
    }
    .holeMeta { display:flex; gap:18px; align-items:center; }
    .holeMeta .par, .holeMeta .stroke { font-size: 12px; color: var(--muted); }
    .holeMeta .holeNo { font-size: 20px; font-weight: 900; }

    /* Distances (top-left) stacked vertical, MID larger; unit toggle here */
    .distStack {
      position: absolute; top: 112px; left: 12px; z-index: 1050;
      display: grid; gap: 8px; min-width: 170px;
    }
    .chipV {
      display: grid; grid-template-columns: 14px 1fr auto; align-items: center;
      gap: 8px; padding: 10px 12px; border-radius: 14px;
      background: var(--panel); border: 1px solid var(--chip-border); color: var(--text); box-shadow: var(--shadow);
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .midTxt { font-size: 18px; font-weight: 900; }  /* MID larger */
    .smallTxt { font-size: 12px; font-weight: 700; }
    .unitToggle {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 8px 10px; border-radius: 999px; background: var(--panel);
      border: 1px solid var(--chip-border); color: var(--text); font-weight: 800; cursor: pointer; width: max-content; box-shadow: var(--shadow);
    }

    /* Bottom-left stacked icons: flag & cart (lowered to match bottom padding) */
    .viewIcons {
      position: absolute; left: 12px; bottom: 12px; z-index: 1050;
      display: grid; gap: 8px;
    }
    .viewBtn {
      width: 52px; height: 52px; display: grid; place-items: center;
      border-radius: 14px; background: var(--panel); border: 1px solid var(--chip-border); color: var(--text); cursor: pointer;
      font-size: 24px; user-select: none; box-shadow: var(--shadow);
    }

    /* Bottom-center bubbles: Scorecard & History */
    .bottomBubbles {
      position: absolute; left: 50%; transform: translateX(-50%); bottom: 12px; z-index: 1050;
      display: flex; gap: 10px;
    }
    .bubbleBtn {
      cursor: pointer; padding: 10px 14px; border-radius: 999px; background: var(--panel); border: 1px solid var(--chip-border); color: var(--text); font-weight: 800; box-shadow: var(--shadow);
    }

    /* Floating clear layup button just above bottom bubbles */
    .clearLayupFloating {
      position: absolute; left: 50%; transform: translateX(-50%); bottom: 64px; z-index: 1050;
      display:none;
    }
    .clearLayupFloating .btn { background: var(--panel); }

    /* Modals */
    .modalBack {
      position: fixed; inset: 0; background: rgba(0,0,0,0.3); display: none; place-items: center; z-index: 1200;
    }
    .modal {
      width: min(92vw, 920px); max-height: 84vh; overflow: auto;
      background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 16px; padding: 14px; box-shadow: var(--shadow);
    }
    .modal h2 { margin: 0 0 10px; font-size: 18px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 8px; border-bottom: 1px solid var(--border); text-align: center; }
    input.strokes, input.nameInp, input.hcapInp {
      width: 70px; padding: 6px; border-radius: 8px; border: 1px solid var(--border); background: var(--chip); color: var(--text); text-align: center;
    }
    .modalActions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px; }

    /* Hide Leaflet UI */
    .leaflet-control-container { display: none !important; }
    .leaflet-bottom.leaflet-right { display: none !important; }

    /* Layup label bubble (bigger) */
    .layupLabel{
      background: var(--panel); color: var(--text);
      border: 1px solid var(--chip-border); padding: 6px 8px; border-radius: 10px;
      font-size: 14px; font-weight: 900; box-shadow: var(--shadow);
     white-space:nowrap; padding-left:14px; padding-right:14px; line-height:1;}

    /* Theme toggle */
    .themeBtn { border-color: var(--accent-3); }
  
/* --- Layup box sizing fix --- */
#layupBox, .layupBox { 
  display: grid;
  align-self: start;
  width: auto;
  max-width: none;
}
#layupText { 
  white-space: nowrap;
  overflow: visible;
}


    /* rules/penalties theme fix v2 */
    #rulesBtn.bubbleBtn, #penaltiesBox.bubbleBtn {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--chip-border);
      transition: background 0.3s, color 0.3s;
    }
  
/* === Rules & Penalties theme integration (override inline light styles) === */
#rulesBtnMini,
#penBtnMini {
  background: var(--panel) !important;
  color: var(--text) !important;
  border: 1px solid var(--chip-border) !important;
  box-shadow: var(--shadow) !important;
}

#penBtnMini .penSwitch {
  background: var(--chip) !important;
  border: 1px solid var(--chip-border) !important;
}

#penBtnMini .penSwitch [data-role="knob"] {
  background: var(--panel) !important;
}

#rulesModalMini .modalMini {
  background: var(--panel) !important;
  color: var(--text) !important;
  border: 1px solid var(--chip-border) !important;
}

#rulesModalMini .modalMini h2,
#rulesModalMini .modalMini h3,
#rulesModalMini .modalMini p,
#rulesModalMini .modalMini li,
#rulesModalMini .modalMini span,
#rulesModalMini .modalMini div {
  color: var(--text) !important;
}

/* Optional: bubbleBtn variants if ever applied */
#rulesBtn.bubbleBtn, #penaltiesBox.bubbleBtn {
  background: var(--panel) !important;
  color: var(--text) !important;
  border: 1px solid var(--chip-border) !important;
}


/* === Penalties switch theme-safe styles === */
#penSwitch {
  background: var(--chip) !important;
  border: 1px solid var(--chip-border) !important;
}
#penSwitch.on {
  background: var(--accent) !important;
  border-color: var(--accent-2) !important;
}
#penSwitch [data-role="knob"] {
  background: var(--panel) !important;
}

</style>
</head>
<body data-theme="light">
  <div id="map"></div>

  <!-- Rules & Penalties (top-right) -->
  <div class="topRightCol" style="position:absolute;top:108px;right:10px;z-index:1000;display:flex;flex-direction:column;gap:8px;">
    <button class="btnMini" id="rulesBtnMini" style="border:1px solid #e5e7eb;background:#ffffffee;color:#111827;border-radius:12px;padding:10px 14px;font-weight:800;cursor:pointer;box-shadow:0 4px 16px rgba(0,0,0,.12);">Rules</button>
    <button class="btnMini" id="penBtnMini" style="border:1px solid #e5e7eb;background:#ffffffee;color:#111827;border-radius:12px;padding:10px 14px;font-weight:800;cursor:pointer;box-shadow:0 4px 16px rgba(0,0,0,.12);display:flex;align-items:center;justify-content:space-between;gap:10px;min-width:160px;">
      <span>Penalties</span>
      <div class="penSwitch" id="penSwitch" style="position:relative;width:44px;height:24px;border-radius:999px;background:#ddd;border:1px solid #cfcfcf;flex:0 0 auto;">
        <div style="position:absolute;top:2px;left:2px;width:18px;height:18px;border-radius:999px;background:#fff;transition:all .2s;" data-role="knob"></div>
      </div>
    </button>
  </div>

  <!-- Rules modal -->
  <div class="modalBackMini" id="rulesModalMini" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.45);place-items:center;z-index:1600;">
    <div class="modalMini" style="width:min(92vw,880px);max-height:84vh;overflow:auto;background:#fff;color:#0b0b0b;border:1px solid #00000022;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);">
      <h2 style="margin:0 0 10px;font-size:18px;display:flex;align-items:center;justify-content:space-between;">
        <span>Official Rules (Reference)</span>
        <button class="btnMini" id="rulesCloseMini" style="border:1px solid #ddd;background:#f5f5f5;color:#111;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer;">Close</button>
      </h2>
      <div id="rulesBodyMini">
        <p>This panel supports <strong>rich HTML</strong> (images, links, embeds).</p>
        <ul>
          <li><a href="https://www.randa.org/rog/the-rules-of-golf" target="_blank" rel="noopener">R&amp;A â€” Rules of Golf</a></li>
          <li><a href="https://www.usga.org/content/usga/home-page/rules-hub.html" target="_blank" rel="noopener">USGA â€” Rules Hub</a></li>
          <li><a href="https://www.pgatour.com/fan-relations/rules" target="_blank" rel="noopener">PGA TOUR â€” Rules &amp; Resources</a></li>
        </ul>
      </div>
    </div>
  </div>


  <!-- Top course banner -->
  <div class="banner">
    <div class="left"></div>
    <h1 id="courseTitle">Course</h1>
    <div class="right">
      <button class="btn themeBtn" id="themeBtn">ðŸŒž</button>
      <button class="btn" id="exitBtn">Exit</button>
    </div>
  </div>

  <!-- Center hole bar -->
  <div class="holeBar">
    <button class="btn" id="prevHole">â—€ï¸Ž</button>
    <div class="holeMeta">
      <div class="par">Par <span id="par">4</span></div>
      <div class="holeNo">Hole <span id="holeNo">1</span></div>
      <div class="stroke">Stroke <span id="stroke">1</span></div>
    </div>
    <button class="btn" id="nextHole">â–¶ï¸Ž</button>
  </div>

  <!-- Distances stack -->
  <div class="distStack">
    <div class="chipV">
      <span class="dot" style="background:#ffffff"></span>
      <span class="smallTxt">FRONT</span>
      <span id="dFront" class="smallTxt">â€“</span>
    </div>
    <div class="chipV">
      <span class="dot" style="background:#fbbf24"></span>
      <span class="midTxt">MID</span>
      <span id="dMid" class="midTxt">â€“</span>
    </div>
    <div class="chipV">
      <span class="dot" style="background:#ef4444"></span>
      <span class="smallTxt">BACK</span>
      <span id="dBack" class="smallTxt">â€“</span>
    </div>

    <div class="unitToggle" id="unitBtn">Units: <span id="unitChip">m</span></div>
  </div>

  <!-- Bottom-left stacked view icons -->
  <div class="viewIcons">
    <button title="Hole View (TEEâ†”BACK)" class="viewBtn" id="holeViewBtn">â›³</button>
    <button title="Cart View (CARTâ†”BACK)" class="viewBtn" id="cartViewBtn">ðŸ›º</button>
  </div>

  <!-- Floating clear layup -->
  <div class="clearLayupFloating" id="clearLayupFloating">
    <button class="btn" id="clearLayupBtn">CLEAR LAYUP</button>
  </div>

  <!-- Bottom-center bubbles -->
  <div class="bottomBubbles">
    <button class="bubbleBtn" id="scoreBtn">Scorecard</button>
    <button class="bubbleBtn" id="historyBtn">History</button>
  </div>

  <!-- Scorecard modal -->
  <div class="modalBack" id="scoreModal">
    <div class="modal">
      <h2 id="scoreTitle">Scorecard</h2>

      <!-- Setup panel -->
      <div id="scoreSetup">
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:10px;">
          <label>Players:</label>
          <select id="playerCount">
            <option>1</option><option>2</option><option selected>3</option><option>4</option>
          </select>
          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="useHandicaps" checked/> Use handicaps (for points only)
          </label>
        </div>
        <div id="playersGrid" style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-bottom:10px;"></div>
        <div class="modalActions">
          <button class="btn" id="createCard">Create scorecard</button> <button class="btn" id="closeSetup">Close</button>
        </div>
        <hr style="border-color:var(--border); margin:12px 0;">
      </div>

      <!-- Card table -->
      <div id="scoreBody" style="display:none;">
        <div style="overflow:auto;">
          <table id="scoreTable"></table>
        </div>
        <div class="modalActions">
          <button class="btn" id="clearScore">Clear Scorecard</button>
          <button class="btn" id="closeScore">Close</button>
          <button class="btn" id="saveRound">Save Round</button>
        </div>
      </div>
    </div>
  </div>

  <!-- History modal -->
  <div class="modalBack" id="histModal">
    <div class="modal">
      <h2>Last 10 Rounds</h2>
      <div id="histList"></div>
      <div class="modalActions">
        <button class="btn" id="closeHist">Close</button>
        <button class="btn" id="clearHist">Clear History</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" style="display:none; position: absolute; left: 50%; transform: translateX(-50%); bottom: 12px; z-index: 1300; background: var(--panel); color:var(--text); border:1px solid var(--chip-border); padding:8px 12px; border-radius:10px; font-size:12px; box-shadow:var(--shadow);"></div>

  <script>
    // Register SW
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => navigator.serviceWorker.register('/sw.js'));
    }

    // Helpers
    const $  = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);
    function q(name){ return new URL(location.href).searchParams.get(name); }
    function toast(msg, ms=1600){ const t=$('#toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', ms); }

    // Theme toggle
    (function(){
      const saved = localStorage.getItem('tl_theme') || 'light';
      document.body.setAttribute('data-theme', saved);
      $('#themeBtn').textContent = saved==='dark'?'ðŸŒš':'ðŸŒž';
      $('#themeBtn').addEventListener('click', ()=>{
        const cur = document.body.getAttribute('data-theme')==='dark'?'light':'dark';
        document.body.setAttribute('data-theme', cur);
        localStorage.setItem('tl_theme', cur);
        $('#themeBtn').textContent = cur==='dark'?'ðŸŒš':'ðŸŒž';
      });
    })();

    // Icons
    function dotIcon(color='#ffffff', size=12){
      const r=Math.floor(size/2);
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'>
          <circle cx='${r}' cy='${r}' r='${r}' fill='${color}' />
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[r,r] });
    }
    function largeSymbolIcon(svgPath, size=36){
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 40 40'>${svgPath}</svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[size/2,size/2] });
    }
    
    const TOILET_SVG = `
      <!-- background -->
      <rect x='2' y='2' width='36' height='36' rx='8' fill='#6b7280'/>
      <!-- female (left) -->
      <circle cx='14' cy='14' r='2.2' fill='white'/>
      <path d='M10 22 L14 16 L18 22 Z' fill='white'/> <!-- dress -->
      <rect x='12.4' y='22' width='3.2' height='7' rx='1.2' fill='white'/> <!-- legs block -->
      <!-- male (right) -->
      <circle cx='26' cy='14' r='2.2' fill='white'/>
      <rect x='24.2' y='16.3' width='3.6' height='5.8' rx='1' fill='white'/> <!-- torso -->
      <rect x='23.8' y='22' width='2.2' height='7' rx='1.2' fill='white'/> <!-- left leg -->
      <rect x='27' y='22' width='2.2' height='7' rx='1.2' fill='white'/>   <!-- right leg -->
      <rect x='22.5' y='17.8' width='2.2' height='3.2' rx='1' fill='white'/> <!-- left arm -->
      <rect x='28.5' y='17.8' width='2.2' height='3.2' rx='1' fill='white'/> <!-- right arm -->
    `;

    const TAP_SVG = `
      <!-- background -->
      <rect x='2' y='2' width='36' height='36' rx='8' fill='#0ea5e9'/>
      <!-- handle -->
      <rect x='10' y='10' width='10' height='2.4' rx='1.2' fill='white'/>
      <rect x='14.8' y='8' width='2.4' height='4.8' rx='1.2' fill='white'/>
      <!-- spout (curved) -->
      <path d='M17 14 C 22 14, 24 16, 26 18 C 27.2 19.2, 27.2 21, 26 22.2
               C 24.8 23.4, 23 23.4, 21.8 22.2 C 21.1 21.5, 20.8 20.6, 20.8 19.8
               L20.8 19.5 L18.6 19.5 C 17.7 19.5, 17 18.8, 17 17.9 Z' fill='white'/>
      <!-- droplet -->
      <path d='M25.4 25.6 C 24.6 26.8, 24.2 27.8, 24.2 28.7
               C 24.2 30.1, 25.3 31.2, 26.7 31.2 C 28.1 31.2, 29.2 30.1, 29.2 28.7
               C 29.2 27.8, 28.8 26.8, 28.0 25.6 Z' fill='white'/>
    `;
const ICONS = {
      TEE: dotIcon('#16a34a', 14),

FRONT: dotIcon('transparent', 12), 
BACK:  dotIcon('transparent', 12), 

      MID: dotIcon('#fbbf24', 12),
      TOILET: largeSymbolIcon(TOILET_SVG, 36),
      TAPS: largeSymbolIcon(TAP_SVG, 36),
      STAKE_WHITE: dotIcon('#ffffff', 8),
      STAKE_RED: dotIcon('#ef4444', 8),
      STAKE_YELLOW: dotIcon('#fbbf24', 8),
      CART: L.divIcon({className:'', html:'<div style=\"font-size:26px;line-height:1\">ðŸ›º</div>', iconSize:[26,26], iconAnchor:[13,13]}),
      LAYUP: dotIcon('#111111', 12)
    };

    // Map (Esri; no visible Leaflet controls)
    const map = L.map('map', { zoomControl:false, attributionControl:false }).setView([-25.746, 28.229], 17);
    L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19 }
    ).addTo(map);

    // Data (cache-first)
    async function getIndex(){
      let res=await caches.match('/courses/index.json');
      if(!res) res=await fetch('/courses/index.json', { cache:'reload' });
      return res.json();
    }
    async function loadCourseJson(id){
      const url=`/courses/${id}.json`;
      let res=await caches.match(url);
      if(!res) res=await fetch(url, { cache:'reload' });
      return res.json();
    }
    async function pickCourseFromIndex(idx){
      const want=(q('course')||'').trim();
      if(want){
        const c=(idx.courses||[]).find(x=>x.id.toUpperCase()===want.toUpperCase());
        if(c) return c;
      }
      return (idx.courses||[])[0]||null;
    }

    // PIN/guest
    function isGuestMode(){
      const g = (q('guest')||'').trim();
      return g === '1';
    }

    async function validatePinFlow(courseId, courseJson){
      if(isGuestMode()){
        localStorage.setItem(`mode_${courseId}`, 'guest');
        return true;
      }
      const pinFromUrl=(q('pin')||'').trim().toUpperCase();
      if(pinFromUrl.length===10){
        localStorage.setItem(`pin_${courseId}`, pinFromUrl);
        const ok = await isPinValid(courseId, courseJson, pinFromUrl);
        localStorage.setItem(`mode_${courseId}`, ok ? 'club' : 'guest');
        return ok;
      }
      const stored=(localStorage.getItem(`pin_${courseId}`)||'').trim().toUpperCase();
      if(stored.length===10 && await isPinValid(courseId, courseJson, stored)){
        localStorage.setItem(`mode_${courseId}`, 'club');
        return true;
      }
      const entered=(prompt(`Enter PIN for ${courseJson?.course?.name || courseId}:`)||'').trim().toUpperCase();
      if(entered.length!==10) return false;
      const ok=await isPinValid(courseId, courseJson, entered);
      if(ok){
        localStorage.setItem(`pin_${courseId}`, entered);
        localStorage.setItem(`mode_${courseId}`, 'club');
      }else{
        alert('Invalid PIN');
      }
      return ok;
    }
    async function isPinValid(courseId, courseJson, candidate){
      if(!candidate||candidate.length!==10) return false;
      try{
        const idx=await getIndex();
        const c=(idx.courses||[]).find(x=>x.id===courseId);
        if(c?.pin && c.pin.trim().toUpperCase()===candidate) return true;
      }catch(_){}
      const metaPin=(courseJson?.course?.pin||'').trim().toUpperCase();
      if(metaPin && metaPin===candidate) return true;
      return false;
    }

    // State
    const state = {
      meta:null, course:null, hole:1, markers:[], cartMarker:null,
      unit:'m', // 'm' or 'yd'
      layupMarker:null, layupSolid:null, layupDash:null, layupLabel1:null, layupLabel2:null,
      initialFramed:false
    };

    // Distance helpers
    const toRad = d => d*Math.PI/180;
    function haversine(a,b){
      const R=6371000, dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
      const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
      const aa=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
      return 2*R*Math.atan2(Math.sqrt(aa),Math.sqrt(1-aa));
    }
    const fmt = m => state.unit==='yd' ? Math.round(m*1.09361) : Math.round(m);
    function fromCart(){ if(state.cartMarker){ const ll=state.cartMarker.getLatLng(); return {lat:ll.lat,lng:ll.lng}; } return null; }
    function midPoint(a,b){ return { lat:(a.lat+b.lat)/2, lng:(a.lng+b.lng)/2 }; }
    function labelAt(ll, text){
      const div = L.divIcon({ className:'', html:`<div class="layupLabel">${text}</div>`, iconSize:null });
      return L.marker([ll.lat, ll.lng], { icon: div, interactive:false });
    }

    function fromPoint(pins, pref='CART'){
      if(pref==='TEE' && pins.TEE) return { lat:pins.TEE.lat, lng:pins.TEE.lng };
      return fromCart();
    }
    function updateChips(pins){
      const f=$('#dFront'), m=$('#dMid'), b=$('#dBack');
      f.textContent=m.textContent=b.textContent='â€“';
      const from = fromPoint(pins, 'CART') || fromPoint(pins,'TEE');
      if(!from) return;
      if(pins.FRONT) f.textContent=fmt(haversine(from, pins.FRONT));
      if(pins.MID)   m.textContent=fmt(haversine(from, pins.MID));
      if(pins.BACK)  b.textContent=fmt(haversine(from, pins.BACK));
      $('#unitChip').textContent = state.unit;
      updateLayupUI(); // keep layup distances/labels in sync
    }

    // Markers & fitting
    function clearMarkers(){ state.markers.forEach(m=>m.remove()); state.markers=[]; }
    function addMarker(lat,lng,icon,title=''){ const m=L.marker([lat,lng],{icon,title}).addTo(map); state.markers.push(m); return m; }
    function fitBetween(a,b){ const bounds=L.latLngBounds(L.latLng(a[0],a[1]),L.latLng(b[0],b[1])); map.fitBounds(bounds,{padding:[60,60]}); }

    function doHoleView(){
      const p = state.course.holes[String(state.hole)]?.pins || {};
      if (p.TEE && p.BACK) fitBetween([p.TEE.lat,p.TEE.lng],[p.BACK.lat,p.BACK.lng]);
    }
    function doCartView(){
      const p = state.course.holes[String(state.hole)]?.pins || {};
      const cart = fromCart();
      if (cart && p.BACK){ fitBetween([cart.lat,cart.lng],[p.BACK.lat,p.BACK.lng]); }
      else if (p.TEE && p.BACK){ fitBetween([p.TEE.lat,p.TEE.lng],[p.BACK.lat,p.BACK.lng]); } // fallback
    }
    function ensureInitialFraming(){
      if (state.initialFramed) return;
      state.initialFramed = true;
      doCartView();
    }

    function renderHole(){
      clearMarkers();
      const h = state.course.holes[String(state.hole)];
      $('#holeNo').textContent = state.hole;
      $('#par').textContent = h?.par ?? '-';
      $('#stroke').textContent = h?.stroke ?? '-';
      if(!h) return;

      const p = h.pins || {};
      if (p.TEE)   addMarker(p.TEE.lat, p.TEE.lng, ICONS.TEE, 'TEE');
      if (p.FRONT) addMarker(p.FRONT.lat, p.FRONT.lng, ICONS.FRONT, 'FRONT');
      if (p.MID)   addMarker(p.MID.lat, p.MID.lng, ICONS.MID, 'MID');
      if (p.BACK)  addMarker(p.BACK.lat, p.BACK.lng, ICONS.BACK, 'BACK');

      if (p.TOILET) addMarker(p.TOILET.lat, p.TOILET.lng, ICONS.TOILET, 'Toilet');
      (p.TAPS || []).forEach(t => addMarker(t.lat, t.lng, ICONS.TAPS, 'Drinking water'));
      (p.STAKE_WHITE || []).forEach(s => addMarker(s.lat, s.lng, ICONS.STAKE_WHITE, 'Stake (white)'));
      (p.STAKE_RED   || []).forEach(s => addMarker(s.lat, s.lng, ICONS.STAKE_RED, 'Stake (red)'));
      (p.STAKE_YELLOW|| []).forEach(s => addMarker(s.lat, s.lng, ICONS.STAKE_YELLOW, 'Stake (yellow)'));

      updateChips(p);
      ensureInitialFraming();
      updateLayupUI();
    }

    
    // View buttons
    function toggleStakes(show){
      (state.stakeMarkers || []).forEach(m=>{
        if(show){
          if(!map.hasLayer(m)) m.addTo(map);
        } else {
          if(map.hasLayer(m)) m.remove();
        }
      });
    }
    $('#holeViewBtn').addEventListener('click', doHoleView);
    $('#cartViewBtn').addEventListener('click', doCartView);

    // Hole nav
    $('#prevHole').addEventListener('click', ()=>{
      const min=1; state.hole=Math.max(min, state.hole-1); state.initialFramed=false; renderHole();
    });
    $('#nextHole').addEventListener('click', ()=>{
      const max=Math.max(...Object.keys(state.course.holes||{}).map(k=>+k).filter(Number.isFinite));
      state.hole=Math.min(max||state.hole+1, state.hole+1); state.initialFramed=false; renderHole();
    });

    // Units
    $('#unitBtn').addEventListener('click', ()=>{
      state.unit = state.unit==='m' ? 'yd' : 'm';
      const p = state.course.holes[String(state.hole)]?.pins || {};
      updateChips(p);
    });

    // Exit -> back to login
    $('#exitBtn').addEventListener('click', ()=>{ location.href = '/index.html'; });

    // Geolocation (watch for live CART updates)
    function updateCartAndChips(){
      const p = state.course.holes[String(state.hole)]?.pins || {};
      updateChips(p);
      updateLayupUI();
    }
    if (navigator.geolocation){
      navigator.geolocation.watchPosition((pos)=>{
        const { latitude, longitude } = pos.coords;
        if (!state.cartMarker) state.cartMarker = L.marker([latitude,longitude], { icon: ICONS.CART, title:'CART' }).addTo(map);
        else state.cartMarker.setLatLng([latitude,longitude]);
        updateCartAndChips();
      }, ()=>{}, { enableHighAccuracy:true, maximumAge:5000, timeout:10000 });
    }

    // LAYUP with lines and labels
    function toggleClearLayupBtn(){
      $('#clearLayupFloating').style.display = state.layupMarker ? 'block' : 'none';
    }
    function clearLayupGraphics(){
      if (state.layupSolid){ state.layupSolid.remove(); state.layupSolid=null; }
      if (state.layupDash){ state.layupDash.remove(); state.layupDash=null; }
      if (state.layupLabel1){ state.layupLabel1.remove(); state.layupLabel1=null; }
      if (state.layupLabel2){ state.layupLabel2.remove(); state.layupLabel2=null; }
    }
    function updateLayupUI(){
      const h = state.course?.holes?.[String(state.hole)];
      const p = h?.pins || {};
      const mid = p.MID || null;

      clearLayupGraphics();
      if (!state.layupMarker){ toggleClearLayupBtn(); return; }

      const ll = state.layupMarker.getLatLng();
      const P = { lat: ll.lat, lng: ll.lng };

      let cartSrc = fromCart();
      if (!cartSrc && p.TEE) cartSrc = { lat:p.TEE.lat, lng:p.TEE.lng }; // fallback when GPS not available

      if (cartSrc){
        const cartDist = fmt(haversine(cartSrc, P));
        state.layupSolid = L.polyline([[cartSrc.lat,cartSrc.lng],[P.lat,P.lng]], { color:'#111', weight:3, opacity:1 }).addTo(map);
        state.layupLabel1 = labelAt(midPoint(cartSrc,P), `${cartDist} ${state.unit}`).addTo(map);
      }
      if (mid){
        const midDist  = fmt(haversine(P, mid));
        state.layupDash = L.polyline([[P.lat,P.lng],[mid.lat,mid.lng]], { color:'#111', weight:3, opacity:1, dashArray:'6,6' }).addTo(map);
        state.layupLabel2 = labelAt(midPoint(P,mid), `${midDist} ${state.unit}`).addTo(map);
      }
      toggleClearLayupBtn();
    }
    map.on('click', (e)=>{
      const { lat, lng } = e.latlng;
      if (state.layupMarker) state.layupMarker.remove();
      state.layupMarker = L.marker([lat,lng], { icon: ICONS.LAYUP, title:'LAYUP' }).addTo(map);
      updateLayupUI();
    });
    $('#clearLayupBtn').addEventListener('click', ()=>{
      if (state.layupMarker){ state.layupMarker.remove(); state.layupMarker=null; }
      clearLayupGraphics();
      updateLayupUI();
    });

    // ---------- Scorecard (classic) with persistence, reopen, clear, and auto-advance ----------
    function histKey(){ return `history_${state.course?.course?.id || state.meta?.id || 'course'}`; }
    function scStateKey(){ return `sc_state_${state.course?.course?.id || state.meta?.id || 'course'}`; }

    function rebuildPlayersGrid(saved){
      const grid = $('#playersGrid');
      const count = saved ? saved.players.length : parseInt($('#playerCount').value,10);
      if (!saved) { grid.innerHTML = ''; }
      else { $('#playerCount').value = String(count); grid.innerHTML=''; }
      for (let i=0;i<count;i++){
        const wrap = document.createElement('div');
        const nameVal = saved ? (saved.players[i]?.name || `P${i+1}`) : `P${i+1}`;
        const hVal = saved ? (saved.players[i]?.hcap ?? 0) : (i===0?12: (i===1?18:(i===2?24:10)));
        wrap.innerHTML = `
          <div style="display:grid; gap:6px; padding:8px; border:1px solid var(--border); border-radius:12px; background: var(--chip);">
            <div style="font-weight:800; text-align:center;">Player ${i+1}</div>
            <input class="nameInp" placeholder="Name" value="${nameVal}">
            <input class="hcapInp" type="number" step="1" min="0" max="54" placeholder="Handicap" value="${hVal}">
          </div>
        `;
        grid.appendChild(wrap);
      }
    }
    $('#playerCount').addEventListener('change', ()=>rebuildPlayersGrid(null));

    function strokesReceived(hcap, holeStrokeIndex){
      const base = Math.floor(hcap / 18);
      const rem = hcap % 18;
      return base + (holeStrokeIndex <= rem ? 1 : 0);
    }
    function stablefordPoints(par, gross, recv){
      if (!Number.isFinite(par) || !Number.isFinite(gross)) return 0;
      const net = gross - (recv||0);
      const diff = net - par;
      if (diff >= 2) return 0;
      if (diff === 1) return 1;
      if (diff === 0) return 2;
      if (diff === -1) return 3;
      if (diff === -2) return 4;
      return 5;
    }

    function buildScoreTable(players, useHcaps, saved){
      const holes = state.course?.holes || {};
      const ordered = Object.keys(holes).map(k=>+k).sort((a,b)=>a-b);
      const front9 = ordered.filter(n => n <= 9);
      const back9  = ordered.filter(n => n > 9);
      const tbl = $('#scoreTable');

      let html = '<tr><th style="text-align:left;padding-left:12px;">Player</th>';
      front9.forEach(n=> html += `<th>${n}</th>`);
      html += `<th>OUT</th>`;
      back9.forEach(n=> html += `<th>${n}</th>`);
      html += `<th>IN</th><th>TOTAL</th><th>NET</th><th>PTS</th></tr>`;

const parOut = front9.reduce((s, n) => s + (Number(holes[n]?.par) || 0), 0);
const parIn  = back9.reduce((s, n) => s + (Number(holes[n]?.par) || 0), 0);
const parTot = parOut + parIn;

//Par indicator on scorecard with Par Total OUT IN TOTAL
html += '<tr><th style="text-align:left;padding-left:12px;">Par</th>';
front9.forEach(n => html += `<td>${holes[n]?.par ?? ''}</td>`);
html += `<td>${parOut}</td>`;
back9.forEach(n => html += `<td>${holes[n]?.par ?? ''}</td>`);
html += `<td>${parIn}</td><td>${parTot}</td><td>â€“</td><td>â€“</td></tr>`;


      // Stroke on scorecard
      html += '<tr><th style="text-align:left;padding-left:12px;">Stroke</th>';
      front9.forEach(n => html += `<td>${holes[n]?.stroke ?? ''}</td>`);
      html += `<td>â€“</td>`;
      back9.forEach(n => html += `<td>${holes[n]?.stroke ?? ''}</td>`);
      html += `<td>â€“</td><td>â€“</td><td>â€“</td><td>â€“</td></tr>`;


      players.forEach((p, idx)=>{
        html += `<tr><th style="text-align:left;padding-left:12px;">${p.name} ${useHcaps?`(H${p.hcap})`:''}</th>`;
        ordered.forEach(n=>{
          const val = saved?.strokes?.[idx]?.[n] ?? '';
          html += `<td><div class="cellWrap"><input class="strokes" data-player="${idx}" data-hole="${n}" inputmode="numeric" value="${val}"><div class="mini" data-player="${idx}" data-hole="${n}" style="font-size:10px;color:var(--muted);line-height:1;margin-top:2px;"></div></div></td>`;
        });
        html += `<td class="outCell" data-player="${idx}">0</td>`;
        html += `<td class="inCell" data-player="${idx}">0</td>`;
        html += `<td class="totCell" data-player="${idx}">0</td>`;
        html += `<td class="netCell" data-player="${idx}">0</td>`;
        html += `<td class="ptsCell" data-player="${idx}">0</td>`;
        html += `</tr>`;
      });

      tbl.innerHTML = html;
      $$('#scoreTable input.strokes').forEach(inp=>{
        inp.addEventListener('input', ()=>{
          recalcLive(players, useHcaps);
          persistScoreStateFromUI(players, useHcaps);
          autoAdvanceIfHoleComplete();
        });
      });
      recalcLive(players, useHcaps);
    }

    function recalcLive(players, useHcaps){
      const holes = state.course?.holes || {};
      const ordered = Object.keys(holes).map(k=>+k).sort((a,b)=>a-b);
      const front9 = ordered.filter(n => n <= 9);
      const back9  = ordered.filter(n => n > 9);

      const agg = players.map(p => ({ gross:0, net:0, points:0, out:0, inn:0 }));

      $$('#scoreTable input.strokes').forEach(inp=>{
        const playerIdx = parseInt(inp.dataset.player,10);
        const holeNo = parseInt(inp.dataset.hole,10);
        const v = parseInt(inp.value,10);
        if (!Number.isFinite(v)) return;
        const par = holes[holeNo]?.par ?? null;
        const strokeIdx = holes[holeNo]?.stroke ?? null;
        const recv = useHcaps ? strokesReceived(players[playerIdx].hcap, strokeIdx||18) : 0;
        // Update compact mini text under each score: Â± vs par and Stableford points (if handicaps in use)
        (function(){
          const mini = document.querySelector(`.mini[data-player="${playerIdx}"][data-hole="${holeNo}"]`);
          if (!mini) return;
          const diffOk = Number.isFinite(par) && Number.isFinite(v);
          const diff = diffOk ? (v - par) : null;
          const sgn  = (diff===0) ? 'E' : (diff>0 ? `+${diff}` : `${diff}`);
          if (useHcaps && diffOk){
            const pts = stablefordPoints(par, v, recv);
            mini.textContent = `${sgn} Â· ${pts}pt${pts===1?'':'s'}`;
          } else {
            mini.textContent = diffOk ? sgn : '';
          }
        })();

        const pts = stablefordPoints(par, v, recv);

        agg[playerIdx].gross += v;
        agg[playerIdx].points+= pts;
        if (front9.includes(holeNo)) agg[playerIdx].out += v;
        else agg[playerIdx].inn += v;
      });

      agg.forEach((a, idx)=>{
        const grossTotal = (a.out + a.inn) || 0;
        const netTotal = Math.max(0, grossTotal - (players[idx].hcap||0));
        const outCell = document.querySelector(`.outCell[data-player="${idx}"]`);
        const inCell  = document.querySelector(`.inCell[data-player="${idx}"]`);
        const totCell = document.querySelector(`.totCell[data-player="${idx}"]`);
        const netCell = document.querySelector(`.netCell[data-player="${idx}"]`);
        const ptsCell = document.querySelector(`.ptsCell[data-player="${idx}"]`);
        if (outCell) outCell.textContent = a.out || 0;
        if (inCell)  inCell.textContent  = a.inn || 0;
        if (totCell) totCell.textContent = grossTotal;
        if (netCell) netCell.textContent = netTotal;
        if (ptsCell) ptsCell.textContent = a.points || 0;
      });
    }

    function persistScoreStateFromUI(players, useHcaps){
      const strokes = {};
      $$('#scoreTable input.strokes').forEach(inp=>{
        const pi = parseInt(inp.dataset.player,10);
        const h  = parseInt(inp.dataset.hole,10);
        const v  = parseInt(inp.value,10);
        if (!strokes[pi]) strokes[pi] = {};
        if (Number.isFinite(v)) strokes[pi][h] = v;
      });
      const stateObj = { players, useHcaps, strokes, ts: Date.now(), active:true };
      localStorage.setItem(scStateKey(), JSON.stringify(stateObj));
    }

    function loadScoreState(){
      try {
        const raw = localStorage.getItem(scStateKey());
        if (!raw) return null;
        return JSON.parse(raw);
      } catch { return null; }
    }

    function autoAdvanceIfHoleComplete(){
      const hNo = state.hole;
      const inputs = $$('#scoreTable input.strokes');
      if (!inputs.length) return;
      const playersSet = new Set([...inputs].map(i=>i.dataset.player));
      for (const pi of playersSet){
        const cell = document.querySelector(`#scoreTable input.strokes[data-player="${pi}"][data-hole="${hNo}"]`);
        if (!cell || !cell.value || isNaN(parseInt(cell.value,10))) return;
      }
      setTimeout(()=>{
        const max=Math.max(...Object.keys(state.course.holes||{}).map(k=>+k).filter(Number.isFinite));
        if (hNo < max){
          state.hole = hNo + 1;
          state.initialFramed=false;
          renderHole();
        }
      }, 100);
    }

    function openScore(){
      $('#scoreTitle').textContent = `Scorecard â€” ${state.course?.course?.name || 'Course'}`;
      const saved = loadScoreState();
      if (saved && saved.active){
        // jump straight into the active scorecard
        $('#useHandicaps').checked = !!saved.useHcaps;
        rebuildPlayersGrid(saved);
        buildScoreTable(saved.players, saved.useHcaps, saved);
        $('#scoreBody').dataset.players = JSON.stringify(saved.players);
        $('#scoreBody').dataset.useH = saved.useHcaps ? '1' : '0';
        $('#scoreSetup').style.display = 'none';
        $('#scoreBody').style.display  = 'block';
      } else {
        rebuildPlayersGrid(null);
        $('#scoreSetup').style.display = 'block';
        $('#scoreBody').style.display  = 'none';
      }
      $('#scoreModal').style.display='grid';
    }
    function closeScore(){ $('#scoreModal').style.display='none'; }

    $('#createCard').addEventListener('click', ()=>{
      const count = parseInt($('#playerCount').value,10);
      const useH = $('#useHandicaps').checked;
      const ps = [];
      const nameEls = $$('.nameInp');
      const hcapEls = $$('.hcapInp');
      for (let i=0;i<count;i++){
        const name = (nameEls[i].value||`P${i+1}`).trim();
        let hcap = parseInt(hcapEls[i].value,10);
        if (!Number.isFinite(hcap) || hcap<0) hcap = 0;
        ps.push({ name, hcap });
      }
      const saved = loadScoreState();
      buildScoreTable(ps, useH, saved);
      $('#scoreBody').dataset.players = JSON.stringify(ps);
      $('#scoreBody').dataset.useH = useH ? '1' : '0';
      $('#scoreSetup').style.display = 'none';
      $('#scoreBody').style.display  = 'block';
      persistScoreStateFromUI(ps, useH);
    });

    $('#clearScore').addEventListener('click', ()=>{
      if (!confirm('Clear current scorecard?')) return;
      localStorage.removeItem(scStateKey());
      // Return to setup
      rebuildPlayersGrid(null);
      $('#scoreSetup').style.display = 'block';
      $('#scoreBody').style.display  = 'none';
    });

    $('#closeScore').addEventListener('click', closeScore);

    $('#saveRound').addEventListener('click', ()=>{
      const ps = JSON.parse($('#scoreBody').dataset.players || '[]');
      const useH = $('#scoreBody').dataset.useH === '1';

      const holes = state.course?.holes || {};
      const ordered = Object.keys(holes).map(k=>+k).sort((a,b)=>a-b);
      const front9 = ordered.filter(n => n <= 9);
      const back9  = ordered.filter(n => n > 9);

      const results = ps.map((p, idx)=>({ name:p.name, hcap:p.hcap, gross:0, net:0, points:0, out:0, inn:0 }));

      $$('#scoreTable input.strokes').forEach(inp=>{
        const i = parseInt(inp.dataset.player,10);
        const holeNo = parseInt(inp.dataset.hole,10);
        const v = parseInt(inp.value,10);
        if (!Number.isFinite(v)) return;
        const par = holes[holeNo]?.par ?? null;
        const strokeIdx = holes[holeNo]?.stroke ?? null;
        const recv = useH ? strokesReceived(ps[i].hcap, strokeIdx||18) : 0;
        const pts = stablefordPoints(par, v, recv);
        results[i].gross += v;
        results[i].points+= pts;
        if (front9.includes(holeNo)) results[i].out += v;
        else results[i].inn += v;
      });
      results.forEach((r,i)=>{ r.net = Math.max(0, (r.out + r.inn) - (ps[i].hcap||0)); });

      const entry = {
        course: state.course?.course?.name || 'Course',
        id    : state.course?.course?.id   || state.meta?.id || 'course',
        ts    : Date.now(),
        useHandicaps: useH,
        players: results
      };
      const key = histKey();
      const arr = JSON.parse(localStorage.getItem(key) || '[]');
      arr.unshift(entry);
      while (arr.length>10) arr.pop();
      localStorage.setItem(key, JSON.stringify(arr));
      localStorage.removeItem(scStateKey()); // reset in-progress
      toast('Round saved');
      closeScore();
    });

    function openHist(){
      const div = $('#histList');
      const arr = JSON.parse(localStorage.getItem(histKey()) || '[]');
      if (!arr.length){ div.innerHTML = '<p style="margin:10px 0; color:var(--muted);">No rounds yet.</p>'; }
      else {
        const out = arr.map(r=>{
          const dt = new Date(r.ts).toLocaleString();
          const rows = r.players.map(p=>`
            <div style="display:grid;grid-template-columns:1fr auto auto auto auto auto;gap:10px;">
              <div><strong>${p.name}</strong>${r.useHandicaps?` <span style="color:var(--muted);">(H${p.hcap})</span>`:''}</div>
              <div>Out: <strong>${p.out||0}</strong></div>
              <div>In: <strong>${p.inn||0}</strong></div>
              <div>Total: <strong>${(p.out||0)+(p.inn||0)}</strong></div>
              <div>Net: <strong>${p.net}</strong></div>
              <div>Pts: <strong>${p.points}</strong></div>
            </div>
          `).join('');
          return `
            <div style="border-bottom:1px solid var(--border); padding:10px 0;">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                <div><strong>${r.course}</strong></div>
                <div style="color:var(--muted);font-size:12px;">${dt}</div>
              </div>
              ${rows}
            </div>
          `;
        }).join('');
        div.innerHTML = out;
      }
      $('#histModal').style.display='grid';
    }
    function closeHist(){ $('#histModal').style.display='none'; }
    function clearHistory(){
      if (!confirm('Clear all saved rounds?')) return;
      localStorage.removeItem(histKey());
      $('#histList').innerHTML = '<p style="margin:10px 0; color:var(--muted);">History cleared.</p>';
    }
    $('#historyBtn').addEventListener('click', openHist);
    $('#closeHist').addEventListener('click', closeHist);
    $('#clearHist').addEventListener('click', clearHistory);
    $('#scoreBtn').addEventListener('click', openScore);

    // Boot
    (async function boot(){
      const idx = await getIndex();
      const meta = await pickCourseFromIndex(idx);
      if (!meta){ alert('No courses in index.json'); return; }
      const course = await loadCourseJson(meta.id);

      const ok = await validatePinFlow(meta.id, course);
      if (!ok) return;

      state.meta = meta; state.course = course;
      $('#courseTitle').textContent = course.course?.name || meta.name || 'Course';

      // Hide history for clubs
      const mode = localStorage.getItem(`mode_${meta.id}`) || (isGuestMode() ? 'guest' : 'club');
      if (mode !== 'guest') {
        const hb = document.getElementById('historyBtn');
        if (hb) hb.style.display = 'none';
      }

      const startHole = parseInt(q('hole') || '1', 10);
      state.hole = startHole;

      renderHole();
      toast(navigator.onLine ? 'Course loaded (online)' : 'Course loaded (offline cached)');
    })();
  </script>

<script>
// === Additive handlers (safe) ===
window.__patchBlock = true;
(function(){
  // Expose map safely without renaming 'map'
  try {
    if (!window.__leafletMap && typeof map !== 'undefined') window.__leafletMap = map;
  } catch(e){}

  // Rules modal logic
  const modal = document.getElementById('rulesModalMini');
  const openBtn = document.getElementById('rulesBtnMini');
  const closeBtn = document.getElementById('rulesCloseMini');
  if (openBtn && modal) openBtn.addEventListener('click', ()=> modal.style.display='grid');
  if (closeBtn && modal) closeBtn.addEventListener('click', ()=> modal.style.display='none');
  if (modal) modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });

  // Scorecard setup close
  const closeSetup = document.getElementById('closeSetup');
  const scoreModal = document.getElementById('scoreModal') || document.getElementById('scorecardModal');
  if (closeSetup && scoreModal) closeSetup.addEventListener('click', ()=> scoreModal.style.display='none');

  // --- Robust penalties toggle: discover stake markers dynamically ---
  function discoverStakeMarkers(){
    const map = window.__leafletMap || window.map;
    const arr = [];
    if (!map) return arr;
    try{
      if (window.state && Array.isArray(state.markers)){
        state.markers.forEach(m=>{
          const t = (m && m.options && m.options.title) ? String(m.options.title).toLowerCase() : '';
          if (t.includes('stake')) arr.push(m);
        });
      }
    }catch(e){}
    try{
      map.eachLayer(layer=>{
        if (layer && layer.options && layer.options.title){
          const t = String(layer.options.title).toLowerCase();
          if (t.includes('stake') && !arr.includes(layer)) arr.push(layer);
        }
      });
    }catch(e){}
    return arr;
  }
  window.__applyPenToggle = function(show){
    try{
      // Non-destructive show/hide so we can always bring stakes back without re-adding layers
      // 1) Ensure our stake cache is up-to-date
      window.__stakeMarkers = discoverStakeMarkers();
      (window.__stakeMarkers || []).forEach(m => {
        // If the marker already has a DOM icon rendered, toggle its display
        const icon = m && m._icon;
        const shadow = m && m._shadow;
        if (icon) icon.style.display = show ? '' : 'none';
        if (shadow) shadow.style.display = show ? '' : 'none';
        // Fallback: if no icon exists yet (not rendered), add to map once when showing
        if (show && !m._map) { try { m.addTo(window.__leafletMap || window.map || m._map); } catch(e){} }
      });
    }catch(e){ console.warn('pen toggle error', e); }
  };
  // Toggle UI & persistence
  const key = 'penalties_show';
  const penBtn = document.getElementById('penBtnMini');
  const penSwitch = document.getElementById('penSwitch');
  function setPen(on){
    if (penSwitch){
      
      penSwitch.classList.toggle('on', !!on);
      penSwitch.style.background = '';
      penSwitch.style.borderColor = '';
    const knob = penSwitch.querySelector('[data-role="knob"]');
      if (knob) knob.style.transform = on ? 'translateX(20px)' : 'translateX(0)';
    }
    localStorage.setItem(key, on ? '1' : '0');
    if (window.__applyPenToggle) window.__applyPenToggle(on);
  }
  const initPen = (localStorage.getItem(key) === '1');
  setPen(initPen);
  if (penBtn) penBtn.addEventListener('click', ()=> setPen(!(localStorage.getItem(key) === '1')));

  // After each renderHole, collect stake markers by title and hide FRONT/BACK dots to declutter
  if (!window.__patchedRenderHole && typeof window.renderHole === 'function'){
    window.__patchedRenderHole = true;
    const orig = window.renderHole;
    window.renderHole = function(){
      orig();
      try{
        const map = window.__leafletMap || window.map;
        window.__stakeMarkers = [];
        if (window.state && Array.isArray(state.markers)){
          state.markers.forEach(m => {
            const t = (m && m.options && m.options.title) ? String(m.options.title).toLowerCase() : '';
            if (t.includes('stake')) window.__stakeMarkers.push(m);
            if (t==='front' || t==='back'){ if (m._map) map.removeLayer(m); }
          });
        }
        setPen(localStorage.getItem(key) === '1'); // apply current state
      }catch(e){}
    };
  }

  // No-go zone detection (supports pins.NOGO/NO_GO/NO_GO_ZONES)
  function pointInPoly(pt, poly){
    let x=pt.lat, y=pt.lng, inside=false;
    for (let i=0,j=poly.length-1; i<poly.length; j=i++){
      let xi=poly[i].lat, yi=poly[i].lng, xj=poly[j].lat, yj=poly[j].lng;
      let intersect=((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12) + xi);
      if (intersect) inside=!inside;
    }
    return inside;
  }
  window.__nogoZones = [];
  function loadNoGoForHole(h){
    window.__nogoZones = [];
    const pins = (h && h.pins) || {};
    const cand = [].concat(pins.NOGO||[], pins.NO_GO||[], pins.NO_GO_ZONES||[]);
    cand.forEach(zone => {
      if (Array.isArray(zone) && zone.length && zone[0].lat!==undefined) window.__nogoZones.push(zone);
      else if (Array.isArray(zone)) zone.forEach(z=> Array.isArray(z) && z.length && z[0].lat!==undefined && window.__nogoZones.push(z));
    });
  }
  if (!window.__patchedRenderHoleNoGo && typeof window.renderHole === 'function'){
    window.__patchedRenderHoleNoGo = true;
    const orig2 = window.renderHole;
    window.renderHole = function(){
      orig2();
      try{
        const h = window.state && window.state.course && window.state.course.holes
                  ? window.state.course.holes[String(window.state.hole)] : null;
        loadNoGoForHole(h||{});
      }catch(e){}
    };
  }
  if (!window.__patchedUpdateCart && typeof window.updateCartAndChips === 'function'){
    window.__patchedUpdateCart = true;
    const orig3 = window.updateCartAndChips;
    window.__wasInNoGo = false;
    window.updateCartAndChips = function(){
      orig3();
      try{
        const cm = window.state && window.state.cartMarker;
        if (!cm) return;
        const ll = cm.getLatLng();
        const pt = {lat: ll.lat, lng: ll.lng};
        let inside = false;
        for (const poly of (window.__nogoZones||[])){ if (pointInPoly(pt, poly)) { inside = true; break; } }
        if (inside && !window.__wasInNoGo){
          window.__wasInNoGo = true;
          try{
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const o = ctx.createOscillator(); const g = ctx.createGain();
            o.type='sine'; o.frequency.value=880; o.connect(g); g.connect(ctx.destination);
            o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, 350);
          }catch(e){}
          const t = document.getElementById('toast');
          if (t){ t.textContent='Please stay clear of greens / no-go zones.'; t.style.display='block'; setTimeout(()=> t.style.display='none', 2500); }
        }
        if (!inside) window.__wasInNoGo = false;
      }catch(e){}
    };
  }
})();

// Layup width fix (ensure no wrap at runtime too)
try{ var lay=document.getElementById('layupText'); if(lay) lay.style.whiteSpace='nowrap'; }catch(e){}
</script>


<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js').catch(console.error);
  });
}
</script>

  
</body>
</html>
