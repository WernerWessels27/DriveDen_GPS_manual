<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TrackLinq GPS (Oriented)</title>
  <link rel="manifest" href="/manifest.webmanifest">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    :root{--bg:#0c0c0c;--panel:#141414;--line:#2a2a2a;--accent:#01d28e;--muted:#a9a9a9}
    *{box-sizing:border-box}
    body{margin:0;background:#0b0b0b;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;display:grid;grid-template-rows:auto 1fr;min-height:100dvh}
    header{background:#141414;border-bottom:1px solid #2a2a2a;position:sticky;top:0;z-index:30}
    .bar{display:flex;gap:10px;align-items:center;padding:10px 12px}
    .title{font-weight:800}
    .chip{border:1px solid #2a2a2a;background:#000;color:#fff;border-radius:999px;padding:4px 10px;font-size:12px}
    .btn{border:1px solid #2a2a2a;background:#0e0e0e;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn.primary{background:var(--accent);color:#0b1612;border-color:var(--accent);font-weight:800}
    .spacer{flex:1}
    main{display:grid;grid-template-columns:1fr 420px;gap:10px;padding:10px}
    #mapWrap{position:relative}
    #map{width:100%;height:68vh;border:1px solid #2a2a2a;border-radius:14px;overflow:hidden}
    #orientCanvas{position:absolute;left:0;top:0;width:100%;height:68vh;pointer-events:auto;display:none}
    #hint{position:absolute;left:10px;bottom:10px;z-index:10;background:#000;border:1px solid #2a2a2a;border-radius:10px;padding:6px 10px;font-size:12px;color:#ddd}
    aside{background:#121212;border:1px solid #2a2a2a;border-radius:14px;padding:10px;display:flex;flex-direction:column;gap:10px;overflow:auto}
    h3{margin:6px 0 8px;font-size:14px;text-transform:uppercase;letter-spacing:.08em;color:#c8c8c8}
    .muted{color:#a9a9a9;font-size:12px}
    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{border-bottom:1px solid #2a2a2a;padding:6px;text-align:center}
    th.sticky{position:sticky;top:0;background:#151515;z-index:2}
    .small{width:60px;padding:6px 8px;border-radius:8px;background:#0f0f0f;border:1px solid #333;color:#fff}
    .name{width:140px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    @media (max-width:1100px){main{grid-template-columns:1fr} #map{height:56vh} #orientCanvas{height:56vh}}
    .bubble{background:#000;border:1px solid #262626;color:#fff;padding:4px 8px;border-radius:10px;font-size:12px;white-space:nowrap}
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="title" id="courseTitle">TrackLinq GPS</div>
      <div class="chip" id="holeChip">Hole –</div>
      <div class="spacer"></div>
      <button class="btn" id="toggleOrient" title="Switch between Map and Oriented View">Oriented View: OFF</button>
      <button class="btn" id="clearLayup">Clear layup</button>
      <button class="btn" id="prevHole">◀</button>
      <button class="btn" id="nextHole">▶</button>
      <button class="btn primary" id="saveRound">Save</button>
    </div>
  </header>

  <main>
    <div id="mapWrap">
      <div id="map"></div>
      <canvas id="orientCanvas"></canvas>
      <div id="hint" style="display:none;">Tap to set layup • Cart follows GPS • Distances show on lines</div>
    </div>
    <aside>
      <section>
        <h3>Players & Handicaps</h3>
        <div class="row">
          <label>Players:
            <select id="playersCount">
              <option>1</option><option selected>2</option><option>3</option><option>4</option>
            </select>
          </label>
          <label>Hcp base:
            <select id="hcpBase">
              <option value="18" selected>18</option>
              <option value="9">9</option>
              <option value="36">36</option>
            </select>
          </label>
        </div>
      </section>

      <section>
        <h3>Scorecard (Classic)</h3>
        <div id="scorecard"></div>
        <p class="muted">Stableford auto-calculates per hole from par, stroke index & handicap.</p>
      </section>

      <section>
        <h3>History (Summary)</h3>
        <div id="history"></div>
      </section>
    </aside>
  </main>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js').catch(()=>{}); }

  // --- Map base ---
  const map = L.map('map', { zoomControl:true, attributionControl:false });
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

  // --- State ---
  let course = null;
  let currentHole = 1;
  let layupLatLng = null;
  let cartLatLng = null;
  let cartMarker = null;

  const courseId = (new URLSearchParams(location.search)).get('course')
                 || (new URLSearchParams(location.search)).get('courseId')
                 || localStorage.getItem('dd:lastCourseId');
  const courseName = localStorage.getItem('dd:lastCourseName') || 'Course';
  const courseTitle = document.getElementById('courseTitle');
  const holeChip = document.getElementById('holeChip');

  const orientBtn = document.getElementById('toggleOrient');
  const canvas = document.getElementById('orientCanvas');
  const hint = document.getElementById('hint');
  const ctx = canvas.getContext('2d');
  let oriented = false;

  // --- Helpers ---
  function hole(){ return course?.holes?.find(h=>h.no===currentHole); }
  function metersBetweenLatLng(a,b){ return map.distance(a,b); }
  function yards(m){ return m * 1.09361; }
  function fmt(m){ return `${Math.round(m)} m (${Math.round(yards(m))} yd)`; }

  function updateHeader(){
    const h = hole(); if (!h) return;
    holeChip.textContent = `Hole ${h.no} • Par ${h.par} • Stroke ${h.strokeIndex}`;
  }

  async function loadCourse() {
    try {
      let id = courseId;
      if (!id) throw new Error('Missing course id (?course=)');
      const res = await fetch(`/courses/${id}.json`, { cache: 'no-cache' });
      course = await res.json();
      currentHole = course.startHole || 1;
      courseTitle.textContent = course.name || courseName;
      localStorage.setItem('dd:lastCourseId', id);
      localStorage.setItem('dd:lastCourseName', course.name || courseName);
    } catch (e) {
      course = {
        name: courseName, startHole:1, metersPerPixel:0.35,
        holes: Array.from({length:18}, (_,i)=> ({
          no:i+1, par:[4,4,3,5,4,3,5,4,4,4,4,3,5,4,3,5,4,4][i], strokeIndex:(i%18)+1,
          tee:{lat:-25.75,lng:28.23}, greenMid:{lat:-25.74,lng:28.25}, back:{lat:-25.739,lng:28.251}
        }))
      };
    }
  }

  function fitHoleBounds(){
    const h = hole(); if (!h) return;
    const b = L.latLngBounds([ [h.tee.lat,h.tee.lng], [h.greenMid.lat,h.greenMid.lng] ]).pad(0.4);
    map.fitBounds(b, { animate:false });
  }

  // --- Oriented canvas math ---
  const view = { margin: 60, scale:1, rot:0, tx:0, ty:0 }; // screen transform for oriented mode
  function resizeCanvas(){
    const r = document.getElementById('map').getBoundingClientRect();
    canvas.width = Math.floor(r.width * devicePixelRatio);
    canvas.height = Math.floor(r.height * devicePixelRatio);
    canvas.style.width = r.width + 'px';
    canvas.style.height = r.height + 'px';
    drawOriented();
  }
  window.addEventListener('resize', ()=>{ if(oriented) resizeCanvas(); });

  function projectLL(ll){ return map.project(ll, 19); } // fixed high zoom for uniform local space
  function unprojectPt(pt){ return map.unproject(pt, 19); }

  function computeView(){
    const h = hole(); if (!h) return;
    // Base points in "pixel" space at z=19
    const teeP = projectLL(L.latLng(h.tee.lat, h.tee.lng));
    const midP = projectLL(L.latLng(h.greenMid.lat, h.greenMid.lng));

    // angle tee->mid
    const vx = midP.x - teeP.x, vy = midP.y - teeP.y;
    const angle = Math.atan2(vy, vx);
    view.rot = -angle; // rotate so tee->mid becomes horizontal

    // rotate points
    function rot(p){
      const s = Math.sin(view.rot), c = Math.cos(view.rot);
      const x = p.x*c - p.y*s;
      const y = p.x*s + p.y*c;
      return {x,y};
    }
    const rTee = rot(teeP), rMid = rot(midP);

    // fit into canvas
    const cw = canvas.width/devicePixelRatio;
    const ch = canvas.height/devicePixelRatio;
    const minX = Math.min(rTee.x, rMid.x), maxX = Math.max(rTee.x, rMid.x);
    const minY = Math.min(rTee.y, rMid.y), maxY = Math.max(rTee.y, rMid.y);
    const holeW = Math.max(1, maxX - minX);
    const holeH = Math.max(1, maxY - minY);

    const availW = cw - view.margin*2;
    const availH = ch - view.margin*2;
    view.scale = Math.min(availW / holeW, Math.max(1, availH / Math.max(holeH, 160))); // keep some vertical size

    // place tee near left margin, center vertically
    const afterMinX = minX * view.scale, afterMinY = minY * view.scale;
    const neededH = (maxY - minY) * view.scale;
    const targetX = view.margin;
    const targetY = (ch - neededH)/2;
    view.tx = targetX - afterMinX;
    view.ty = targetY - afterMinY;
  }

  function toScreen(pt){
    const s = Math.sin(view.rot), c = Math.cos(view.rot);
    const xr =  pt.x*c - pt.y*s;
    const yr =  pt.x*s + pt.y*c;
    return { x: xr*view.scale + view.tx, y: yr*view.scale + view.ty };
  }
  function toOrientedWorld(screenX, screenY){
    // inverse of toScreen (returns base z=19 pixel space)
    const x = (screenX - view.tx)/view.scale;
    const y = (screenY - view.ty)/view.scale;
    const s = Math.sin(-view.rot), c = Math.cos(-view.rot);
    return { x: x*c - y*s, y: x*s + y*c };
  }

  function drawCart(ctx,x,y){
    ctx.save();
    ctx.translate(x,y);
    ctx.fillStyle = '#00c2ff';
    ctx.strokeStyle = '#0086b3';
    ctx.lineWidth = 1.5;
    const w=24, h=14;
    ctx.beginPath();
    ctx.moveTo(-w/2, -h/2); ctx.lineTo(w/2, -h/2); ctx.lineTo(w/2-4, h/2); ctx.lineTo(-w/2+6, h/2); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-w/2+2, -h/2); ctx.lineTo(w/2-2, -h/2); ctx.lineTo(w/2-8, -h/2-6); ctx.lineTo(-w/2+10, -h/2-6); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.fillStyle = '#0b0b0b';
    ctx.arc(-w/4, h/2+3, 4, 0, Math.PI*2); ctx.arc(w/4, h/2+3, 4, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawBubble(ctx, x, y, text){
    ctx.save();
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial';
    const padX=8, h=22;
    const w = ctx.measureText(text).width + padX*2;
    ctx.fillStyle = '#000'; ctx.strokeStyle='#262626'; ctx.lineWidth=1;
    roundRect(ctx, x - w/2, y - h/2, w, h, 10); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#fff'; ctx.textBaseline='middle'; ctx.fillText(text, x - w/2 + padX, y);
    ctx.restore();
  }
  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawOriented(){
    if(!oriented) return;
    const r = document.getElementById('map').getBoundingClientRect();
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,0,canvas.width,canvas.height);

    const h=hole(); if(!h) return;
    computeView();

    const teeP = projectLL(h.tee);
    const midP = projectLL(h.greenMid);

    const teeS = toScreen(teeP);
    const midS = toScreen(midP);

    // Fairway band (wide + inner)
    ctx.save();
    ctx.strokeStyle = '#134e18'; ctx.lineWidth = 60; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(teeS.x, teeS.y); ctx.lineTo(midS.x, midS.y); ctx.stroke();
    ctx.strokeStyle = '#1a6b24'; ctx.lineWidth = 36;
    ctx.beginPath(); ctx.moveTo(teeS.x, teeS.y); ctx.lineTo(midS.x, midS.y); ctx.stroke();
    ctx.restore();

    // Cart
    const cartP = cartLatLng ? projectLL(cartLatLng) : teeP;
    const cartS = toScreen(cartP);
    drawCart(ctx, cartS.x, cartS.y);

    // Layup + lines/bubbles
    const layLL = layupLatLng;
    if (layLL){
      const layP = projectLL(layLL);
      const layS = toScreen(layP);

      // Solid: cart->layup
      ctx.save();
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth=2.5;
      ctx.beginPath(); ctx.moveTo(cartS.x, cartS.y); ctx.lineTo(layS.x, layS.y); ctx.stroke();
      ctx.restore();

      // Bubble at midpoint, offset normal
      const m1x = (cartS.x + layS.x)/2, m1y=(cartS.y + layS.y)/2;
      const dx1 = layS.x - cartS.x, dy1 = layS.y - cartS.y, L1=Math.hypot(dx1,dy1)||1;
      drawBubble(ctx, m1x - (dy1/L1)*12, m1y + (dx1/L1)*12, `Cart→Layup: ${fmt(metersBetweenLatLng(cartLatLng||h.tee, layLL))}`);

      // Dashed: layup->mid
      ctx.save();
      ctx.setLineDash([10,8]); ctx.strokeStyle='#ffffff'; ctx.lineWidth=2.5;
      ctx.beginPath(); ctx.moveTo(layS.x, layS.y); ctx.lineTo(midS.x, midS.y); ctx.stroke();
      ctx.restore();

      const m2x = (layS.x + midS.x)/2, m2y=(layS.y + midS.y)/2;
      const dx2 = midS.x - layS.x, dy2 = midS.y - layS.y, L2=Math.hypot(dx2,dy2)||1;
      drawBubble(ctx, m2x - (dy2/L2)*12, m2y + (dx2/L2)*12, `Layup→Mid: ${fmt(metersBetweenLatLng(layLL, h.greenMid))}`);

      // Layup dot
      ctx.save(); ctx.fillStyle='#ffcc00'; ctx.beginPath(); ctx.arc(layS.x, layS.y, 6, 0, Math.PI*2); ctx.fill(); ctx.restore();

    } else {
      // Cart→Mid bubble
      const m3x = (cartS.x + midS.x)/2, m3y=(cartS.y + midS.y)/2;
      const dx3 = midS.x - cartS.x, dy3 = midS.y - cartS.y, L3=Math.hypot(dx3,dy3)||1;
      drawBubble(ctx, m3x - (dy3/L3)*12, m3y + (dx3/L3)*12, `Cart→Mid: ${fmt(metersBetweenLatLng(cartLatLng||h.tee, h.greenMid))}`);
    }

    // Tee & Mid dots
    ctx.save();
    ctx.fillStyle='#3aa657'; ctx.beginPath(); ctx.arc(teeS.x, teeS.y, 8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#8fd19e'; ctx.beginPath(); ctx.arc(midS.x, midS.y, 9, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Canvas click -> set layup (inverse transform to latlng)
  canvas.addEventListener('click', (ev)=>{
    if (!oriented) return;
    const rect = canvas.getBoundingClientRect();
    const sx = (ev.clientX - rect.left);
    const sy = (ev.clientY - rect.top);
    const base = toOrientedWorld(sx, sy); // z=19 pixel space
    const ll = unprojectPt(base);
    layupLatLng = L.latLng(ll.lat, ll.lng);
    drawOriented();
  });

  // Toggle oriented
  orientBtn.addEventListener('click', ()=>{
    oriented = !oriented;
    orientBtn.textContent = 'Oriented View: ' + (oriented ? 'ON' : 'OFF');
    canvas.style.display = oriented ? 'block' : 'none';
    hint.style.display = oriented ? 'block' : 'none';
    if (oriented){ resizeCanvas(); drawOriented(); } else { /* map is visible underneath */ }
  });

  // Layup clear
  document.getElementById('clearLayup').onclick = ()=>{ layupLatLng=null; drawOriented(); };

  // Hole nav
  document.getElementById('prevHole').onclick = ()=>{ currentHole=Math.max(1,currentHole-1); updateHeader(); fitHoleBounds(); drawOriented(); };
  document.getElementById('nextHole').onclick = ()=>{ currentHole=Math.min(course.holes.length,currentHole+1); updateHeader(); fitHoleBounds(); drawOriented(); };

  // Geolocation for cart
  function initCart(){
    const h = hole(); if (!h) return;
    cartLatLng = L.latLng(h.tee.lat, h.tee.lng); // default tee
    cartMarker = L.marker(cartLatLng).addTo(map);
    if ('geolocation' in navigator){
      navigator.geolocation.watchPosition((pos)=>{
        cartLatLng = L.latLng(pos.coords.latitude, pos.coords.longitude);
        cartMarker.setLatLng(cartLatLng);
        if(oriented) drawOriented();
      }, ()=>{}, { enableHighAccuracy:true, maximumAge:5000, timeout:8000 });
    }
  }

  // -------- Scorecard & History (same as prior version) --------
  const playersSel = document.getElementById('playersCount');
  const hcpBaseSel = document.getElementById('hcpBase');
  const scorecardHost = document.getElementById('scorecard');
  let card = [];

  playersSel.addEventListener('change', buildScorecard);
  hcpBaseSel.addEventListener('change', ()=>{ distributeHandicaps(); recomputePoints(); });

  function buildScorecard(){
    const nPlayers = parseInt(playersSel.value,10);
    const holes = course.holes; const nHoles = holes.length;
    card = Array.from({length:nPlayers}, (_,i)=>({
      name:`Player ${i+1}`, hcp:18, scores:Array(nHoles).fill(''), points:Array(nHoles).fill(0), hcpStrokes:Array(nHoles).fill(0)
    }));
    renderScorecard();
    distributeHandicaps();
    recomputePoints();
  }

  function renderScorecard(){
    const holes = course.holes; const n = holes.length;
    const front = Math.min(9,n), back = Math.max(0,n-9);
    const thead = `
      <thead>
        <tr>
          <th class="sticky" style="text-align:left">Player</th>
          ${Array.from({length:front}, (_,i)=>`<th class="sticky">${i+1}</th>`).join('')}
          <th class="sticky">OUT</th>
          ${back ? Array.from({length:back}, (_,i)=>`<th class="sticky">${i+10}</th>`).join('') : ''}
          ${back ? '<th class="sticky">IN</th>' : ''}
          <th class="sticky">TOTAL</th>
          <th class="sticky">Pts</th>
        </tr>
      </thead>`;

    let rows = '';
    card.forEach((p,pi)=>{
      const nameCell = `
        <td style="text-align:left">
          <div>
            <input class="name small" value="${p.name}" data-pi="${pi}" data-field="name">
            <div class="muted">Hcp: <input class="small" value="${p.hcp}" data-pi="${pi}" data-field="hcp"></div>
          </div>
        </td>`;
      const frontInputs = Array.from({length:front}, (_,hi)=>`<td><input class="small" data-pi="${pi}" data-hi="${hi}" placeholder="-"></td>`).join('');
      const outCell = `<td id="out-${pi}">0</td>`;
      const backInputs = back ? Array.from({length:back}, (_,k)=>{
        const hi = 9+k; return `<td><input class="small" data-pi="${pi}" data-hi="${hi}" placeholder="-"></td>`;
      }).join('') : '';
      const inCell = back ? `<td id="in-${pi}">0</td>` : '';
      const totalCell = `<td id="total-${pi}">0</td>`;
      const ptsCell = `<td id="pts-${pi}">0</td>`;
      rows += `<tr>${nameCell}${frontInputs}${outCell}${backInputs}${inCell}${totalCell}${ptsCell}</tr>`;
    });

    scorecardHost.innerHTML = `<div style="overflow:auto"><table>${thead}<tbody id="scBody">${rows}</tbody></table></div>`;

    scorecardHost.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('input', onScoreInput);
    });
  }

  function onScoreInput(e){
    const pi = parseInt(e.target.dataset.pi,10);
    const field = e.target.dataset.field;
    if (field === 'name'){ card[pi].name = e.target.value; return; }
    if (field === 'hcp'){ card[pi].hcp = Math.max(0, Math.min(54, parseInt(e.target.value||'0',10))); distributeHandicaps(); recomputePoints(); return; }
    const hi = parseInt(e.target.dataset.hi,10);
    const v = e.target.value.trim()==='' ? '' : Math.max(0, parseInt(e.target.value,10));
    card[pi].scores[hi] = v;
    recomputePoints();
  }

  function distributeHandicaps(){
    const unit = parseInt(hcpBaseSel.value,10) || 18;
    const holes = course.holes;
    card.forEach(p=>{
      const full = Math.floor(p.hcp / unit);
      const rem = p.hcp % unit;
      p.hcpStrokes = holes.map(()=> full);
      const order = holes.map((h,idx)=>({idx, si:h.strokeIndex})).sort((a,b)=>a.si-b.si);
      for(let i=0;i<rem;i++){ p.hcpStrokes[order[i%holes.length].idx] += 1; }
    });
  }

  function stableford(gross, par, strokes){
    if (gross==='' || gross==null) return 0;
    const net = gross - strokes;
    const d = net - par;
    if (d <= -3) return 5;
    if (d === -2) return 4;
    if (d === -1) return 3;
    if (d === 0) return 2;
    if (d === 1) return 1;
    return 0;
  }

  function recomputePoints(){
    const holes = course.holes; const n = holes.length;
    card.forEach((p,pi)=>{
      let out=0, inn=0, pts=0;
      for(let hi=0; hi<n; hi++){
        const g=p.scores[hi]; const strokes=p.hcpStrokes[hi]||0;
        const s=stableford(g, holes[hi].par, strokes); p.points[hi]=s; pts+=s;
        if (g!=='' && g!=null){ if (hi<9) out+= (g-strokes); else inn+= (g-strokes); }
      }
      const o=document.getElementById('out-'+pi); if (o) o.textContent = out;
      const i=document.getElementById('in-'+pi); if (i) i.textContent = inn;
      const t=document.getElementById('total-'+pi); if (t) t.textContent = out+inn;
      const ptd=document.getElementById('pts-'+pi); if (ptd) ptd.textContent = pts;
    });
  }

  document.getElementById('saveRound').addEventListener('click', ()=>{
    const holes = course.holes;
    const date = new Date().toISOString().slice(0,10);
    const record = {
      date, course: course.name || courseTitle.textContent,
      players: card.map(p=>{
        let out=0, inn=0, pts=0;
        holes.forEach((h,hi)=>{
          const g=p.scores[hi]; const strokes=p.hcpStrokes[hi]||0;
          if (g!=='' && g!=null){ if (hi<9) out+=(g-strokes); else inn+=(g-strokes); }
          pts += p.points[hi]||0;
        });
        return { name:p.name, hcp:p.hcp, out, inn, total:out+inn, points:pts };
      })
    };
    const key = 'dd:history';
    const list = JSON.parse(localStorage.getItem(key)||'[]');
    list.unshift(record);
    localStorage.setItem(key, JSON.stringify(list));
    renderHistory();
    alert('Saved');
  });

  function renderHistory(){
    const key='dd:history'; const list=JSON.parse(localStorage.getItem(key)||'[]');
    const host=document.getElementById('history');
    if (!list.length){ host.innerHTML='<p class="muted">No saved rounds yet.</p>'; return; }
    host.innerHTML = list.map(rec=>{
      const rows = rec.players.map(p=>`<tr><td style="text-align:left">${p.name}</td><td>${p.hcp}</td><td>${p.out}</td><td>${p.inn}</td><td>${p.total}</td><td>${p.points}</td></tr>`).join('');
      return `<div style="border:1px solid #2a2a2a;border-radius:12px;overflow:hidden;margin:6px 0">
        <div style="background:#151515;padding:8px 10px;display:flex;justify-content:space-between">
          <div><strong>${rec.course}</strong></div><div class="muted">${rec.date}</div>
        </div>
        <div style="padding:0;overflow:auto">
          <table style="min-width:560px">
            <thead><tr><th>Player</th><th>Hcp</th><th>OUT</th><th>IN</th><th>Total</th><th>Pts</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      </div>`;
    }).join('');
  }

  // Boot
  (async function(){
    await loadCourse();
    updateHeader();
    fitHoleBounds();
    initCart();
    buildScorecard();
    renderHistory();
  })();
  </script>
</body>
</html>
