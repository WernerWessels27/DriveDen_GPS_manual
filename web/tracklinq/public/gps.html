<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TrackLinq GPS</title>

  <link rel="manifest" href="/manifest.webmanifest">

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    /* Keep your existing layout look: distances top-left, hole number centered, buttons bottom-left */
    html, body { height: 100%; margin: 0; background: #000; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; }
    #map { width: 100%; height: 100%; }

    /* Top-left distance chips */
    .chips { position: absolute; left: 12px; top: 12px; z-index: 1000; display: flex; gap: 8px; flex-wrap: wrap; }
    .chip { display: inline-flex; align-items: center; gap: 6px; padding: 8px 10px; border-radius: 999px; background: rgba(17,24,39,0.8); border: 1px solid rgba(255,255,255,0.15); color: #fff; font-weight: 700; backdrop-filter: blur(4px); }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

    /* Center hole indicator */
    .centerHole { position: absolute; left: 50%; top: 12px; transform: translateX(-50%); z-index: 1000; color: #fff; background: rgba(17,24,39,0.6); border: 1px solid rgba(255,255,255,0.15); padding: 6px 10px; border-radius: 10px; font-weight: 800; }

    /* Bottom-left buttons */
    .hud { position: absolute; left: 12px; bottom: 12px; z-index: 1000; display: flex; gap: 8px; flex-wrap: wrap; }
    .btn { cursor: pointer; padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.15); background: rgba(17,24,39,0.75); color: #fff; font-weight: 700; backdrop-filter: blur(4px); }
    .btn:active { transform: translateY(1px); }

    /* Top-right info (course id/name) */
    .panel { position: absolute; right: 12px; top: 12px; z-index: 1000; background: rgba(255,255,255,0.9); border-radius: 12px; padding: 8px 10px; font-size: 12px; color: #111; border: 1px solid #e5e7eb; min-width: 220px; }
    .panel strong { font-weight: 800; }

    /* Toast bottom-center for small notices */
    .toast { position: absolute; left: 50%; transform: translateX(-50%); bottom: 12px; z-index: 1000; background: rgba(17,24,39,0.9); color:#fff; border:1px solid rgba(255,255,255,0.15); padding:8px 12px; border-radius:10px; font-size:12px; display:none; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Distances (top-left) -->
  <div class="chips">
    <div class="chip"><span class="dot" style="background:#ffffff"></span><span>FRONT</span><span id="dFront">–</span></div>
    <div class="chip"><span class="dot" style="background:#fbbf24"></span><span>MID</span><span id="dMid">–</span></div>
    <div class="chip"><span class="dot" style="background:#ef4444"></span><span>BACK</span><span id="dBack">–</span></div>
    <div class="chip" id="unitChip">m</div>
    <div class="chip" id="fromChip">From: CART</div>
  </div>

  <!-- Center hole label -->
  <div class="centerHole">Hole <span id="holeNo">1</span> • Par <span id="par">4</span> • Stroke <span id="stroke">1</span></div>

  <!-- Bottom-left controls -->
  <div class="hud">
    <button class="btn" id="holeViewBtn">Hole View (TEE↔BACK)</button>
    <button class="btn" id="cartViewBtn">Cart View (CART↔BACK)</button>
    <button class="btn" id="locBtn">My Location</button>
    <button class="btn" id="unitBtn">Units: m/yd</button>
    <button class="btn" id="fromBtn">From: CART/TEE</button>
    <button class="btn" id="prevHole">Prev</button>
    <button class="btn" id="nextHole">Next</button>
  </div>

  <!-- Top-right info panel -->
  <div class="panel">
    <div><strong id="courseName">Course</strong> • <span id="courseId">ID</span></div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <script>
    // SW register
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => navigator.serviceWorker.register('/sw.js'));
    }

    // Small helpers
    const $ = s => document.querySelector(s);
    function q(name){ return new URL(location.href).searchParams.get(name); }
    function toast(msg, ms=2000){ const t=$('#toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', ms); }

    // Icons (tiny dots, no borders; larger signs for toilet/taps)
    function dotIcon(color='#ffffff', size=12) {
      const r = Math.floor(size/2);
      const svg = encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'>
          <circle cx='${r}' cy='${r}' r='${r}' fill='${color}' />
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[r,r] });
    }
    function largeSymbolIcon(svgPath, size=44) {
      const svg = encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 40 40'>${svgPath}</svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[size/2,size/2] });
    }
    const TOILET_SVG = `
      <rect x='2' y='2' width='36' height='36' rx='8' fill='#6b7280'/>
      <path d='M14 26h2l1-6 1 6h2l-2-10h-2l-2 10Zm8 0h2v-4h2v4h2V16h-2v4h-2v-4h-2v10Z' fill='white'/>
    `;
    const TAP_SVG = `
      <rect x='2' y='2' width='36' height='36' rx='8' fill='#0ea5e9'/>
      <path d='M10 18h10v-2h2v-2h8v2h-6v2h-4v4h4v2h-8v-2h2v-4h-8v-2h0Z' fill='white'/>
    `;

    const ICONS = {
      TEE: dotIcon('#16a34a', 14),
      FRONT: dotIcon('#ffffff', 12),
      MID: dotIcon('#fbbf24', 12),
      BACK: dotIcon('#ef4444', 12),
      TOILET: largeSymbolIcon(TOILET_SVG, 44),
      TAPS: largeSymbolIcon(TAP_SVG, 44),
      STAKE_WHITE: dotIcon('#ffffff', 10),
      STAKE_RED: dotIcon('#ef4444', 10),
      STAKE_YELLOW: dotIcon('#fbbf24', 10),
      CART: dotIcon('#60a5fa', 12)
    };

    // Map: Esri satellite default; OSM fallback
    const map = L.map('map', { zoomControl: true }).setView([-25.746, 28.229], 17);
    const esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: 'Imagery © Esri' }).addTo(map);
    const osm  = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' });
    L.control.layers({ 'Satellite (Esri)': esri, 'Streets (OSM)': osm }, {}, { position:'topright', collapsed:true }).addTo(map);

    // Data loading with cache-first
    async function getIndex() {
      let res = await caches.match('/courses/index.json');
      if (!res) res = await fetch('/courses/index.json', { cache: 'reload' });
      return res.json();
    }
    async function loadCourseJson(courseId) {
      const url = `/courses/${courseId}.json`;
      let res = await caches.match(url);
      if (!res) res = await fetch(url, { cache: 'reload' });
      return res.json();
    }
    async function pickCourseFromIndex(idx) {
      const want = (q('course')||'').trim();
      if (want) {
        const c = (idx.courses||[]).find(x => x.id.toUpperCase() === want.toUpperCase());
        if (c) return c;
      }
      return (idx.courses||[])[0] || null;
    }

    // PIN validation (guest bypass)
    async function validatePinFlow(courseId, courseJson) {
      if ((q('guest')||'').trim()==='1') return true;

      const pinFromUrl = (q('pin')||'').trim().toUpperCase();
      if (pinFromUrl.length === 10) {
        localStorage.setItem(`pin_${courseId}`, pinFromUrl);
        return await isPinValid(courseId, courseJson, pinFromUrl);
      }

      const stored = (localStorage.getItem(`pin_${courseId}`)||'').trim().toUpperCase();
      if (stored.length === 10 && await isPinValid(courseId, courseJson, stored)) return true;

      const entered = (prompt(`Enter PIN for ${courseJson?.course?.name || courseId}:`)||'').trim().toUpperCase();
      if (entered.length !== 10) return false;
      const ok = await isPinValid(courseId, courseJson, entered);
      if (ok) localStorage.setItem(`pin_${courseId}`, entered);
      else alert('Invalid PIN');
      return ok;
    }

    async function isPinValid(courseId, courseJson, candidate) {
      if (!candidate || candidate.length !== 10) return false;
      try {
        const idx = await getIndex();
        const c = (idx.courses||[]).find(x => x.id === courseId);
        if (c?.pin && c.pin.trim().toUpperCase() === candidate) return true;
      } catch(_) {}
      const metaPin = (courseJson?.course?.pin || '').trim().toUpperCase();
      if (metaPin && metaPin === candidate) return true;
      return false;
    }

    // State
    const state = {
      meta:null, course:null, hole:1, markers:[], cartMarker:null,
      unit:'m', from:'CART'
    };

    // Distances
    function toRad(d){ return d*Math.PI/180; }
    function haversine(a,b){ const R=6371000, dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
      const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
      const aa=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
      return 2*R*Math.atan2(Math.sqrt(aa),Math.sqrt(1-aa)); }
    function fmt(m){ return state.unit==='yd' ? Math.round(m*1.09361) : Math.round(m); }
    function fromPoint(pins){
      if (state.from==='TEE' && pins.TEE) return { lat:pins.TEE.lat, lng:pins.TEE.lng };
      if (state.cartMarker) { const ll = state.cartMarker.getLatLng(); return { lat: ll.lat, lng: ll.lng }; }
      return null;
    }
    function updateChips(pins){
      const f=$('#dFront'), m=$('#dMid'), b=$('#dBack');
      f.textContent = m.textContent = b.textContent = '–';
      const from = fromPoint(pins); if(!from) return;
      if (pins.FRONT) f.textContent = fmt(haversine(from, pins.FRONT));
      if (pins.MID)   m.textContent = fmt(haversine(from, pins.MID));
      if (pins.BACK)  b.textContent = fmt(haversine(from, pins.BACK));
      $('#unitChip').textContent = state.unit;
      $('#fromChip').textContent = `From: ${state.from}`;
    }

    // Markers
    function clearMarkers(){ state.markers.forEach(m=>m.remove()); state.markers=[]; }
    function addMarker(lat,lng,icon,title=''){ const m=L.marker([lat,lng],{icon,title}).addTo(map); state.markers.push(m); return m; }
    function fitBetween(a,b){ const bounds=L.latLngBounds(L.latLng(a[0],a[1]),L.latLng(b[0],b[1])); map.fitBounds(bounds,{padding:[60,60]}); }

    function renderHole(){
      clearMarkers();
      const h = state.course.holes[String(state.hole)];
      $('#holeNo').textContent = state.hole;
      $('#par').textContent = h?.par ?? '-';
      $('#stroke').textContent = h?.stroke ?? '-';
      if(!h) return;
      const p = h.pins || {};

      if (p.TEE)   addMarker(p.TEE.lat, p.TEE.lng, ICONS.TEE, 'TEE');
      if (p.FRONT) addMarker(p.FRONT.lat, p.FRONT.lng, ICONS.FRONT, 'FRONT');
      if (p.MID)   addMarker(p.MID.lat, p.MID.lng, ICONS.MID, 'MID');
      if (p.BACK)  addMarker(p.BACK.lat, p.BACK.lng, ICONS.BACK, 'BACK');

      if (p.TOILET) addMarker(p.TOILET.lat, p.TOILET.lng, ICONS.TOILET, 'Toilet');
      (p.TAPS || []).forEach(t => addMarker(t.lat, t.lng, ICONS.TAPS, 'Drinking water'));

      (p.STAKE_WHITE || []).forEach(s => addMarker(s.lat, s.lng, ICONS.STAKE_WHITE, 'Stake (white)'));
      (p.STAKE_RED   || []).forEach(s => addMarker(s.lat, s.lng, ICONS.STAKE_RED, 'Stake (red)'));
      (p.STAKE_YELLOW|| []).forEach(s => addMarker(s.lat, s.lng, ICONS.STAKE_YELLOW, 'Stake (yellow)'));

      if (p.TEE && p.BACK) fitBetween([p.TEE.lat,p.TEE.lng],[p.BACK.lat,p.BACK.lng]);
      else {
        const latlngs = state.markers.map(m => m.getLatLng());
        if (latlngs.length) map.fitBounds(L.latLngBounds(latlngs), { padding: [40,40] });
      }

      updateChips(p);
    }

    // Buttons (keep positions/behaviour)
    $('#holeViewBtn').addEventListener('click', ()=>{
      const p = state.course.holes[String(state.hole)]?.pins || {};
      if (p.TEE && p.BACK) fitBetween([p.TEE.lat,p.TEE.lng],[p.BACK.lat,p.BACK.lng]);
    });
    $('#cartViewBtn').addEventListener('click', ()=>{
      const p = state.course.holes[String(state.hole)]?.pins || {};
      if (!p.BACK || !state.cartMarker) return;
      const ll = state.cartMarker.getLatLng();
      fitBetween([ll.lat,ll.lng],[p.BACK.lat,p.BACK.lng]);
    });
    $('#locBtn').addEventListener('click', ()=>{
      if (!navigator.geolocation) return alert('Geolocation not available.');
      navigator.geolocation.getCurrentPosition((pos)=>{
        const { latitude, longitude } = pos.coords;
        if (!state.cartMarker) state.cartMarker = L.marker([latitude,longitude], { icon: ICONS.CART, title:'CART' }).addTo(map);
        else state.cartMarker.setLatLng([latitude,longitude]);
        map.setView([latitude,longitude], 18);
        const p = state.course.holes[String(state.hole)]?.pins || {};
        updateChips(p);
      }, ()=> alert('Could not get location.'));
    });
    $('#unitBtn').addEventListener('click', ()=>{
      state.unit = state.unit==='m' ? 'yd' : 'm';
      const p = state.course.holes[String(state.hole)]?.pins || {};
      updateChips(p);
    });
    $('#fromBtn').addEventListener('click', ()=>{
      state.from = state.from==='CART' ? 'TEE' : 'CART';
      const p = state.course.holes[String(state.hole)]?.pins || {};
      updateChips(p);
    });
    $('#prevHole').addEventListener('click', ()=>{
      const min = 1;
      state.hole = Math.max(min, state.hole - 1);
      renderHole();
    });
    $('#nextHole').addEventListener('click', ()=>{
      const max = Math.max(...Object.keys(state.course.holes||{}).map(k=>+k).filter(Number.isFinite));
      state.hole = Math.min(max || state.hole+1, state.hole + 1);
      renderHole();
    });

    // Boot
    (async function boot(){
      const idx = await getIndex();
      const meta = await pickCourseFromIndex(idx);
      if (!meta) { alert('No courses in index.json'); return; }
      const course = await loadCourseJson(meta.id);

      // PIN/guest flow
      const ok = await validatePinFlow(meta.id, course);
      if (!ok) return;

      state.meta = meta; state.course = course;
      $('#courseName').textContent = course.course?.name || meta.name || 'Course';
      $('#courseId').textContent   = course.course?.id   || meta.id   || '-';

      const startHole = parseInt(q('hole') || '1', 10);
      state.hole = startHole;

      renderHole();
      toast(navigator.onLine ? 'Course loaded (online)' : 'Course loaded (offline cached)');
    })();
  </script>
</body>
</html>
