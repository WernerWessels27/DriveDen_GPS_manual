<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DriveDen GPS — Round</title>
  <style>
    :root{
      --bg:#0c0c0c; --panel:#141414; --line:#2a2a2a; --chip:#000; --accent:#01d28e; --bad:#e74c3c;
      --bubble:#000; --bubble-border:#262626; --muted:#9a9a9a;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;background:var(--bg);color:#eee;min-height:100dvh;display:grid;grid-template-rows:auto 1fr}
    header{position:sticky;top:0;background:var(--panel);border-bottom:1px solid var(--line);z-index:5}
    .banner{display:flex;align-items:center;gap:12px;padding:10px 12px}
    .title{font-weight:700}
    .chip{background:#000;color:#fff;border:1px solid #262626;border-radius:999px;padding:4px 10px;font-size:12px}
    .spacer{flex:1}
    .btn{padding:10px 12px;border-radius:12px;border:1px solid #333;background:#0f0f0f;color:#fff;cursor:pointer}
    .btn.primary{background:var(--accent);border-color:var(--accent);color:#0b1512;font-weight:700}
    main{display:grid;grid-template-columns:1fr 420px;gap:10px;padding:10px}
    .mapWrap{position:relative;background:#0f0f0f;border:1px solid var(--line);border-radius:14px;overflow:hidden;min-height:62vh}
    canvas{display:block;width:100%;height:100%;background:#0b0b0b}
    .hud{position:absolute;left:10px;top:10px;display:flex;gap:8px;flex-wrap:wrap}
    .bubble{background:var(--bubble);color:#fff;border:1px solid var(--bubble-border);border-radius:12px;padding:6px 10px;font-size:12px;box-shadow:0 6px 16px rgba(0,0,0,.25)}
    .bubble strong{font-weight:800}
    .right{background:#121212;border:1px solid var(--line);border-radius:14px;padding:10px;display:flex;flex-direction:column;gap:10px;overflow:auto;max-height:calc(100dvh - 90px)}
    h3{margin:4px 0 8px;font-size:14px;text-transform:uppercase;letter-spacing:.08em;color:#c8c8c8}
    .muted{color:var(--muted);font-size:12px}
    /* Classic scorecard table */
    .scorecard{width:100%;border-collapse:collapse;font-size:12px}
    .scorecard th,.scorecard td{border-bottom:1px solid #2a2a2a;padding:6px;text-align:center}
    .scorecard th.sticky{position:sticky;top:0;background:#151515;z-index:1}
    .sc-player{display:flex;flex-direction:column;gap:4px;align-items:flex-start}
    .small{width:64px;padding:6px 8px;border-radius:8px;background:#0f0f0f;border:1px solid #333;color:#fff}
    .name{width:140px}
    .pill{display:inline-flex;gap:6px;align-items:center;background:#000;border:1px solid #262626;border-radius:999px;padding:6px 10px;font-size:12px}
    .toast{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#000;border:1px solid #2a2a2a;border-radius:999px;padding:8px 14px;font-size:12px;opacity:0;transition:opacity .2s ease}
    .toast.show{opacity:1}
    @media (max-width: 1100px){
      main{grid-template-columns:1fr}
      .right{max-height:none}
    }
  </style>
</head>
<body>
  <header>
    <div class="banner">
      <div class="title" id="courseTitle">Course</div>
      <div class="chip" id="holeChip">Hole 1 • Par 4 • SI 8</div>
      <div class="spacer"></div>
      <button class="btn" id="layupClear" title="Clear layup pin">Clear layup</button>
      <button class="btn" id="prevHole">◀</button>
      <button class="btn" id="nextHole">▶</button>
      <button class="btn primary" id="saveRound">Save</button>
    </div>
  </header>

  <main>
    <section class="mapWrap">
      <canvas id="map"></canvas>
      <div class="hud" id="hud"></div>
    </section>

    <aside class="right">
      <section>
        <h3>Players & Handicaps</h3>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <label class="pill">Players:
            <select id="playersCount">
              <option>1</option><option selected>2</option><option>3</option><option>4</option>
            </select>
          </label>
          <label class="pill">Hcp base:
            <select id="hcpType">
              <option value="0" selected>18</option>
              <option value="9">9</option>
              <option value="36">36</option>
            </select>
          </label>
        </div>
      </section>

      <section>
        <h3>Scorecard (Classic)</h3>
        <div id="scorecard"></div>
        <p class="muted">Stableford: Net dbl bogey=0, bogey=1, par=2, birdie=3, eagle=4, albatross=5.</p>
      </section>

      <section>
        <h3>History (Summary)</h3>
        <div id="history"></div>
      </section>
    </aside>
  </main>

  <div class="toast" id="toast">Saved</div>

  <script>
    // ====== Canvas & Transform Helpers ======
    const canvas = document.getElementById('map');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    const holeChip = document.getElementById('holeChip');
    const courseTitle = document.getElementById('courseTitle');
    const layupClearBtn = document.getElementById('layupClear');

    let course = null;
    let currentHole = 1;
    let layupPt = null;  // world coords
    let cartPt = null;   // world coords

    // Transform (world -> screen) to keep TEE left, GREEN right, horizontally aligned and fully in view
    const view = { scale: 1, rot: 0, tx: 0, ty: 0, margin: 80 };

    function fitCanvas(){
      const r = canvas.getBoundingClientRect();
      canvas.width = Math.floor(r.width * devicePixelRatio);
      canvas.height = Math.floor(r.height * devicePixelRatio);
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      updateViewForHole();
      draw();
    }
    window.addEventListener('resize', fitCanvas);

    function worldToScreen(p){
      const s = Math.sin(view.rot), c = Math.cos(view.rot);
      const x = (p.x * view.scale), y = (p.y * view.scale);
      const xr =  x*c - y*s;
      const yr =  x*s + y*c;
      return { x: xr + view.tx, y: yr + view.ty };
    }
    function screenToWorld(p){
      // inverse of above
      const x = p.x - view.tx, y = p.y - view.ty;
      const s = Math.sin(-view.rot), c = Math.cos(-view.rot);
      const xr =  x*c - y*s;
      const yr =  x*s + y*c;
      return { x: xr / view.scale, y: yr / view.scale };
    }

    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    function pxToMeters(px){ return (course?.metersPerPixel || 0.3) * px; }
    function metersToYards(m){ return m * 1.09361; }

    // ====== Drawing ======
    function draw(){
      // bg
      ctx.fillStyle = '#0b0b0b';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Simple placeholder fairway (rotates with view via worldToScreen sampling)
      // We'll just draw a big rounded rect between tee and green to suggest a hole
      const h = currentHoleObj();
      if (h){
        const teeS = worldToScreen(h.tee);
        const greenS = worldToScreen(h.greenMid);

        // Fairway band
        ctx.save();
        ctx.strokeStyle = '#134e18';
        ctx.lineWidth = 60;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(teeS.x, teeS.y);
        ctx.lineTo(greenS.x, greenS.y);
        ctx.stroke();
        ctx.restore();

        // Inner fairway
        ctx.save();
        ctx.strokeStyle = '#1a6b24';
        ctx.lineWidth = 36;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(teeS.x, teeS.y);
        ctx.lineTo(greenS.x, greenS.y);
        ctx.stroke();
        ctx.restore();

        // Tee & green markers
        drawDot(h.tee, 10, '#3aa657');
        drawDot(h.greenMid, 11, '#8fd19e');
      }

      // Cart icon
      if (cartPt){
        drawCart(cartPt);
      }

      // Layup dot & lines
      if (layupPt && cartPt && h){
        // SOLID: cart → layup
        const A = worldToScreen(cartPt);
        const B = worldToScreen(layupPt);
        ctx.save();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
        ctx.restore();
        // Label at midpoint
        distanceBubble(cartPt, layupPt, 'Cart→Layup');

        // STRIPED: layup → mid green
        const C = worldToScreen(currentHoleObj().greenMid);
        ctx.save();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2.5;
        ctx.setLineDash([10,8]);
        ctx.beginPath();
        ctx.moveTo(B.x, B.y);
        ctx.lineTo(C.x, C.y);
        ctx.stroke();
        ctx.restore();
        // Label at midpoint
        distanceBubble(layupPt, currentHoleObj().greenMid, 'Layup→Mid');

        // Layup dot
        drawDot(layupPt, 8, '#ffcc00');
      } else if (cartPt && h){
        // Only Cart → Mid distance label
        distanceBubble(cartPt, h.greenMid, 'Cart→Mid');
      }

      updateHUD();
    }

    function drawDot(worldPt, r, color){
      const s = worldToScreen(worldPt);
      ctx.save();
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(s.x, s.y, r, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function drawCart(worldPt){
      const s = worldToScreen(worldPt);
      const w = 24, h = 14;
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.fillStyle = '#00c2ff';
      ctx.strokeStyle = '#0086b3';
      ctx.lineWidth = 1.5;
      // body
      ctx.beginPath();
      ctx.moveTo(-w/2, -h/2);
      ctx.lineTo(w/2, -h/2);
      ctx.lineTo(w/2-4, h/2);
      ctx.lineTo(-w/2+6, h/2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      // roof
      ctx.beginPath();
      ctx.moveTo(-w/2+2, -h/2);
      ctx.lineTo(w/2-2, -h/2);
      ctx.lineTo(w/2-8, -h/2-6);
      ctx.lineTo(-w/2+10, -h/2-6);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      // wheels
      ctx.beginPath();
      ctx.fillStyle = '#0b0b0b';
      ctx.arc(-w/4, h/2+3, 4, 0, Math.PI*2);
      ctx.arc(w/4, h/2+3, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function distanceBubble(p1, p2, label){
      const mid = { x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 };
      const s = worldToScreen(mid);
      // Offset the bubble slightly perpendicular to the segment so it doesn't sit on the line
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const len = Math.hypot(dx,dy) || 1;
      const nx = -dy/len, ny = dx/len;
      const offset = 12;
      const px = s.x + nx*offset, py = s.y + ny*offset;

      const meters = pxToMeters(dist(p1,p2));
      const yards = metersToYards(meters);
      const txt = `${label}: ${Math.round(meters)} m (${Math.round(yards)} yd)`;

      // draw a solid black bubble
      ctx.save();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial';
      const padX = 8, padY = 6;
      const w = ctx.measureText(txt).width + padX*2;
      const h = 22;
      ctx.fillStyle = '#000';
      ctx.strokeStyle = '#262626';
      ctx.lineWidth = 1;
      roundRect(ctx, px - w/2, py - h/2, w, h, 10);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.textBaseline = 'middle';
      ctx.fillText(txt, px - w/2 + padX, py);
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    function updateHUD(){
      hud.innerHTML = '';
      const h = currentHoleObj();
      if (!h) return;
      addBubble(`<strong>H${h.no}</strong> • Par ${h.par} • SI ${h.strokeIndex}`);
    }
    function addBubble(html){
      const d = document.createElement('div');
      d.className = 'bubble';
      d.innerHTML = html;
      hud.appendChild(d);
    }

    // ====== Interactions ======
    function toLocal(evt){
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left);
      const y = (evt.clientY - rect.top);
      return screenToWorld({ x, y });
    }

    canvas.addEventListener('pointerdown', (e)=>{
      const world = toLocal(e);
      const screen = worldToScreen(world);
      const atBottom = screen.y > canvas.height/devicePixelRatio - 80;
      if (!cartPt && atBottom){
        cartPt = world; // initial set by bottom tap, though we default to tee on load
      } else {
        layupPt = world;
      }
      draw();
    });

    layupClearBtn.addEventListener('click', ()=>{
      layupPt = null;
      draw();
    });

    // ====== Course / View handling ======
    function currentHoleObj(){
      return course?.holes?.find(x=>x.no===currentHole);
    }

    function updateViewForHole(){
      const h = currentHoleObj();
      if (!h) return;
      // vector tee -> green
      const vx = h.greenMid.x - h.tee.x;
      const vy = h.greenMid.y - h.tee.y;
      const angle = Math.atan2(vy, vx); // angle of the hole
      // rotate so tee->green is horizontal left-to-right: subtract current angle
      view.rot = -angle;

      // rotate both points then compute scale & translation to fit with margins
      const pts = [h.tee, h.greenMid].map(p=>{
        const x = p.x, y = p.y;
        const s = Math.sin(view.rot), c = Math.cos(view.rot);
        const xr =  x*c - y*s;
        const yr =  x*s + y*c;
        return {x:xr, y:yr};
      });
      // Ensure tee is left of green after rotation; if not, flip by 180deg
      if (pts[0].x > pts[1].x){
        view.rot += Math.PI;
        // recompute rotated points
        const s = Math.sin(view.rot), c = Math.cos(view.rot);
        pts[0] = { x: h.tee.x*c - h.tee.y*s, y: h.tee.x*s + h.tee.y*c };
        pts[1] = { x: h.greenMid.x*c - h.greenMid.y*s, y: h.greenMid.x*s + h.greenMid.y*c };
      }

      const minX = Math.min(pts[0].x, pts[1].x), maxX = Math.max(pts[0].x, pts[1].x);
      const minY = Math.min(pts[0].y, pts[1].y), maxY = Math.max(pts[0].y, pts[1].y);
      const holeW = (maxX - minX) || 1;
      const holeH = (maxY - minY) || 1;

      const availW = canvas.width/devicePixelRatio - view.margin*2;
      const availH = canvas.height/devicePixelRatio - view.margin*2;
      view.scale = Math.min(availW / holeW, Math.max(1, availH / Math.max(holeH, 160))); // keep decent height

      // translate so that minX,minY aligns to margin, and vertically centered
      const afterMin = { x: minX*view.scale, y: minY*view.scale };
      const afterMax = { x: maxX*view.scale, y: maxY*view.scale };
      const neededW = afterMax.x - afterMin.x;
      const neededH = afterMax.y - afterMin.y;

      const targetX = view.margin;
      const targetY = (canvas.height/devicePixelRatio - neededH)/2;

      // We want tee at left margin
      view.tx = targetX - afterMin.x;
      view.ty = targetY - afterMin.y;
    }

    async function boot(){
      const params = new URLSearchParams(location.search);
      const id = params.get('courseId') || localStorage.getItem('ddgps:lastCourseId');
      if(!id){ location.href = './index.html'; return; }
      const name = localStorage.getItem('ddgps:lastCourseName') || 'Course';
      courseTitle.textContent = name;

      try{
        const res = await fetch(`./courses/${id}.json`, { cache: 'no-store' });
        course = await res.json();
      }catch(e){
        console.error(e);
        course = fallbackCourse(name);
      }
      currentHole = course.startHole || 1;

      // Default CART view = cart at tee to begin with
      const h = currentHoleObj();
      cartPt = h?.tee ? { x:h.tee.x, y:h.tee.y } : null;

      updateHoleChip();
      fitCanvas();
      buildScorecard();
      renderHistory();
    }

    function updateHoleChip(){
      const h = currentHoleObj();
      if(!h) return;
      holeChip.textContent = `Hole ${h.no} • Par ${h.par} • SI ${h.strokeIndex}`;
      updateViewForHole();
      draw();
    }

    document.getElementById('prevHole').onclick = ()=>{ currentHole = Math.max(1, currentHole-1); layupPt=null; updateHoleChip(); };
    document.getElementById('nextHole').onclick = ()=>{ currentHole = Math.min(course.holes.length, currentHole+1); layupPt=null; updateHoleChip(); };

    // ====== Fallback course ======
    function fallbackCourse(name){
      return {
        name,
        metersPerPixel: 0.35,
        startHole: 1,
        holes: Array.from({length:18}, (_,i)=> ({
          no:i+1, par:[4,4,3,5,4,3,5,4,4, 4,4,3,5,4,3,5,4,4][i],
          strokeIndex:(i%18)+1,
          tee:{x:120, y: 320},
          greenMid:{x: 920, y: 180}
        }))
      };
    }

    // ====== Scorecard (Classic layout) ======
    const scorecardHost = document.getElementById('scorecard');
    const playersCountSel = document.getElementById('playersCount');
    const hcpTypeSel = document.getElementById('hcpType');

    playersCountSel.onchange = buildScorecard;
    hcpTypeSel.onchange = ()=>{ applyHandicapDots(); recomputeAll(); };

    let players = 2;
    let cardData = []; // [{name,hcp,scores:[..], points:[..]}]

    function buildScorecard(){
      players = parseInt(playersCountSel.value,10);
      const holes = course?.holes || [];
      const nHoles = holes.length;
      const frontCount = Math.min(9, nHoles);
      const backCount = Math.max(0, nHoles - 9);

      // data
      cardData = Array.from({length:players}, (_,pi)=>({
        name: 'Player ' + (pi+1),
        hcp: 18,
        scores: Array(nHoles).fill(''),
        points: Array(nHoles).fill(0)
      }));

      // header
      const thead = `
        <thead>
          <tr>
            <th class="sticky" style="text-align:left">Player</th>
            ${Array.from({length:frontCount}, (_,i)=>`<th class="sticky">${i+1}</th>`).join('')}
            <th class="sticky">OUT</th>
            ${backCount ? Array.from({length:backCount}, (_,i)=>`<th class="sticky">${i+10}</th>`).join('') : ''}
            ${backCount ? '<th class="sticky">IN</th>' : ''}
            <th class="sticky">TOTAL</th>
            <th class="sticky">Pts</th>
          </tr>
        </thead>`;

      // body rows
      let bodyRows = '';
      for (let i=0;i<players;i++){
        const nameCell = `
          <td style="text-align:left">
            <div class="sc-player">
              <input class="small name" value="Player ${i+1}" data-pi="${i}" data-field="name">
              <div class="muted">Hcp: <input class="small" value="18" data-pi="${i}" data-field="hcp" title="Handicap"></div>
            </div>
          </td>`;

        const frontInputs = Array.from({length:frontCount}, (_,hi)=>`<td><input class="small" data-pi="${i}" data-hi="${hi}" placeholder="-"></td>`).join('');
        const outCell = `<td id="out-${i}">0</td>`;
        const backInputs = backCount ? Array.from({length:backCount}, (_,k)=>{
          const hi = 9 + k;
          return `<td><input class="small" data-pi="${i}" data-hi="${hi}" placeholder="-"></td>`;
        }).join('') : '';
        const inCell = backCount ? `<td id="in-${i}">0</td>` : '';
        const totalCell = `<td id="total-${i}">0</td>`;
        const ptsCell = `<td id="pts-${i}">0</td>`;

        bodyRows += `<tr>${nameCell}${frontInputs}${outCell}${backInputs}${inCell}${totalCell}${ptsCell}</tr>`;
      }

      scorecardHost.innerHTML = `<div style="overflow:auto"><table class="scorecard">${thead}<tbody id="scBody">${bodyRows}</tbody></table></div>`;

      scorecardHost.querySelectorAll('input').forEach(inp=>{
        inp.addEventListener('input', onScoreInput);
      });

      applyHandicapDots();
      recomputeAll();
    }

    function onScoreInput(e){
      const pi = parseInt(e.target.dataset.pi,10);
      const field = e.target.dataset.field;
      if (field === 'name'){ cardData[pi].name = e.target.value; return; }
      if (field === 'hcp'){ 
        const v = Math.max(0, Math.min(54, parseInt(e.target.value||'0',10)));
        cardData[pi].hcp = v; 
        applyHandicapDots();
        recomputeAll(); 
        return; 
      }
      const hi = parseInt(e.target.dataset.hi,10);
      const v = e.target.value.trim()==='' ? '' : Math.max(0, parseInt(e.target.value,10));
      cardData[pi].scores[hi] = v;
      recomputeAll();
    }

    function applyHandicapDots(){
      const base = parseInt(hcpTypeSel.value,10) || 18;
      const holes = course.holes;
      for (let p of cardData){
        const hcp = p.hcp;
        const unit = base === 0 ? 18 : base;
        const full = Math.floor(hcp / unit);
        const rem = hcp % unit;
        p.hcpStrokes = holes.map(()=> full);
        const sorted = holes.map((h,idx)=>({idx,si:h.strokeIndex})).sort((a,b)=>a.si-b.si);
        for (let i=0;i<rem;i++){
          p.hcpStrokes[sorted[i%holes.length].idx] += 1;
        }
      }
    }

    function stablefordPoints(gross, par, strokes){
      if (gross==='' || gross==null) return 0;
      const net = gross - strokes;
      const diff = net - par;
      if (diff <= -3) return 5;
      if (diff === -2) return 4;
      if (diff === -1) return 3;
      if (diff === 0) return 2;
      if (diff === 1) return 1;
      return 0;
    }

    function recomputeAll(){
      const holes = course.holes;
      const n = holes.length;
      for (let pi=0; pi<cardData.length; pi++){
        const p = cardData[pi];
        let out = 0, inn = 0, totalNet = 0, totalPts = 0;
        for (let hi=0; hi<n; hi++){
          const gross = p.scores[hi];
          const strokes = p.hcpStrokes?.[hi] || 0;
          const pts = stablefordPoints(gross, holes[hi].par, strokes);
          p.points[hi] = pts;
          if (gross !== '' && gross != null){
            totalNet += (gross - strokes);
            if (hi < 9) out += (gross - strokes); else inn += (gross - strokes);
          }
          totalPts += pts;
        }
        document.getElementById('out-'+pi).textContent = out;
        const inCell = document.getElementById('in-'+pi);
        if (inCell) inCell.textContent = inn;
        document.getElementById('total-'+pi).textContent = out + inn;
        document.getElementById('pts-'+pi).textContent = totalPts;
      }
    }

    // ====== History (summary only) ======
    document.getElementById('saveRound').onclick = ()=>{
      const date = new Date().toISOString().slice(0,10);
      const rec = {
        date,
        course: courseTitle.textContent,
        players: cardData.map(p=>{
          const holes = course.holes;
          let out=0, inn=0, totalPts=0;
          for (let hi=0; hi<holes.length; hi++){
            const gross = p.scores[hi];
            const strokes = p.hcpStrokes?.[hi] || 0;
            if (gross !== '' && gross != null){
              if (hi<9) out += (gross - strokes); else inn += (gross - strokes);
            }
            totalPts += p.points[hi]||0;
          }
          return { name:p.name, hcp:p.hcp, out, inn, total: out+inn, points: totalPts };
        })
      };
      const key = 'ddgps:history';
      const list = JSON.parse(localStorage.getItem(key)||'[]');
      list.unshift(rec);
      localStorage.setItem(key, JSON.stringify(list));
      toast('Saved to history');
      renderHistory();
    };

    function renderHistory(){
      const key = 'ddgps:history';
      const list = JSON.parse(localStorage.getItem(key)||'[]');
      const host = document.getElementById('history');
      if (!list.length){ host.innerHTML = '<p class="muted">No saved rounds yet.</p>'; return; }
      host.innerHTML = list.map(rec=>{
        const rows = rec.players.map(p=>`
          <tr><td style="text-align:left">${p.name}</td><td>${p.hcp}</td><td>${p.out}</td><td>${p.inn}</td><td>${p.total}</td><td>${p.points}</td></tr>`).join('');
        return `
          <div style="border:1px solid #2a2a2a;border-radius:12px;overflow:hidden;margin:6px 0">
            <div style="background:#151515;padding:8px 10px;display:flex;justify-content:space-between">
              <div><strong>${rec.course}</strong></div><div class="muted">${rec.date}</div>
            </div>
            <div style="padding:0;overflow:auto">
              <table class="scorecard" style="min-width:560px">
                <thead>
                  <tr><th>Player</th><th>Hcp</th><th>OUT</th><th>IN</th><th>Total</th><th>Pts</th></tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>
          </div>`;
      }).join('');
    }

    function toast(msg){
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(()=> t.classList.remove('show'), 1500);
    }

    // ====== Boot ======
    boot();
  </script>
</body>
</html>
