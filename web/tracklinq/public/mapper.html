<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TrackLinq Mapper</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- Leaflet.draw for polygon & freehand shapes -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <style>
    :root{
      --bg:#f7faf7; --panel:#fff; --text:#0b0b0b; --muted:#6b7280; --border:#dbe5d9;
      --green:#16a34a; --yellow:#fbbf24; --red:#ef4444; --blue:#0ea5e9; --gray:#6b7280;
    }
    html, body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:var(--bg); color:var(--text); }
    #map { position:absolute; inset:0; }

    .panel {
      position:absolute; top:10px; left:10px; z-index:1000;
      width:min(92vw,380px); max-height:88vh; overflow:auto;
      background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px;
      box-shadow:0 6px 18px rgba(0,0,0,0.08);
    }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .row4 { display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; }
    .row > * , .row3 > *, .row4 > * { width:100%; }

    input, select, button, textarea {
      border:1px solid var(--border); border-radius:10px; padding:8px 10px; background:#fff; color:var(--text);
    }
    button { cursor:pointer; font-weight:800; }
    h2 { margin:0 0 8px 0; font-size:16px; }
    h3 { margin:12px 0 6px 0; font-size:13px; color:#111; }

    .toolgrid { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; margin-top:6px; }
    .tool { display:flex; align-items:center; gap:8px; padding:8px; border:1px solid var(--border); border-radius:12px; background:#fff; cursor:pointer; }
    .tool.active { outline:2px solid var(--green); }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .muted { color:var(--muted); font-size:12px; }

    .saveRow { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }

    /* Drawn polygon style */
    .no-go { color:#ef4444; fill:#ef4444; fill-opacity:0.25; stroke:#ef4444; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <h2>TrackLinq Mapper</h2>

    <div class="row">
      <div>
        <label class="muted">Course Name</label>
        <input id="courseName" placeholder="e.g., Waterkloof Golf Club" />
      </div>
      <div>
        <label class="muted">Course ID (file name)</label>
        <input id="courseId" placeholder="e.g., WGC-course" />
      </div>
    </div>

    <div class="row">
      <div>
        <label class="muted">10-digit PIN</label>
        <input id="coursePin" placeholder="e.g., WGC1234567" maxlength="10" />
      </div>
      <div>
        <label class="muted"># Holes</label>
        <select id="holeCount">
          <option>9</option><option selected>18</option><option>27</option><option>36</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label class="muted">Hole</label>
        <select id="holeNo"></select>
      </div>
      <div class="row">
        <div>
          <label class="muted">Par</label>
          <input id="holePar" type="number" min="3" max="6" value="4"/>
        </div>
        <div>
          <label class="muted">Stroke</label>
          <input id="holeStroke" type="number" min="1" max="36" value="1"/>
        </div>
      </div>
    </div>

    <h3>Place Pins</h3>
    <div class="toolgrid" id="tools">
      <div class="tool" data-tool="TEE"><span>üèåÔ∏è‚Äç‚ôÇÔ∏è</span><span>TEE</span></div>
      <div class="tool" data-tool="FRONT"><span class="dot" style="background:#ffffff"></span><span>FRONT</span></div>
      <div class="tool" data-tool="MID"><span class="dot" style="background:#fbbf24"></span><span>MID (flag)</span></div>
      <div class="tool" data-tool="BACK"><span class="dot" style="background:#ef4444"></span><span>BACK</span></div>
      <div class="tool" data-tool="TOILET"><span>üöª</span><span>Toilet</span></div>
      <div class="tool" data-tool="TAPS"><span>üö∞</span><span>Tap</span></div>
      <div class="tool" data-tool="STAKE_WHITE"><span class="dot" style="background:#ffffff"></span><span>Stake (White)</span></div>
      <div class="tool" data-tool="STAKE_RED"><span class="dot" style="background:#ef4444"></span><span>Stake (Red)</span></div>
      <div class="tool" data-tool="STAKE_YELLOW"><span class="dot" style="background:#fbbf24"></span><span>Stake (Yellow)</span></div>
      <div class="tool" data-tool="NO_GO"><span>‚õî</span><span>No-Go Zone</span></div>
      <div class="tool" data-tool="MOVE"><span>‚ú•</span><span>Move/Select</span></div>
      <div class="tool" data-tool="ERASE"><span>üóëÔ∏è</span><span>Erase</span></div>
    </div>
    <div class="muted" style="margin-top:6px;">Click a tool, then click the map to place. For <strong>No‚ÄëGo Zone</strong>, draw a polygon.</div>

    <div class="saveRow">
      <button id="saveHole">Save Hole</button>
      <button id="clearHole">Clear Hole</button>
      <button id="downloadJson">Download Course JSON</button>
      <button id="loadLocal">Load Saved (Local)</button>
      <button id="saveLocal">Save (Local)</button>
    </div>
    <div id="status" class="muted" style="margin-top:6px;"></div>
  </div>

  <script>
    // --- Map & Icons ---
    const map = L.map('map', { zoomControl:true, attributionControl:false }).setView([-25.746, 28.229], 17);
    L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 20 }
    ).addTo(map);

    // Small, clean dots (no border)
    function dotIcon(color='#ffffff', size=10){
      const r=Math.floor(size/2);
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'>
          <circle cx='${r}' cy='${r}' r='${r}' fill='${color}' />
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[r,r] });
    }

    function flagMidIcon(size=18){
      // Yellow dot with a small flagstick
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 24 24'>
          <circle cx='12' cy='12' r='5' fill='#fbbf24'/>
          <rect x='11.5' y='4' width='1' height='8' fill='#374151'/>
          <path d='M12 5 L17 7 L12 9 Z' fill='#16a34a'/>
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[12,12] });
    }

    function teeIcon(size=18){
      // Simple tee marker icon
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 24 24'>
          <circle cx='12' cy='8' r='4' fill='#16a34a'/>
          <rect x='11' y='10' width='2' height='8' fill='#3b3b3b'/>
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[12,12] });
    }

    function smallSymbol(svgPath,size=18){
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 24 24'>${svgPath}</svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[12,12] });
    }
    const TOILET_SVG = `<rect x='3' y='3' width='18' height='18' rx='4' fill='#6b7280'/><path d='M8 16h2l1-5 1 5h2l-2-8h-2l-2 8Zm6 0h2v-3h2v3h2V8h-2v3h-2V8h-2v8Z' fill='white'/>`;
    const TAP_SVG = `<rect x='3' y='3' width='18' height='18' rx='4' fill='#0ea5e9'/><path d='M6 11h6V9h2V7h6v2h-5v2h-3v3h3v2H9v-2h2v-3H6v-2Z' fill='white'/>`;

    const ICONS = {
      TEE: teeIcon(18),
      FRONT: dotIcon('#ffffff', 10),
      MID: flagMidIcon(18),
      BACK: dotIcon('#ef4444', 10),
      TOILET: smallSymbol(TOILET_SVG, 18),
      TAPS: smallSymbol(TAP_SVG, 18),
      STAKE_WHITE: dotIcon('#ffffff', 6),
      STAKE_RED: dotIcon('#ef4444', 6),
      STAKE_YELLOW: dotIcon('#fbbf24', 6)
    };

    // Draw layer for no-go zones
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
      draw: {
        polygon: {
          shapeOptions: { color:'#ef4444', weight:2, fill:true, fillColor:'#ef4444', fillOpacity:0.25, className:'no-go' }
        },
        polyline: false, rectangle: false, circle: false, circlemarker: false, marker: false
      },
      edit: { featureGroup: drawnItems, edit: true, remove: true }
    });

    // We'll toggle this control only when NO_GO tool is active.
    let drawAdded = false;

    // --- State ---
    const $ = sel => document.querySelector(sel);
    const $$ = sel => document.querySelectorAll(sel);
    const status = msg => { const s=$('#status'); s.textContent=msg; };

    const state = {
      course: {
        course: { id:'', name:'', pin:'' },
        holes: {} // "1": { par, stroke, pins:{} }
      },
      holeCount: 18,
      hole: 1,
      tool: 'MOVE',
      markers: [], // live markers per hole for edit
      stakes: { STAKE_WHITE:[], STAKE_RED:[], STAKE_YELLOW:[] } // temp edit arrays
    };

    // --- UI Init ---
    function fillHoleDropdown(n=18){
      const sel = $('#holeNo');
      sel.innerHTML = '';
      for(let i=1;i<=n;i++){
        const opt=document.createElement('option');
        opt.value=String(i); opt.textContent=String(i);
        sel.appendChild(opt);
      }
      sel.value = String(state.hole);
    }
    fillHoleDropdown(18);

    $('#holeCount').addEventListener('change', e=>{
      state.holeCount = parseInt(e.target.value,10);
      fillHoleDropdown(state.holeCount);
      status('Hole count updated');
    });

    $('#holeNo').addEventListener('change', e=>{
      saveHoleToState();
      state.hole = parseInt(e.target.value,10);
      loadHoleToUI();
    });

    // Tools activation
    $$('#tools .tool').forEach(t=>{
      t.addEventListener('click', ()=>{
        $$('#tools .tool').forEach(x=>x.classList.remove('active'));
        t.classList.add('active');
        state.tool = t.dataset.tool;
        // Toggle draw controls
        if (state.tool==='NO_GO'){
          if (!drawAdded){ map.addControl(drawControl); drawAdded=true; }
        } else {
          if (drawAdded){ map.removeControl(drawControl); drawAdded=false; }
        }
      });
    });
    // Default active tool
    document.querySelector('[data-tool="MOVE"]').classList.add('active');

    // --- Elevation helper ---
    async function fetchElevation(lat,lng){
      // Online call to free API. If it fails, return null (we still save lat/lng).
      try{
        const r = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`);
        const j = await r.json();
        const e = j?.results?.[0]?.elevation;
        return Number.isFinite(e) ? e : null;
      }catch(_){ return null; }
    }

    // --- Map click behavior ---
    map.on('click', async (e)=>{
      const { lat, lng } = e.latlng;
      const tool = state.tool;
      if (tool==='MOVE' || tool==='ERASE') return;

      const ele = await fetchElevation(lat, lng);
      const base = { lat, lng };
      if (Number.isFinite(ele)) base.ele = ele;

      const pins = getHolePins();
      let m;

      if (tool==='TEE'){
        pins.TEE = base;
        m = addMarker(ICONS.TEE, base, 'TEE', true);
      } else if (tool==='FRONT'){
        pins.FRONT = base;
        m = addMarker(ICONS.FRONT, base, 'FRONT', true);
      } else if (tool==='MID'){
        pins.MID = base;
        m = addMarker(ICONS.MID, base, 'MID', true);
      } else if (tool==='BACK'){
        pins.BACK = base;
        m = addMarker(ICONS.BACK, base, 'BACK', true);
      } else if (tool==='TOILET'){
        pins.TOILET = base;
        m = addMarker(ICONS.TOILET, base, 'Toilet', true);
      } else if (tool==='TAPS'){
        pins.TAPS = pins.TAPS || [];
        pins.TAPS.push(base);
        m = addMarker(ICONS.TAPS, base, 'Tap', false, 'TAPS', pins.TAPS.length-1);
      } else if (tool==='STAKE_WHITE' || tool==='STAKE_RED' || tool==='STAKE_YELLOW'){
        const key = tool;
        pins[key] = pins[key] || [];
        pins[key].push(base);
        m = addMarker(ICONS[key], base, key.replace('STAKE_','Stake '), false, key, pins[key].length-1);
      }
      status(`${tool} placed at ${lat.toFixed(6)}, ${lng.toFixed(6)}${Number.isFinite(ele)?' ‚Ä¢ Elev '+ele+'m':''}`);
    });

    map.on(L.Draw.Event.CREATED, function (event) {
      if (state.tool!=='NO_GO') return;
      const layer = event.layer;
      drawnItems.addLayer(layer);
      // Save polygon to hole pins as NO_GO (array of polygons; each polygon is array of latlng objects)
      const latlngs = layer.getLatLngs()[0] || [];
      const poly = latlngs.map(pt => ({ lat: pt.lat, lng: pt.lng }));
      const pins = getHolePins();
      pins.NO_GO = pins.NO_GO || [];
      pins.NO_GO.push(poly);
      status(`No-Go zone added with ${poly.length} points`);
    });

    // --- Marker helpers ---
    function clearLiveMarkers(){
      state.markers.forEach(m => {
        try { map.removeLayer(m.layer); } catch{}
      });
      state.markers.length = 0;
      drawnItems.clearLayers();
    }

    function addMarker(icon, pos, title, unique=false, listKey=null, listIndex=null){
      const marker = L.marker([pos.lat, pos.lng], { icon, draggable:true, title });
      marker.addTo(map);
      const rec = { layer: marker, listKey, listIndex, uniqueKey: unique ? title : null };
      state.markers.push(rec);

      marker.on('dragend', async () => {
        const ll = marker.getLatLng();
        const elev = await fetchElevation(ll.lat, ll.lng);
        const pins = getHolePins();
        const obj = { lat: ll.lat, lng: ll.lng };
        if (Number.isFinite(elev)) obj.ele = elev;

        if (rec.uniqueKey){
          pins[rec.uniqueKey] = obj;
        } else if (rec.listKey){
          pins[rec.listKey][rec.listIndex] = obj;
        }
        status(`${title} moved to ${ll.lat.toFixed(6)}, ${ll.lng.toFixed(6)}${Number.isFinite(elev)?' ‚Ä¢ Elev '+elev+'m':''}`);
      });

      marker.on('click', ()=>{
        if (state.tool!=='ERASE') return;
        // Remove from map + state
        map.removeLayer(marker);
        const pins = getHolePins();
        if (rec.uniqueKey){
          delete pins[rec.uniqueKey];
        } else if (rec.listKey){
          try { pins[rec.listKey].splice(rec.listIndex,1); } catch{}
        }
        // remove from local array
        state.markers = state.markers.filter(x => x.layer !== marker);
        status(`${title} removed`);
      });

      return marker;
    }

    function getHolePins(){
      const hKey = String(state.hole);
      state.course.holes[hKey] = state.course.holes[hKey] || { par:4, stroke:1, pins:{} };
      state.course.holes[hKey].par = parseInt($('#holePar').value,10) || 4;
      state.course.holes[hKey].stroke = parseInt($('#holeStroke').value,10) || 1;
      state.course.holes[hKey].pins = state.course.holes[hKey].pins || {};
      return state.course.holes[hKey].pins;
    }

    function saveHoleToState(){
      const hKey = String(state.hole);
      const h = state.course.holes[hKey] || { par:4, stroke:1, pins:{} };
      h.par = parseInt($('#holePar').value,10) || 4;
      h.stroke = parseInt($('#holeStroke').value,10) || 1;
      state.course.holes[hKey] = h;
      status(`Hole ${hKey} saved`);
    }

    function loadHoleToUI(){
      clearLiveMarkers();
      const hKey = String(state.hole);
      const h = state.course.holes[hKey];
      $('#holePar').value = h?.par ?? 4;
      $('#holeStroke').value = h?.stroke ?? 1;
      const p = h?.pins || {};

      // Unique markers
      if (p.TEE)   addMarker(ICONS.TEE, p.TEE, 'TEE', true);
      if (p.FRONT) addMarker(ICONS.FRONT, p.FRONT, 'FRONT', true);
      if (p.MID)   addMarker(ICONS.MID, p.MID, 'MID', true);
      if (p.BACK)  addMarker(ICONS.BACK, p.BACK, 'BACK', true);
      if (p.TOILET) addMarker(ICONS.TOILET, p.TOILET, 'Toilet', true);

      // Lists
      (p.TAPS || []).forEach((obj, i)=> addMarker(ICONS.TAPS, obj, 'Tap', false, 'TAPS', i));
      (p.STAKE_WHITE || []).forEach((obj, i)=> addMarker(ICONS.STAKE_WHITE, obj, 'Stake White', false, 'STAKE_WHITE', i));
      (p.STAKE_RED || []).forEach((obj, i)=> addMarker(ICONS.STAKE_RED, obj, 'Stake Red', false, 'STAKE_RED', i));
      (p.STAKE_YELLOW || []).forEach((obj, i)=> addMarker(ICONS.STAKE_YELLOW, obj, 'Stake Yellow', false, 'STAKE_YELLOW', i));

      // No-go polygons
      (p.NO_GO || []).forEach(poly => {
        const latlngs = poly.map(pt => L.latLng(pt.lat, pt.lng));
        const layer = L.polygon(latlngs, { color:'#ef4444', weight:2, fill:true, fillColor:'#ef4444', fillOpacity:0.25, className:'no-go' });
        drawnItems.addLayer(layer);
      });
    }

    // --- Save / Load Course ---
    function collectCourse(){
      state.course.course.id = ($('#courseId').value || '').trim();
      state.course.course.name = ($('#courseName').value || '').trim();
      state.course.course.pin = ($('#coursePin').value || '').trim().toUpperCase();
      return state.course;
    }

    $('#saveHole').addEventListener('click', ()=>{
      saveHoleToState();
    });

    $('#clearHole').addEventListener('click', ()=>{
      if (!confirm('Clear all pins for this hole?')) return;
      const hKey=String(state.hole);
      state.course.holes[hKey] = { par:4, stroke:1, pins:{} };
      loadHoleToUI();
      status(`Hole ${hKey} cleared`);
    });

    $('#downloadJson').addEventListener('click', ()=>{
      saveHoleToState();
      const obj = collectCourse();
      if (!obj.course.id){ alert('Please enter a Course ID (file name)'); return; }
      const blob = new Blob([JSON.stringify(obj,null,2)], { type:'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${obj.course.id}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
      status('Course JSON downloaded');
    });

    const LOCAL_KEY = 'tl_mapper_draft';
    $('#saveLocal').addEventListener('click', ()=>{
      saveHoleToState();
      collectCourse();
      localStorage.setItem(LOCAL_KEY, JSON.stringify(state.course));
      status('Saved to local storage');
    });
    $('#loadLocal').addEventListener('click', ()=>{
      try{
        const raw = localStorage.getItem(LOCAL_KEY);
        if (!raw) return alert('No local save found');
        const obj = JSON.parse(raw);
        state.course = obj;
        $('#courseId').value = obj.course?.id || '';
        $('#courseName').value = obj.course?.name || '';
        $('#coursePin').value = obj.course?.pin || '';
        const most = Math.max(...Object.keys(obj.holes||{}).map(k=>+k).filter(n=>Number.isFinite(n)));
        const inferredCount = Number.isFinite(most) ? Math.max(most, 18) : 18;
        $('#holeCount').value = String(inferredCount);
        state.holeCount = inferredCount;
        fillHoleDropdown(inferredCount);
        state.hole = 1;
        $('#holeNo').value = '1';
        loadHoleToUI();
        status('Local save loaded');
      }catch(e){
        alert('Failed to load local save');
      }
    });

    // Fit map to current hole markers
    function fitToHole(){
      const h = state.course.holes[String(state.hole)];
      const pins = h?.pins || {};
      const list = [];
      ['TEE','FRONT','MID','BACK','TOILET'].forEach(k=>{ if(pins[k]) list.push([pins[k].lat,pins[k].lng]); });
      (pins.TAPS||[]).forEach(t=> list.push([t.lat,t.lng]));
      (pins.STAKE_WHITE||[]).forEach(t=> list.push([t.lat,t.lng]));
      (pins.STAKE_RED||[]).forEach(t=> list.push([t.lat,t.lng]));
      (pins.STAKE_YELLOW||[]).forEach(t=> list.push([t.lat,t.lng]));
      if (list.length){
        map.fitBounds(L.latLngBounds(list), { padding:[40,40] });
      }
    }

    // Update course meta live
    ['#courseId','#courseName','#coursePin'].forEach(sel=>{
      $(sel).addEventListener('input', ()=> collectCourse());
    });

    // After any load, try to fit
    map.whenReady(()=> setTimeout(fitToHole, 300));
  </script>
</body>
</html>
