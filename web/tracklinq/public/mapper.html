<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TrackLinq Mapper</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <style>
    :root{
      --bg:#f7faf7; --panel:#fff; --text:#0b0b0b; --muted:#6b7280; --border:#dbe5d9;
      --green:#16a34a; --yellow:#fbbf24; --red:#ef4444; --blue:#0ea5e9; --gray:#6b7280;
    }
    html, body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:var(--bg); color:var(--text); }
    #map { position:absolute; inset:0; }

    .panel {
      position:absolute; top:10px; left:10px; z-index:1000;
      width:min(92vw,380px); max-height:88vh; overflow:auto;
      background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px;
      box-shadow:0 6px 18px rgba(0,0,0,0.08);
    }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .row4 { display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; }
    .row > * , .row3 > *, .row4 > * { width:100%; }

    input, select, button {
      border:1px solid var(--border); border-radius:10px; padding:8px 10px; background:#fff; color:var(--text);
    }
    button { cursor:pointer; font-weight:800; }
    h2 { margin:0 0 8px 0; font-size:16px; }
    h3 { margin:12px 0 6px 0; font-size:13px; color:#111; }

    .toolgrid { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; margin-top:6px; }
    .tool { display:flex; align-items:center; gap:8px; padding:8px; border:1px solid var(--border); border-radius:12px; background:#fff; cursor:pointer; }
    .tool.active { outline:2px solid var(--green); }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .muted { color:var(--muted); font-size:12px; }

    .saveRow { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .nogobar { display:none; gap:8px; margin-top:8px; }
    .nogobar.show { display:flex; flex-wrap:wrap; }

    .status { margin-top:8px; font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <h2>TrackLinq Mapper</h2>

    <div class="row">
      <div>
        <label class="muted">Course Name</label>
        <input id="courseName" placeholder="e.g., Waterkloof Golf Club" />
      </div>
      <div>
        <label class="muted">Course ID (file name)</label>
        <input id="courseId" placeholder="e.g., WGC-course" />
      </div>
    </div>

    <div class="row">
      <div>
        <label class="muted">10-digit PIN</label>
        <input id="coursePin" placeholder="e.g., WGC1234567" maxlength="10" />
      </div>
      <div>
        <label class="muted"># Holes</label>
        <select id="holeCount">
          <option>9</option><option selected>18</option><option>27</option><option>36</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label class="muted">Hole</label>
        <select id="holeNo"></select>
      </div>
      <div class="row">
        <div>
          <label class="muted">Par</label>
          <input id="holePar" type="number" min="3" max="6" value="4"/>
        </div>
        <div>
          <label class="muted">Stroke</label>
          <input id="holeStroke" type="number" min="1" max="36" value="1"/>
        </div>
      </div>
    </div>

    <h3>Place Pins</h3>
    <div class="toolgrid" id="tools">
      <div class="tool" data-tool="TEE"><span>üèåÔ∏è‚Äç‚ôÇÔ∏è</span><span>TEE</span></div>
      <div class="tool" data-tool="FRONT"><span class="dot" style="background:#ffffff"></span><span>FRONT</span></div>
      <div class="tool" data-tool="MID"><span class="dot" style="background:#fbbf24"></span><span>MID (flag)</span></div>
      <div class="tool" data-tool="BACK"><span class="dot" style="background:#ef4444"></span><span>BACK</span></div>
      <div class="tool" data-tool="TOILET"><span>üöª</span><span>Toilet</span></div>
      <div class="tool" data-tool="TAPS"><span>üö∞</span><span>Tap</span></div>
      <div class="tool" data-tool="STAKE_WHITE"><span class="dot" style="background:#ffffff"></span><span>Stake (White)</span></div>
      <div class="tool" data-tool="STAKE_RED"><span class="dot" style="background:#ef4444"></span><span>Stake (Red)</span></div>
      <div class="tool" data-tool="STAKE_YELLOW"><span class="dot" style="background:#fbbf24"></span><span>Stake (Yellow)</span></div>
      <div class="tool" data-tool="NO_GO"><span>‚õî</span><span>No-Go Zone</span></div>
      <div class="tool" data-tool="MOVE"><span>‚ú•</span><span>Move/Select</span></div>
      <div class="tool" data-tool="ERASE"><span>üóëÔ∏è</span><span>Erase</span></div>
    </div>
    <div class="muted" style="margin-top:6px;">
      Click a tool, then click the map to place. For <strong>No‚ÄëGo Zone</strong>, click to add vertices, then double‚Äëclick or press ‚ÄúFinish Zone‚Äù to complete.
    </div>

    <div class="nogobar" id="nogobar">
      <button id="finishNoGo">Finish Zone</button>
      <button id="undoNoGo">Undo Point</button>
      <button id="cancelNoGo">Cancel Zone</button>
    </div>

    <div class="saveRow">
      <button id="saveHole">Save Hole</button>
      <button id="clearHole">Clear Hole</button>
      <button id="downloadJson">Download Course JSON</button>
      <button id="loadLocal">Load Saved (Local)</button>
      <button id="saveLocal">Save (Local)</button>
    </div>
    <div id="status" class="status"></div>
  </div>

  <script>
    // --- Map & Tiles ---
    const map = L.map('map', { zoomControl:true, attributionControl:false }).setView([-25.746, 28.229], 17);
    L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 20 }
    ).addTo(map);

    // --- Icon Helpers ---
    function dotIcon(color='#ffffff', size=10){
      const r=Math.floor(size/2);
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'>
          <circle cx='${r}' cy='${r}' r='${r}' fill='${color}' />
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[r,r] });
    }

    // Emoji icons for taps/toilet that look exactly like the toolbar previews
    function emojiIcon(char='üöª', size=22){
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'>
          <text x='50%' y='50%' dominant-baseline='central' text-anchor='middle' font-size='${size*0.9}px'>${char}</text>
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[size/2,size/2] });
    }

    function flagMidIcon(size=30){
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 24 24'>
          <circle cx='12' cy='12' r='5' fill='#fbbf24'/>
          <rect x='11.5' y='3' width='1' height='10' fill='#374151'/>
          <path d='M12 4 L18 7 L12 10 Z' fill='#16a34a'/>
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[12,12] });
    }

    function teeIcon(size=18){
      const svg=encodeURIComponent(`<?xml version="1.0"?>
        <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 24 24'>
          <circle cx='12' cy='8' r='4' fill='#16a34a'/>
          <rect x='11' y='10' width='2' height='8' fill='#3b3b3b'/>
        </svg>`);
      return L.icon({ iconUrl:`data:image/svg+xml;utf8,${svg}`, iconSize:[size,size], iconAnchor:[12,12] });
    }

    const ICONS = {
      TEE: teeIcon(18),
      FRONT: dotIcon('#ffffff', 8),
      MID: flagMidIcon(34),        // larger for visibility when viewing entire hole
      BACK: dotIcon('#ef4444', 8),
      TOILET: emojiIcon('üöª', 22), // same style as toolbar
      TAPS: emojiIcon('üö∞', 22),   // same style as toolbar
      STAKE_WHITE: dotIcon('#ffffff', 6),
      STAKE_RED: dotIcon('#ef4444', 6),
      STAKE_YELLOW: dotIcon('#fbbf24', 6)
    };

    // --- State ---
    const $ = sel => document.querySelector(sel);
    const $$ = sel => document.querySelectorAll(sel);
    const status = msg => { $('#status').textContent = msg || ''; };

    const state = {
      course: {
        course: { id:'', name:'', pin:'' },
        holes: {} // "1": { par, stroke, pins:{} }
      },
      holeCount: 18,
      hole: 1,
      tool: 'MOVE',
      markers: [],
      drawingNoGo: false,
      currentNoGoPts: [],
      currentNoGoLayer: null,
    };

    // --- UI Init ---
    function fillHoleDropdown(n=18){
      const sel = $('#holeNo');
      sel.innerHTML = '';
      for(let i=1;i<=n;i++){
        const opt=document.createElement('option');
        opt.value=String(i); opt.textContent=String(i);
        sel.appendChild(opt);
      }
      sel.value = String(state.hole);
    }
    fillHoleDropdown(18);

    $('#holeCount').addEventListener('change', e=>{
      state.holeCount = parseInt(e.target.value,10);
      fillHoleDropdown(state.holeCount);
      status('Hole count updated');
    });

    $('#holeNo').addEventListener('change', e=>{
      saveHoleToState();
      state.hole = parseInt(e.target.value,10);
      loadHoleToUI();
    });

    // Tools activation
    $$('#tools .tool').forEach(t=>{
      t.addEventListener('click', ()=>{
        $$('#tools .tool').forEach(x=>x.classList.remove('active'));
        t.classList.add('active');
        setTool(t.dataset.tool);
      });
    });
    document.querySelector('[data-tool="MOVE"]').classList.add('active');

    function setTool(tool){
      // finalize/cancel any in-progress no-go
      if (state.drawingNoGo) cancelNoGo();
      state.tool = tool;
      if (tool==='NO_GO'){
        $('#nogobar').classList.add('show');
        map.dragging.disable();
        map.doubleClickZoom.disable();
        status('No-Go: click to add points; double-click or "Finish Zone" to complete.');
      } else {
        $('#nogobar').classList.remove('show');
        map.dragging.enable();
        map.doubleClickZoom.enable();
        status('');
      }
    }

    // --- Elevation helper ---
    async function fetchElevation(lat,lng){
      try{
        const r = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`);
        const j = await r.json();
        const e = j?.results?.[0]?.elevation;
        return Number.isFinite(e) ? e : null;
      }catch(_){ return null; }
    }

    // --- Map Clicks ---
    map.on('click', async (e)=>{
      const { lat, lng } = e.latlng;
      const tool = state.tool;

      if (tool==='NO_GO'){
        state.drawingNoGo = true;
        state.currentNoGoPts.push([lat,lng]);
        drawNoGoPreview();
        return;
      }

      if (tool==='MOVE' || tool==='ERASE') return;

      const ele = await fetchElevation(lat, lng);
      const base = { lat, lng };
      if (Number.isFinite(ele)) base.ele = ele;

      const pins = getHolePins();
      let m;

      if (tool==='TEE'){
        pins.TEE = base;
        m = addMarker(ICONS.TEE, base, 'TEE', true);
      } else if (tool==='FRONT'){
        pins.FRONT = base;
        m = addMarker(ICONS.FRONT, base, 'FRONT', true);
      } else if (tool==='MID'){
        pins.MID = base;
        m = addMarker(ICONS.MID, base, 'MID', true);
      } else if (tool==='BACK'){
        pins.BACK = base;
        m = addMarker(ICONS.BACK, base, 'BACK', true);
      } else if (tool==='TOILET'){
        pins.TOILET = base;
        m = addMarker(ICONS.TOILET, base, 'Toilet', true);
      } else if (tool==='TAPS'){
        pins.TAPS = pins.TAPS || [];
        pins.TAPS.push(base);
        m = addMarker(ICONS.TAPS, base, 'Tap', false, 'TAPS', pins.TAPS.length-1);
      } else if (tool==='STAKE_WHITE' || tool==='STAKE_RED' || tool==='STAKE_YELLOW'){
        const key = tool;
        pins[key] = pins[key] || [];
        pins[key].push(base);
        m = addMarker(ICONS[key], base, key.replace('STAKE_','Stake '), false, key, pins[key].length-1);
      }
      status(`${tool} placed at ${lat.toFixed(6)}, ${lng.toFixed(6)}${Number.isFinite(ele)?' ‚Ä¢ Elev '+ele+'m':''}`);
    });

    // Double-click to finish no-go
    map.on('dblclick', (e)=>{
      if (state.tool==='NO_GO' && state.drawingNoGo && state.currentNoGoPts.length>=3){
        finishNoGo();
      }
    });

    function drawNoGoPreview(){
      if (state.currentNoGoLayer) { map.removeLayer(state.currentNoGoLayer); }
      const pts = state.currentNoGoPts.map(([la,ln])=> L.latLng(la,ln));
      if (pts.length < 2){
        state.currentNoGoLayer = L.polyline(pts, { color:'#ef4444', weight:2, dashArray:'4,4' }).addTo(map);
      } else if (pts.length === 2){
        state.currentNoGoLayer = L.polyline(pts, { color:'#ef4444', weight:2, dashArray:'4,4' }).addTo(map);
      } else {
        state.currentNoGoLayer = L.polygon(pts, { color:'#ef4444', weight:2, fill:true, fillColor:'#ef4444', fillOpacity:0.22 }).addTo(map);
      }
    }

    function finishNoGo(){
      const pins = getHolePins();
      pins.NO_GO = pins.NO_GO || [];
      const poly = state.currentNoGoPts.map(([lat,lng])=>({lat,lng}));
      pins.NO_GO.push(poly);
      const layer = L.polygon(poly.map(p=>[p.lat,p.lng]), { color:'#ef4444', weight:2, fill:true, fillColor:'#ef4444', fillOpacity:0.22 });
      layer.addTo(map);
      if (state.currentNoGoLayer){ map.removeLayer(state.currentNoGoLayer); }
      state.currentNoGoLayer = null;
      state.currentNoGoPts = [];
      state.drawingNoGo = false;
      status('No-Go zone saved');
    }

    function undoNoGo(){
      if (!state.currentNoGoPts.length) return;
      state.currentNoGoPts.pop();
      drawNoGoPreview();
    }

    function cancelNoGo(){
      if (state.currentNoGoLayer){ map.removeLayer(state.currentNoGoLayer); }
      state.currentNoGoLayer = null;
      state.currentNoGoPts = [];
      state.drawingNoGo = false;
      status('No-Go zone cancelled');
    }

    $('#finishNoGo').addEventListener('click', ()=>{
      if (state.currentNoGoPts.length>=3) finishNoGo();
    });
    $('#undoNoGo').addEventListener('click', undoNoGo);
    $('#cancelNoGo').addEventListener('click', cancelNoGo);

    // --- Marker helpers ---
    function clearLiveMarkers(){
      state.markers.forEach(m => {
        try { map.removeLayer(m.layer); } catch{}
      });
      state.markers.length = 0;
      // Polygons are left; they get handled in loadHoleToUI
    }

    function addMarker(icon, pos, title, unique=false, listKey=null, listIndex=null){
      const marker = L.marker([pos.lat, pos.lng], { icon, draggable:true, title });
      marker.addTo(map);
      const rec = { layer: marker, listKey, listIndex, uniqueKey: unique ? title : null };
      state.markers.push(rec);

      marker.on('dragend', async () => {
        const ll = marker.getLatLng();
        const elev = await fetchElevation(ll.lat, ll.lng);
        const pins = getHolePins();
        const obj = { lat: ll.lat, lng: ll.lng };
        if (Number.isFinite(elev)) obj.ele = elev;

        if (rec.uniqueKey){
          pins[rec.uniqueKey] = obj;
        } else if (rec.listKey){
          pins[rec.listKey][rec.listIndex] = obj;
        }
        status(`${title} moved to ${ll.lat.toFixed(6)}, ${ll.lng.toFixed(6)}${Number.isFinite(elev)?' ‚Ä¢ Elev '+elev+'m':''}`);
      });

      marker.on('click', ()=>{
        if (state.tool!=='ERASE') return;
        // Remove from map + state
        map.removeLayer(marker);
        const pins = getHolePins();
        if (rec.uniqueKey){
          delete pins[rec.uniqueKey];
        } else if (rec.listKey){
          try { pins[rec.listKey].splice(rec.listIndex,1); } catch{}
        }
        // remove from local array
        state.markers = state.markers.filter(x => x.layer !== marker);
        status(`${title} removed`);
      });

      return marker;
    }

    function getHolePins(){
      const hKey = String(state.hole);
      state.course.holes[hKey] = state.course.holes[hKey] || { par:4, stroke:1, pins:{} };
      state.course.holes[hKey].par = parseInt($('#holePar').value,10) || 4;
      state.course.holes[hKey].stroke = parseInt($('#holeStroke').value,10) || 1;
      state.course.holes[hKey].pins = state.course.holes[hKey].pins || {};
      return state.course.holes[hKey].pins;
    }

    function saveHoleToState(){
      const hKey = String(state.hole);
      const h = state.course.holes[hKey] || { par:4, stroke:1, pins:{} };
      h.par = parseInt($('#holePar').value,10) || 4;
      h.stroke = parseInt($('#holeStroke').value,10) || 1;
      state.course.holes[hKey] = h;
      status(`Hole ${hKey} saved`);
    }

    function loadHoleToUI(){
      clearLiveMarkers();
      // remove polygons (keep baselayer)
      map.eachLayer(l => {
        if (l instanceof L.Polygon && !l._url) { try{ map.removeLayer(l); }catch{} }
      });

      const hKey = String(state.hole);
      const h = state.course.holes[hKey];
      $('#holePar').value = h?.par ?? 4;
      $('#holeStroke').value = h?.stroke ?? 1;
      const p = h?.pins || {};

      if (p.TEE)   addMarker(ICONS.TEE, p.TEE, 'TEE', true);
      if (p.FRONT) addMarker(ICONS.FRONT, p.FRONT, 'FRONT', true);
      if (p.MID)   addMarker(ICONS.MID, p.MID, 'MID', true);
      if (p.BACK)  addMarker(ICONS.BACK, p.BACK, 'BACK', true);
      if (p.TOILET) addMarker(ICONS.TOILET, p.TOILET, 'Toilet', true);
      (p.TAPS || []).forEach((obj, i)=> addMarker(ICONS.TAPS, obj, 'Tap', false, 'TAPS', i));
      (p.STAKE_WHITE || []).forEach((obj, i)=> addMarker(ICONS.STAKE_WHITE, obj, 'Stake White', false, 'STAKE_WHITE', i));
      (p.STAKE_RED || []).forEach((obj, i)=> addMarker(ICONS.STAKE_RED, obj, 'Stake Red', false, 'STAKE_RED', i));
      (p.STAKE_YELLOW || []).forEach((obj, i)=> addMarker(ICONS.STAKE_YELLOW, obj, 'Stake Yellow', false, 'STAKE_YELLOW', i));

      // Recreate saved no-go zones
      (p.NO_GO || []).forEach(poly => {
        const latlngs = poly.map(pt => L.latLng(pt.lat, pt.lng));
        L.polygon(latlngs, { color:'#ef4444', weight:2, fill:true, fillColor:'#ef4444', fillOpacity:0.22 }).addTo(map);
      });
    }

    // --- Save / Load Course ---
    function collectCourse(){
      state.course.course.id = ($('#courseId').value || '').trim();
      state.course.course.name = ($('#courseName').value || '').trim();
      state.course.course.pin = ($('#coursePin').value || '').trim().toUpperCase();
      return state.course;
    }

    $('#saveHole').addEventListener('click', ()=>{
      saveHoleToState();
    });

    $('#clearHole').addEventListener('click', ()=>{
      if (!confirm('Clear all pins for this hole?')) return;
      const hKey=String(state.hole);
      state.course.holes[hKey] = { par:4, stroke:1, pins:{} };
      loadHoleToUI();
      status(`Hole ${hKey} cleared`);
    });

    $('#downloadJson').addEventListener('click', ()=>{
      saveHoleToState();
      const obj = collectCourse();
      if (!obj.course.id){ alert('Please enter a Course ID (file name)'); return; }
      const blob = new Blob([JSON.stringify(obj,null,2)], { type:'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${obj.course.id}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
      status('Course JSON downloaded');
    });

    const LOCAL_KEY = 'tl_mapper_draft';
    $('#saveLocal').addEventListener('click', ()=>{
      saveHoleToState();
      collectCourse();
      localStorage.setItem(LOCAL_KEY, JSON.stringify(state.course));
      status('Saved to local storage');
    });
    $('#loadLocal').addEventListener('click', ()=>{
      try{
        const raw = localStorage.getItem(LOCAL_KEY);
        if (!raw) return alert('No local save found');
        const obj = JSON.parse(raw);
        state.course = obj;
        $('#courseId').value = obj.course?.id || '';
        $('#courseName').value = obj.course?.name || '';
        $('#coursePin').value = obj.course?.pin || '';
        const most = Math.max(...Object.keys(obj.holes||{}).map(k=>+k).filter(n=>Number.isFinite(n)));
        const inferredCount = Number.isFinite(most) ? Math.max(most, 18) : 18;
        $('#holeCount').value = String(inferredCount);
        state.holeCount = inferredCount;
        fillHoleDropdown(inferredCount);
        state.hole = 1;
        $('#holeNo').value = '1';
        loadHoleToUI();
        status('Local save loaded');
      }catch(e){
        alert('Failed to load local save');
      }
    });

    // Fit map to current hole markers on first ready (if any)
    map.whenReady(()=> setTimeout(()=>{
      const h = state.course.holes[String(state.hole)];
      if (h && h.pins){
        const list = [];
        ['TEE','FRONT','MID','BACK','TOILET'].forEach(k=>{ if(h.pins[k]) list.push([h.pins[k].lat,h.pins[k].lng]); });
        (h.pins.TAPS||[]).forEach(t=> list.push([t.lat,t.lng]));
        if (list.length){ map.fitBounds(L.latLngBounds(list), { padding:[40,40] }); }
      }
    }, 300));
  </script>
</body>
</html>
