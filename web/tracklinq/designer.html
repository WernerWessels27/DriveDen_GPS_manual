<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Designer • Vector Course Builder</title>
  <style>
    :root{
      --bg:#e8f5e9; /* neutral green background */
      --panel:#ffffff;
      --line:#1f2937;
      --accent:#0ea5e9;
      --muted:#6b7280;
      --danger:#ef4444;
      --ok:#16a34a;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .layout{display:grid;grid-template-columns:340px 1fr;grid-template-rows:auto 1fr; height:100%}
    header{grid-column:1/3;display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid #e5e7eb;background:#fff}
    header h1{font-size:18px;margin:0;font-weight:700}
    header .spacer{flex:1}
    #left{border-right:1px solid #e5e7eb;overflow:auto;background:#fafafa}
    .section{padding:12px;border-bottom:1px solid #eee}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    label{display:block;font-size:12px;color:#374151;margin:6px 0 2px}
    input[type=text],input[type=number]{width:100%;box-sizing:border-box;padding:8px;border:1px solid #d1d5db;border-radius:8px;background:#fff}
    select{width:100%;padding:8px;border:1px solid #d1d5db;border-radius:8px;background:#fff}
    .btn{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border-radius:8px;border:1px solid #d1d5db;background:#fff;cursor:pointer}
    .btn.primary{background:#111827;color:#fff;border-color:#111827}
    .btn.ghost{background:#fff}
    .btn.warn{background:#fff7ed;color:#9a3412;border-color:#fdba74}
    .btn.danger{background:#fee2e2;color:#991b1b;border-color:#fecaca}
    .toolbar{display:flex;flex-wrap:wrap;gap:6px}
    .swatch{width:22px;height:22px;border-radius:6px;border:1px solid #d1d5db;cursor:pointer}
    .legend{font-size:12px;color:#6b7280}
    canvas{display:block;background:var(--bg)}
    .top-right{position:absolute;top:10px;right:10px;display:flex;gap:6px;z-index:10}
    .toast{position:absolute;left:50%;top:12px;transform:translateX(-50%);background:#111827;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px;opacity:.92}
  </style>
</head>
<body>
  <div class="layout">
    <header>
      <h1>Vector Course Designer</h1>
      <span class="legend">v1.0</span>
      <div class="spacer"></div>
      <button class="btn" id="btn-import">Import JSON</button>
      <button class="btn primary" id="btn-export-json">Export JSON</button>
      <button class="btn" id="btn-export-png">Export PNG + world.json</button>
    </header>

    <aside id="left">
      <div class="section">
        <div class="row">
          <div>
            <label>Club Name</label>
            <input id="clubName" type="text" placeholder="e.g. Silver Lakes"/>
          </div>
          <div>
            <label>Club ID</label>
            <input id="clubId" type="text" placeholder="SLK"/>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Club PIN (10)</label>
            <input id="clubPin" maxlength="10" type="text" placeholder="SLK1234567"/>
          </div>
          <div>
            <label>Status</label>
            <select id="clubActive"><option value="true">Active</option><option value="false">Not Active</option></select>
          </div>
        </div>
      </div>

      <div class="section">
        <label>Bounds (South, West, North, East)</label>
        <div class="row">
          <input id="bSouth" type="number" step="0.000001" placeholder="south"/>
          <input id="bWest" type="number" step="0.000001" placeholder="west"/>
        </div>
        <div class="row">
          <input id="bNorth" type="number" step="0.000001" placeholder="north"/>
          <input id="bEast" type="number" step="0.000001" placeholder="east"/>
        </div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button class="btn" id="btn-apply-bounds">Apply</button>
          <button class="btn" id="btn-fit-to-data">Fit to Data</button>
        </div>
        <p class="legend">Tip: Set bounds to your hole’s rectangle. We use these to convert lat/lng ↔︎ pixels.</p>
      </div>

      <div class="section">
        <label>Reference image (optional, for tracing)</label>
        <div style="display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn" id="btn-load-ref">Load PNG/JPG</button>
          <button class="btn" id="btn-clear-ref">Clear</button>
          <button class="btn" id="btn-ref-opacity">Ref Opacity 50%</button>
        </div>
        <p class="legend">This image is not exported; it’s just a faint layer to trace over. Make sure its bounds match the numbers above.</p>
      </div>

      <div class="section">
        <label>Tool</label>
        <div class="toolbar" id="toolBar"></div>
        <p class="legend">Click to draw. <b>Enter</b> to finish polygon/polyline, <b>Esc</b> to cancel, <b>Drag</b> vertices to adjust, <b>Del</b> to delete selected.</p>
      </div>

      <div class="section">
        <label>Style</label>
        <div class="row">
          <div>
            <label>Fill</label>
            <input id="fill" type="text" value="#6fbf73"/>
          </div>
          <div>
            <label>Stroke</label>
            <input id="stroke" type="text" value="#245a2c"/>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Stroke px</label>
            <input id="strokeW" type="number" value="2"/>
          </div>
          <div>
            <label>Fairway stripes</label>
            <select id="stripe"><option value="no">No</option><option value="yes">Yes</option></select>
          </div>
        </div>
      </div>

      <div class="section">
        <label>Hole meta</label>
        <div class="row">
          <div>
            <label>Hole #</label>
            <input id="holeNum" type="number" min="1" max="18" value="1"/>
          </div>
          <div>
            <label>Par</label>
            <input id="holePar" type="number" min="3" max="6" value="4"/>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Stroke</label>
            <input id="holeStroke" type="number" min="1" max="18" value="7"/>
          </div>
          <div style="display:flex;align-items:end;gap:6px">
            <button class="btn" id="btn-apply-hole">Apply</button>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Tee elev (m)</label>
            <input id="elevTee" type="number" step="0.1"/>
          </div>
          <div>
            <label>Front elev (m)</label>
            <input id="elevFront" type="number" step="0.1"/>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Mid elev (m)</label>
            <input id="elevMid" type="number" step="0.1"/>
          </div>
          <div>
            <label>Back elev (m)</label>
            <input id="elevBack" type="number" step="0.1"/>
          </div>
        </div>
      </div>

      <div class="section">
        <label>Keyboard</label>
        <p class="legend">1–9 switch tools • <b>Enter</b> finish shape • <b>Esc</b> cancel • <b>Del</b> delete selection • <b>Z</b>/<b>Y</b> undo/redo</p>
      </div>
    </aside>

    <main style="position:relative">
      <div class="top-right">
        <button class="btn" id="btn-zoom-out">-</button>
        <button class="btn" id="btn-zoom-in">+</button>
        <button class="btn" id="btn-fit-bbox">Fit CART↔BACK</button>
      </div>
      <div id="toast" class="toast" style="display:none"></div>
      <canvas id="cv"></canvas>
    </main>
  </div>

  <script>
    // =============== Projection helpers (bounds-linear for course scale) ===============
    const state = {
      meta:{name:"",id:"",pin:"",active:true},
      bounds:{south:-25.705, west:28.195, north:-25.695, east:28.205},
      zoom:1, panX:0, panY:0,
      canvas:null, ctx:null, refImage:null, refOpacity:0.4,
      holes: Array.from({length:18}, (_,i)=>({number:i+1, par:4, stroke:i+1, pins:{tee:null, front:null, mid:null, back:null}})),
      features:{polygons:[], polylines:[], points:[]},
      tool:"tee", drawing:[], drawingType:null, selected=null,
      undo:[], redo:[]
    };

    const Tools = [
      {id:"tee", label:"Tee (Pt)", kind:"point", color:"#0ea5e9"},
      {id:"front", label:"Front (Pt)", kind:"point", color:"#22c55e"},
      {id:"mid", label:"Mid (Pt)", kind:"point", color:"#10b981"},
      {id:"back", label:"Back (Pt)", kind:"point", color:"#059669"},
      {id:"toilet", label:"Toilet (Pt)", kind:"point", color:"#8b5cf6"},
      {id:"fairway", label:"Fairway (Poly)", kind:"polygon", style:{fill:"#6fbf73", stroke:"#245a2c", width:2, stripe:true}},
      {id:"green", label:"Green (Poly)", kind:"polygon", style:{fill:"#66a85e", stroke:"#1f7a3d", width:2}},
      {id:"bunker", label:"Bunker (Poly)", kind:"polygon", style:{fill:"#e8d7a6", stroke:"#b59b60", width:2}},
      {id:"rough", label:"Rough (Poly)", kind:"polygon", style:{fill:"#93c590", stroke:"#4d7c4a", width:2}},
      {id:"water", label:"Water (Poly)", kind:"polygon", style:{fill:"#6aa9e9", stroke:"#306aa8", width:2}},
      {id:"bush", label:"Bush (Pt)", kind:"point", color:"#3f6212"},
      {id:"tree", label:"Tree (Pt)", kind:"point", color:"#14532d"},
      {id:"rocks", label:"Rocks (Poly)", kind:"polygon", style:{fill:"#b0b4b8", stroke:"#6b7280", width:2}}
    ];

    function lngToX(lng){const {west,east}=state.bounds;return (lng-west)/(east-west)*state.canvas.width}
    function latToY(lat){const {south,north}=state.bounds;return (north-lat)/(north-south)*state.canvas.height}
    function xToLng(x){const {west,east}=state.bounds;return west + (x/state.canvas.width)*(east-west)}
    function yToLat(y){const {south,north}=state.bounds;return north - (y/state.canvas.height)*(north-south)}

    function worldToScreen([lat,lng]){let x=lngToX(lng), y=latToY(lat); x= (x+state.panX)*state.zoom; y=(y+state.panY)*state.zoom; return [x,y]}
    function screenToWorld(x,y){x/=state.zoom; y/=state.zoom; x-=state.panX; y-=state.panY; return [yToLat(y), xToLng(x)]}

    // =============== UI init ===============
    const el=id=>document.getElementById(id);
    const cv=state.canvas=el('cv');
    const ctx=state.ctx=cv.getContext('2d');
    function sizeCanvas(){cv.width = cv.clientWidth || window.innerWidth-340; cv.height = cv.clientHeight || (window.innerHeight-50); render();}
    window.addEventListener('resize', sizeCanvas);

    // Build toolbar
    const tb=el('toolBar');
    Tools.forEach((t,i)=>{
      const b=document.createElement('button');
      b.className='btn'; b.textContent=`${i+1}. ${t.label}`; b.style.borderColor="#d1d5db"; b.onclick=()=>{state.tool=t.id; toast(t.label)}; tb.appendChild(b);
    });

    // Style inputs
    el('fill').addEventListener('change',()=>{});

    // Bounds inputs
    ['bSouth','bWest','bNorth','bEast'].forEach(id=> el(id).value = state.bounds[id.slice(1).toLowerCase()]);
    el('btn-apply-bounds').onclick=()=>{state.bounds.south=parseFloat(el('bSouth').value);state.bounds.west=parseFloat(el('bWest').value);state.bounds.north=parseFloat(el('bNorth').value);state.bounds.east=parseFloat(el('bEast').value);render();};

    // Zoom controls
    el('btn-zoom-in').onclick=()=>{state.zoom*=1.2; render();};
    el('btn-zoom-out').onclick=()=>{state.zoom/=1.2; render();};

    // Fit CART↔BACK placeholder (will use current hole pins if exist)
    el('btn-fit-bbox').onclick=()=>{
      const h = state.holes[(+el('holeNum').value||1)-1];
      const a=h?.pins?.tee, b=h?.pins?.back; if(!a||!b) return toast('Set Tee and Back first');
      fitTwoPoints(a,b);
    };

    function fitTwoPoints(A,B){
      // Compute required zoom so both points fit with padding
      const [ax,ay]=[lngToX(A.lng), latToY(A.lat)];
      const [bx,by]=[lngToX(B.lng), latToY(B.lat)];
      const pad=80; const w=cv.width-2*pad, h=cv.height-2*pad;
      const dx=Math.abs(ax-bx), dy=Math.abs(ay-by);
      const zx=w/dx, zy=h/dy; const z=Math.max(1, Math.min(zx,zy));
      state.zoom = z;
      const cx=(ax+bx)/2, cy=(ay+by)/2; // center in world pixels
      state.panX = (cv.width/2)/z - cx;
      state.panY = (cv.height/2)/z - cy;
      render();
    }

    // Hole meta
    el('btn-apply-hole').onclick=()=>{
      const idx=(+el('holeNum').value)-1; const h=state.holes[idx]; if(!h) return;
      h.par=+el('holePar').value||h.par; h.stroke=+el('holeStroke').value||h.stroke;
      h.pins.tee && (h.pins.tee.elev_m = numOrNull(el('elevTee').value));
      h.pins.front && (h.pins.front.elev_m = numOrNull(el('elevFront').value));
      h.pins.mid && (h.pins.mid.elev_m = numOrNull(el('elevMid').value));
      h.pins.back && (h.pins.back.elev_m = numOrNull(el('elevBack').value));
      toast('Hole updated'); render();
    }
    function numOrNull(v){const n=parseFloat(v); return Number.isFinite(n)?n:null}

    // Meta sync
    ['clubName','clubId','clubPin','clubActive'].forEach(id=> el(id).addEventListener('change',()=>{
      state.meta.name=el('clubName').value.trim(); state.meta.id=el('clubId').value.trim(); state.meta.pin=el('clubPin').value.trim().toUpperCase(); state.meta.active=(el('clubActive').value==='true');
    }));

    // Reference image
    el('btn-load-ref').onclick=async()=>{
      const inp=document.createElement('input'); inp.type='file'; inp.accept='image/*';
      inp.onchange=()=>{const f=inp.files?.[0]; if(!f) return; const img=new Image(); img.onload=()=>{state.refImage=img; render();}; img.src=URL.createObjectURL(f)}; inp.click();
    };
    el('btn-clear-ref').onclick=()=>{state.refImage=null; render();}
    el('btn-ref-opacity').onclick=()=>{state.refOpacity = state.refOpacity===0.4?0.7:0.4; render();}

    // Import/Export
    el('btn-export-json').onclick=()=>{
      const data = exportJSON(); const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`${(state.meta.id||'course')}.vector.json`; a.click(); URL.revokeObjectURL(a.href);
    };
    el('btn-export-png').onclick=()=>{ exportPNG(); };
    el('btn-import').onclick=()=>{
      const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json,.json';
      inp.onchange=async()=>{const f=inp.files?.[0]; if(!f) return; const txt=await f.text(); try{const obj=JSON.parse(txt); importJSON(obj); toast('Imported');}catch(e){alert('Invalid JSON')};}; inp.click();
    };

    function exportJSON(){
      return {
        meta: state.meta,
        bounds: state.bounds,
        holes: state.holes,
        features: state.features
      };
    }
    function importJSON(obj){
      state.meta = obj.meta||state.meta; state.bounds=obj.bounds||state.bounds; state.holes=obj.holes||state.holes; state.features=obj.features||state.features;
      ['bSouth','bWest','bNorth','bEast'].forEach(id=> el(id).value = state.bounds[id.slice(1).toLowerCase()]);
      render();
    }

    function exportPNG(){
      // Render at current size to a PNG and emit a sidecar world.json with bounds
      const png=cv.toDataURL('image/png');
      const a=document.createElement('a'); a.href=png; a.download=`${(state.meta.id||'course')}.png`; a.click();
      const world={bounds:state.bounds, width:cv.width, height:cv.height};
      const blob=new Blob([JSON.stringify(world,null,2)],{type:'application/json'});
      const a2=document.createElement('a'); a2.href=URL.createObjectURL(blob); a2.download=`${(state.meta.id||'course')}.world.json`; a2.click(); URL.revokeObjectURL(a2.href);
    }

    // =============== Drawing / Editing ===============
    cv.addEventListener('mousedown', onDown);
    cv.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    window.addEventListener('keydown', onKey);

    let drag = {mode:null, feat:null, vi:-1, start:null};

    function onDown(e){
      const [lat,lng] = screenToWorld(e.offsetX, e.offsetY);
      const tool = Tools.find(t=>t.id===state.tool);
      if(!tool) return;

      if(tool.kind==='point'){
        const pt={type:state.tool, coords:{lat,lng}};
        state.features.points.push(pt);
        // sync pins if tee/front/mid/back
        const h=state.holes[(+el('holeNum').value)-1];
        if(['tee','front','mid','back'].includes(state.tool)){
          h.pins[state.tool] = {lat,lng, elev_m: numOrNull(el('elev'+capitalize(state.tool)).value)};
        }
        snapshot(); render(); return;
      }

      // For polygon/polyline, start or continue drawing
      if(!state.drawing.length){ state.drawing=[{lat,lng}]; state.drawingType=tool.kind; }
      else { state.drawing.push({lat,lng}); }
      render();
    }

    function onMove(e){
      if(state.drawing.length){ render(e); return; }
      if(drag.mode==='vertex' && drag.feat){
        const [lat,lng]=screenToWorld(e.offsetX,e.offsetY);
        drag.feat.coords[drag.vi] = {lat,lng}; render(); return;
      }
    }
    function onUp(e){ drag.mode=null; }

    function onKey(e){
      if(e.key==='Enter' && state.drawing.length){
        const tool=Tools.find(t=>t.id===state.tool);
        if(!tool) return;
        if(state.drawingType==='polygon'){
          state.features.polygons.push({type:state.tool, hole:+el('holeNum').value, style:currentStyle(tool), coords:[...state.drawing]});
        }else{ // polyline not used yet
          state.features.polylines.push({type:state.tool, style:currentStyle(tool), coords:[...state.drawing]});
        }
        state.drawing=[]; snapshot(); render();
      }
      if(e.key==='Escape'){ state.drawing=[]; render(); }
      if(e.key==='Delete' && state.selected){
        const {kind,index}=state.selected; if(kind==='poly'){ state.features.polygons.splice(index,1);} else if(kind==='pt'){ state.features.points.splice(index,1);} state.selected=null; snapshot(); render();
      }
      if((e.key==='z'||e.key==='Z') && (e.ctrlKey||e.metaKey)) undo();
      if((e.key==='y'||e.key==='Y') && (e.ctrlKey||e.metaKey)) redo();
      // number keys to switch tools
      const n=parseInt(e.key,10); if(Number.isFinite(n) && n>=1 && n<=Tools.length){ state.tool=Tools[n-1].id; toast(Tools[n-1].label); }
    }
    function currentStyle(tool){
      // merge panel style with default for fairway stripes
      const fill=el('fill').value|| (tool.style?.fill||'#6fbf73');
      const stroke=el('stroke').value|| (tool.style?.stroke||'#245a2c');
      const width=+el('strokeW').value || (tool.style?.width||2);
      const stripe=(el('stripe').value==='yes')
      return {fill, stroke, width, stripe};
    }

    function capitalize(s){return s.charAt(0).toUpperCase()+s.slice(1)}

    function snapshot(){ state.undo.push(JSON.stringify(exportJSON())); state.redo.length=0; }
    function undo(){ if(state.undo.length<2) return; const cur=state.undo.pop(); state.redo.push(cur); importJSON(JSON.parse(state.undo[state.undo.length-1])); }
    function redo(){ if(!state.redo.length) return; const nxt=state.redo.pop(); state.undo.push(nxt); importJSON(JSON.parse(nxt)); }

    // =============== Rendering ===============
    function render(e){
      // resize canvas to fill space
      const mainW = window.innerWidth-340; const mainH = window.innerHeight-50;
      if(cv.width!==mainW || cv.height!==mainH){ cv.width=mainW; cv.height=mainH; }
      ctx.clearRect(0,0,cv.width,cv.height);

      // reference image
      if(state.refImage){ ctx.globalAlpha=state.refOpacity; ctx.drawImage(state.refImage, 0,0, cv.width, cv.height); ctx.globalAlpha=1; }

      // polygons
      state.features.polygons.forEach((p,pi)=>{
        drawPolygon(p, pi);
      });

      // points
      state.features.points.forEach((p,pi)=>{ drawPoint(p,pi); });

      // drawing preview
      if(state.drawing.length){ drawPreview(e); }

      // border
      ctx.strokeStyle="#94a3b8"; ctx.lineWidth=1; ctx.strokeRect(0,0,cv.width,cv.height);
    }

    function drawPolygon(p, index){
      const pts=p.coords.map(c=>worldToScreen([c.lat,c.lng]));
      if(pts.length<2) return;
      ctx.beginPath(); ctx.moveTo(pts[0][0], pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath();
      ctx.fillStyle=p.style?.fill||'#6fbf73'; ctx.strokeStyle=p.style?.stroke||'#245a2c'; ctx.lineWidth=p.style?.width||2;
      ctx.fill(); ctx.stroke();
      // fairway stripes
      if(p.type==='fairway' && (p.style?.stripe)){
        ctx.save(); ctx.clip();
        const step=22; for(let i=-cv.height;i<cv.height*2;i+=step){ ctx.beginPath(); ctx.rect(-cv.width,i,cv.width*3, step/2); ctx.fillStyle=hexShift(p.style.fill||'#6fbf73', -10); ctx.fill(); }
        ctx.restore();
      }
    }

    function hexShift(hex, delta){
      try{ let c=parseInt(hex.replace('#',''),16); let r=(c>>16)&255,g=(c>>8)&255,b=c&255; const adj=v=>Math.max(0,Math.min(255,v+delta)); r=adj(r); g=adj(g); b=adj(b); return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);}catch(e){return hex}
    }

    function drawPoint(p, index){
      const [x,y]=worldToScreen([p.coords.lat,p.coords.lng]);
      ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fillStyle=pointColor(p.type); ctx.fill(); ctx.strokeStyle="#1f2937"; ctx.lineWidth=1; ctx.stroke();
    }
    function pointColor(type){
      const t=Tools.find(t=>t.id===type); return t?.color||'#111827';
    }

    function drawPreview(e){
      const tool=Tools.find(t=>t.id===state.tool); if(!tool) return; const pts=[...state.drawing];
      if(e){ const [lat,lng]=screenToWorld(e.offsetX,e.offsetY); pts.push({lat,lng}); }
      const scr=pts.map(c=>worldToScreen([c.lat,c.lng]));
      ctx.beginPath(); ctx.moveTo(scr[0][0], scr[0][1]); for(let i=1;i<scr.length;i++) ctx.lineTo(scr[i][0], scr[i][1]);
      if(tool.kind==='polygon') ctx.closePath();
      const st=currentStyle(tool); ctx.fillStyle=st.fill; ctx.strokeStyle=st.stroke; ctx.lineWidth=st.width; if(tool.kind==='polygon') ctx.fill(); ctx.stroke();
      // vertices
      scr.forEach(([x,y])=>{ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fillStyle='#111827'; ctx.fill();});
    }

    function toast(t){ const d=el('toast'); d.textContent=t; d.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>d.style.display='none', 1200); }

    // boot
    sizeCanvas(); snapshot(); render();
  </script>
</body>
</html>
