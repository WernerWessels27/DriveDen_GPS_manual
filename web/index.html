<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DriveDen GPS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#06b6d4" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; position: relative; }

    /* Logo only */
    .brand {
      position: fixed; top: 10px; left: 10px; z-index: 10000;
      background: rgba(255,255,255,.9); padding: 6px 10px; border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0,0,0,.15);
      display:flex; align-items:center; gap:8px;
    }
    .brand img { height: 34px; }

    /* Hole nav (top center) */
    .holeNav {
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10000;
      background: rgba(255,255,255,.95); padding: 6px 10px; border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0,0,0,.15);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      display:flex; align-items:center; gap:10px; min-width: 180px; justify-content: center;
    }
    .holeNav button { border:0; background:#06b6d4; color:#fff; border-radius:8px; padding:4px 10px; font-size:16px; cursor:pointer; }
    .holeTitle { font-weight:600; }

    /* WIND (top-right) */
    .windBox{
      position: fixed; top: 10px; right: 10px; z-index: 10000;
      background: rgba(255,255,255,.95); padding: 8px 10px; border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0,0,0,.15);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      display:flex; flex-direction:column; gap:8px; min-width: 160px;
    }
    .windRow { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .windLeft { display:flex; align-items:center; gap:8px; }
    .windSock { width:26px; height:26px; }
    .windData { display:flex; flex-direction:column; line-height:1.1; }
    .windSpeed { font-weight:600; }
    .windDirTxt { font-size:12px; opacity:.8; }
    .windArrow { width:20px; height:20px; transform-origin:50% 50%; opacity:.85; }

    /* toggles under wind */
    .toggles { display:flex; gap:8px; flex-wrap:wrap; }
    .toggle {
      background:#f3f4f6; border:1px solid #e5e7eb; color:#111827;
      padding:6px 10px; border-radius:999px; font-size:12px; cursor:pointer;
      user-select:none;
    }
    .toggle.active { background:#06b6d4; color:#fff; border-color:#06b6d4; }

    /* Distances (left) */
    .distBox {
      position: fixed; top: 60px; left: 10px; z-index: 10000;
      background: rgba(255,255,255,.95); padding: 10px 12px; border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0,0,0,.15);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; width: 180px;
    }
    .row { display:flex; justify-content:space-between; margin: 4px 0; font-size:14px; gap:6px; }
    .col { display:flex; flex-direction:column; align-items:flex-end; }
    .label { opacity:.75; }
    .value { font-weight:600; }
    .delta { font-size:12px; opacity:.8; }
    .muted { font-size: 12px; opacity: .7; margin-top: 4px; }

    /* Bottom info bar */
    .footer {
      position: fixed; left: 10px; right: 10px; bottom: 10px; z-index: 10000;
      background: rgba(255,255,255,.95); padding: 8px 12px; border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0,0,0,.15);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      display:flex; justify-content:center; gap:18px; font-size:14px;
    }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-weight:600; }

    /* Right-side control panel */
    .panel { position: fixed; top: 80px; right: 10px; z-index: 10000; background: rgba(255,255,255,.97); padding: 10px 12px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); width: 330px; max-width: calc(100% - 20px); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; max-height: 75vh; overflow: auto; transition: transform .25s ease, opacity .2s ease; }
    .panel.hidden { transform: translateY(16px); opacity:0; pointer-events:none; }
    .grid { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
    select, button, input { width: 100%; padding: 8px; font-size: 14px; }

    /* Floating buttons */
    .fab { position: fixed; right: 12px; bottom: 12px; z-index: 10001; width: 52px; height: 52px; border-radius: 50%; border: 0; font-size: 22px; background: #06b6d4; color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,.2); cursor: pointer; }
    .fab-left { position: fixed; left: 12px; bottom: 12px; z-index: 10001; width: 52px; height: 52px; border-radius: 50%; border: 0; font-size: 22px; background: #111827; color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,.2); cursor: pointer; display: none; }

    /* Measure label bubble */
    .measure-bubble {
      background: rgba(17,24,39,.95);
      color: #fff;
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 6px 12px rgba(0,0,0,.25);
      user-select: none;
    }
    .measure-close {
      background: rgba(255,255,255,.15);
      border-radius: 6px;
      padding: 0 6px;
      cursor: pointer;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <!-- logo -->
  <div class="brand"><img src="driveden-logo.svg" alt="DriveDen"></div>

  <!-- hole nav -->
  <div class="holeNav">
    <button id="prevHole">â—€</button>
    <div class="holeTitle" id="holeTitle">Hole â€“</div>
    <button id="nextHole">â–¶</button>
  </div>

  <!-- WIND + toggles -->
  <div class="windBox" id="windBox" title="10 m wind at 10 m height">
    <div class="windRow">
      <div class="windLeft">
        <!-- windsock icon -->
        <svg class="windSock" viewBox="0 0 64 64" aria-hidden="true">
          <rect x="8" y="8" width="6" height="48" rx="3" fill="#1f2937"></rect>
          <polygon points="14,14 54,20 54,28 14,34" fill="#e11d48"></polygon>
          <line x1="14" y1="14" x2="14" y2="34" stroke="#111827" stroke-width="2"></line>
          <line x1="24" y1="16" x2="24" y2="32" stroke="#fff" stroke-width="3" opacity="0.7"></line>
          <line x1="36" y1="18" x2="36" y2="30" stroke="#fff" stroke-width="3" opacity="0.7"></line>
        </svg>
        <div class="windData">
          <div class="windSpeed" id="windSpeed">â€“ m/s</div>
          <div class="windDirTxt" id="windDirTxt">â€“</div>
        </div>
      </div>
      <!-- direction arrow (shows where wind COMES FROM) -->
      <svg class="windArrow" id="windArrow" viewBox="0 0 24 24" aria-hidden="true">
        <polygon points="12,3 6,12 10,12 10,21 14,21 14,12 18,12" fill="#111827"></polygon>
      </svg>
    </div>
    <div class="toggles">
      <span id="tgBase" class="toggle">Map: Imagery</span>
      <span id="tgContours" class="toggle">Contours: Off</span>
    </div>
  </div>

  <!-- distances -->
  <div class="distBox">
    <div class="row">
      <span class="label">Front</span>
      <span class="col"><span class="value" id="dFront">â€“</span><span class="delta" id="eFront">â€“</span></span>
    </div>
    <div class="row">
      <span class="label">Mid</span>
      <span class="col"><span class="value" id="dMid">â€“</span><span class="delta" id="eMid">â€“</span></span>
    </div>
    <div class="row">
      <span class="label">Back</span>
      <span class="col"><span class="value" id="dBack">â€“</span><span class="delta" id="eBack">â€“</span></span>
    </div>
    <div class="muted" id="status">Getting GPSâ€¦</div>
  </div>

  <!-- bottom bar -->
  <div class="footer">
    <div>Par <span class="badge" id="par">â€“</span></div>
    <div>Stroke <span class="badge" id="stroke">â€“</span></div>
  </div>

  <!-- map -->
  <div id="map"></div>

  <!-- control panel -->
  <div class="panel hidden" id="panel">
    <div><strong>Select course</strong></div>
    <div class="grid" style="margin-top:6px;">
      <select id="courseSelect"></select>
      <button id="btnLoadCourse">Load</button>
    </div>
    <div class="muted">Open with <code>?course=&lt;id&gt;</code> as well.</div>
    <div style="margin-top:10px;"><strong>Hole</strong></div>
    <div class="grid" style="margin-top:6px;">
      <select id="holes"></select><button id="btnGoHole">Go</button>
    </div>
  </div>

  <!-- toggles -->
  <button id="panelToggle" class="fab">â˜°</button>
  <button id="recenterBtn" class="fab-left">ðŸŽ¯</button>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>
  <script>
    // ------- Base layers & overlays -------
    // Esri World Imagery (great aerial detail)
    const esriImagery = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: '&copy; Esri, Maxar, Earthstar Geographics, and the GIS User Community' }
    );
    // CARTO Voyager (clean labels/roads)
    const cartoVoyager = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
      { maxZoom: 19, attribution: '&copy; OpenStreetMap &copy; CARTO' }
    );
    // OpenTopoMap contours overlay (we keep opacity low)
    const contours = L.tileLayer(
      'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
      { maxZoom: 17, opacity: 0.35, attribution: 'Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap (CC-BY-SA)' }
    );

    // Map & default layers
    const map = L.map('map', { zoomControl: true, layers: [esriImagery] });
    let currentBase = 'imagery'; // 'imagery' or 'voyager'
    let contoursOn = false;

    // ------- Existing UI/state -------
    const cartSvg = encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="40" height="32" viewBox="0 0 40 32"><rect x="5" y="10" width="24" height="10" rx="2" ry="2" fill="#1f2937"/><polygon points="5,10 15,4 29,4 29,10" fill="#0ea5b7"/><circle cx="13" cy="24" r="4" fill="#111827"/><circle cx="13" cy="24" r="2" fill="#e5e7eb"/><circle cx="27" cy="24" r="4" fill="#111827"/><circle cx="27" cy="24" r="2" fill="#e5e7eb"/><rect x="30" y="12" width="6" height="2" rx="1" fill="#111827"/><circle cx="34" cy="16" r="2" fill="#14b8a6"/></svg>`);
    const cartIcon = L.icon({ iconUrl: `data:image/svg+xml;utf8,${cartSvg}`, iconSize: [28,22], iconAnchor: [14,11] });
    const you = L.marker([0,0], { icon: cartIcon }).addTo(map);

    let lastPos = null, follow = true, movedOnce = false;
    let holes = []; let currentIndex = 0; let courseList = [];
    const markers = {}; // front/mid/back

    // Measure tool
    let measureTarget = null; // {lat,lng}
    let measureMarker = null, measureLine = null;

    // UI refs
    const status = document.getElementById('status');
    const dFront = document.getElementById('dFront'), dMid = document.getElementById('dMid'), dBack = document.getElementById('dBack');
    const eFront = document.getElementById('eFront'), eMid = document.getElementById('eMid'), eBack = document.getElementById('eBack');
    const parEl = document.getElementById('par'), strokeEl = document.getElementById('stroke');
    const holeTitle = document.getElementById('holeTitle');
    const recenterBtn = document.getElementById('recenterBtn');
    const panel = document.getElementById('panel'), toggleBtn = document.getElementById('panelToggle');
    const courseSel = document.getElementById('courseSelect'), holesSel = document.getElementById('holes');

    // Wind widget
    const windSpeedEl = document.getElementById('windSpeed');
    const windDirTxtEl = document.getElementById('windDirTxt');
    const windArrowEl = document.getElementById('windArrow');
    let windCache = { ts: 0, lat: null, lng: null, speed: null, dir: null };
    const WIND_TTL = 10 * 60 * 1000; // 10 minutes

    function degToCompass(d){
      const dirs = ['N','NE','E','SE','S','SW','W','NW','N'];
      const i = Math.round(((d % 360) / 45));
      return dirs[i];
    }
    async function fetchWind(lat, lng){
      try {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&windspeed_unit=ms`;
        const r = await fetch(url);
        const j = await r.json();
        const cw = j && j.current_weather;
        if (cw && typeof cw.windspeed === 'number' && typeof cw.winddirection === 'number') {
          return { speed: cw.windspeed, dir: cw.winddirection };
        }
      } catch {}
      return { speed: null, dir: null };
    }
    async function ensureWind(){
      if (!lastPos) return;
      const now = Date.now();
      if (now - windCache.ts > WIND_TTL) {
        const { speed, dir } = await fetchWind(lastPos.lat, lastPos.lng);
        windCache = { ts: now, lat: lastPos.lat, lng: lastPos.lng, speed, dir };
      }
      renderWind();
    }
    function renderWind(){
      const { speed, dir } = windCache;
      windSpeedEl.textContent = (typeof speed === 'number') ? `${speed.toFixed(1)} m/s` : 'â€“ m/s';
      windDirTxtEl.textContent = (typeof dir === 'number') ? `${degToCompass(dir)} (${Math.round(dir)}Â°)` : 'â€“';
      windArrowEl.style.transform = `rotate(${(typeof dir==='number'?dir:0)}deg)`;
    }

    // Panel toggle
    function setPanelHidden(h){ panel.classList.toggle('hidden', h); toggleBtn.textContent = h ? 'â˜°' : 'âœ•'; }
    setPanelHidden(true); toggleBtn.onclick = () => setPanelHidden(!panel.classList.contains('hidden'));

    // Map init view
    map.setView([-25.7542, 28.2322], 15);

    // Helpers
    function mstyle(name){ const p={front:['#059669','#10b981'],mid:['#b45309','#f59e0b'],back:['#b91c1c','#ef4444']}[name]||['#111827','#374151']; return {radius:7,weight:2,opacity:1,fillOpacity:0.9,color:p[0],fillColor:p[1]}; }
    function setMarker(n,pos,label){ if(!pos)return; if(markers[n]){markers[n].setLatLng([pos.lat,pos.lng]);return;} markers[n]=L.circleMarker([pos.lat,pos.lng],mstyle(n)).addTo(map); if(label)markers[n].bindTooltip(label); }
    function clearMarkers(){ ['front','mid','back'].forEach(n=>{ if(markers[n]){ map.removeLayer(markers[n]); delete markers[n]; }}); }

    function meters(a,b){ const R=6371000,toRad=d=>d*Math.PI/180; const dLat=toRad(b.lat-a.lat),dLng=toRad(b.lng-a.lng); const s1=Math.sin(dLat/2),s2=Math.sin(dLng/2); const q=s1*s1+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2; return 2*R*Math.asin(Math.sqrt(q)); }

    // Elevation (current position) â€” throttle & cache
    let lastElev = null, lastElevAt = 0;
    async function fetchCurrentElevation(p){
      const now = Date.now();
      if (lastElev !== null && (now - lastElevAt) < 30000) return lastElev; // 30s throttle
      try{
        const r = await fetch(`https://api.opentopodata.org/v1/srtm90m?locations=${p.lat},${p.lng}`);
        const js = await r.json();
        const v = js?.results?.[0]?.elevation;
        if (typeof v === 'number') { lastElev = v; lastElevAt = now; return v; }
      }catch{}
      return null;
    }
    function fmtDelta(d){ if (d == null) return 'â€“'; if (Math.abs(d) < 0.5) return 'Â±0 m'; return d>0 ? `â†‘ ${Math.round(d)} m` : `â†“ ${Math.round(Math.abs(d))} m`; }

    function updateHoleUI(center=true){
      if(!holes.length) return;
      const h = holes[currentIndex];
      clearMarkers();
      setMarker('front', h.green.front || h.green.center, 'Front');
      setMarker('mid',   h.green.mid   || h.green.center, 'Mid');
      setMarker('back',  h.green.back  || h.green.center, 'Back');

      holeTitle.textContent = `Hole ${h.number}`;
      parEl.textContent = h.par ?? 'â€“';
      strokeEl.textContent = h.strokeIndex ?? 'â€“';
      holesSel.value = String(h.number);

      if (center) {
        const pts = [h.green.front, h.green.mid, h.green.back, h.green.center].filter(Boolean);
        if (pts.length) map.fitBounds(L.latLngBounds(pts.map(p=>[p.lat,p.lng])));
      }
      if (lastPos) updateDistancesAndDeltas();
      updateMeasure(); // keep measure line if present
    }

    async function updateDistancesAndDeltas(){
      if (!lastPos || !holes.length) return;
      const h = holes[currentIndex];
      const f = h.green.front || h.green.center, m = h.green.mid || h.green.center, b = h.green.back || h.green.center;
      dFront.textContent = Math.round(meters(lastPos, f));
      dMid.textContent   = Math.round(meters(lastPos, m));
      dBack.textContent  = Math.round(meters(lastPos, b));

      let curElev = await fetchCurrentElevation(lastPos);
      const df = (h.elevation?.front ?? null);
      const dm = (h.elevation?.mid   ?? null);
      const db = (h.elevation?.back  ?? null);
      eFront.textContent = (curElev!=null && df!=null) ? fmtDelta(df - curElev) : 'â€“';
      eMid.textContent   = (curElev!=null && dm!=null) ? fmtDelta(dm - curElev) : 'â€“';
      eBack.textContent  = (curElev!=null && db!=null) ? fmtDelta(db - curElev) : 'â€“';
    }

    // ----- Measure tool -----
    function measureDistanceText(){
      if (!measureTarget || !lastPos) return null;
      const d = meters(lastPos, measureTarget);
      return `${Math.round(d)} m`;
    }
    function setMeasure(latlng){
      measureTarget = latlng;

      if (measureLine) map.removeLayer(measureLine);
      if (lastPos) {
        measureLine = L.polyline([[lastPos.lat,lastPos.lng],[latlng.lat,latlng.lng]], {weight:3,opacity:0.9}).addTo(map);
      }

      const txt = measureDistanceText() || 'â€“ m';
      const icon = L.divIcon({
        className: 'dd-measure',
        html: `<div class="measure-bubble"><span class="measure-text">${txt}</span><span class="measure-close">Ã—</span></div>`,
        iconSize: [10,10], iconAnchor: [5,5]
      });
      if (measureMarker) map.removeLayer(measureMarker);
      measureMarker = L.marker([latlng.lat,latlng.lng], { icon }).addTo(map);
      measureMarker.on('add', () => {
        const el = measureMarker.getElement();
        if (!el) return;
        const btn = el.querySelector('.measure-close');
        if (btn) btn.addEventListener('click', (ev) => { ev.stopPropagation(); clearMeasure(); });
      });
    }
    function updateMeasure(){
      if (!measureTarget) return;
      if (measureLine) {
        if (lastPos) measureLine.setLatLngs([[lastPos.lat,lastPos.lng],[measureTarget.lat,measureTarget.lng]]);
      }
      if (measureMarker) {
        const el = measureMarker.getElement();
        if (el) {
          const span = el.querySelector('.measure-text');
          if (span) { const txt = measureDistanceText() || 'â€“ m'; span.textContent = txt; }
        }
      }
    }
    function clearMeasure(){
      measureTarget = null;
      if (measureLine){ map.removeLayer(measureLine); measureLine=null; }
      if (measureMarker){ map.removeLayer(measureMarker); measureMarker=null; }
    }

    // Map clicks: set/relocate measure point
    map.on('click', (e) => {
      setMeasure({ lat: e.latlng.lat, lng: e.latlng.lng });
    });

    // GPS
    if ('geolocation' in navigator) {
      navigator.geolocation.watchPosition(async pos => {
        const p = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        lastPos = p;
        you.setLatLng([p.lat, p.lng]);

        if (follow) { map.setView([p.lat, p.lng], map.getZoom() || 17); recenterBtn.style.display='none'; }
        if (!movedOnce) { map.setView([p.lat, p.lng], 17); movedOnce = true; }

        status.textContent = `Accuracy: ${Math.round(pos.coords.accuracy||0)} m`;

        await updateDistancesAndDeltas();
        ensureWind();
        updateMeasure(); // live update measure distance
      }, err => { status.textContent = err.message; }, { enableHighAccuracy:true, maximumAge:1000, timeout:10000 });
    } else {
      status.textContent = 'Geolocation not supported';
    }

    // Follow/recenter
    map.on('dragstart',()=>{follow=false;recenterBtn.style.display='block';});
    map.on('zoomstart',()=>{follow=false;recenterBtn.style.display='block';});
    recenterBtn.onclick=()=>{ if(!lastPos)return; follow=true; map.setView([lastPos.lat,lastPos.lng], map.getZoom()||17); recenterBtn.style.display='none'; };

    // Courses list
    async function loadCourseList(){
      try{ const r=await fetch('/courses/index.json'); const js=await r.json(); courseList=js.courses||[]; courseSel.innerHTML=''; courseList.forEach(c=>{const o=document.createElement('option');o.value=c.id;o.textContent=c.name||c.id;courseSel.appendChild(o);}); }catch{ courseSel.innerHTML=''; }
    }
    async function loadCourse(id){
      clearMarkers(); holes=[]; currentIndex=0; holesSel.innerHTML=''; holeTitle.textContent='Hole â€“'; parEl.textContent='â€“'; strokeEl.textContent='â€“';
      try{
        const r=await fetch(`/courses/${encodeURIComponent(id)}.json`); const course=await r.json();
        holes=(course.holes||[]).map(h=>({ number:h.number, par:h.par, strokeIndex:h.strokeIndex,
          green:{ center:h.green?.center||h.green?.mid||null, front:h.green?.front||null, mid:h.green?.mid||null, back:h.green?.back||null },
          elevation:{ front:h.elevation?.front??null, mid:h.elevation?.mid??null, back:h.elevation?.back??null }
        })).sort((a,b)=>a.number-b.number);
        holes.forEach(h=>{const o=document.createElement('option');o.value=h.number;o.textContent=`Hole ${h.number}`;holesSel.appendChild(o);});
        if(holes.length){ currentIndex=0; updateHoleUI(true); }
        status.textContent=`Loaded course: ${course.name||id}`;
      }catch{ status.textContent=`Failed to load course ${id}`; }
    }

    document.getElementById('btnLoadCourse').onclick=()=>{const id=courseSel.value; if(!id)return; loadCourse(id);};
    document.getElementById('btnGoHole').onclick=()=>{const n=Number(holesSel.value); const idx=holes.findIndex(h=>h.number===n); if(idx>=0){ currentIndex=idx; updateHoleUI(true);} };
    document.getElementById('prevHole').onclick=()=>{ if(!holes.length)return; currentIndex=(currentIndex-1+holes.length)%holes.length; updateHoleUI(true); };
    document.getElementById('nextHole').onclick=()=>{ if(!holes.length)return; currentIndex=(currentIndex+1)%holes.length; updateHoleUI(true); };

    // ---------- Basemap & Contours toggles ----------
    const tgBase = document.getElementById('tgBase');
    const tgContours = document.getElementById('tgContours');

    function setBase(which){
      if (which === currentBase) return;
      if (which === 'imagery') {
        map.removeLayer(cartoVoyager);
        esriImagery.addTo(map);
        tgBase.textContent = 'Map: Imagery';
      } else {
        map.removeLayer(esriImagery);
        cartoVoyager.addTo(map);
        tgBase.textContent = 'Map: Voyager';
      }
      currentBase = which;
    }
    function setContours(on){
      if (on && !contoursOn) { contours.addTo(map); tgContours.classList.add('active'); tgContours.textContent='Contours: On'; contoursOn = true; }
      else if (!on && contoursOn) { map.removeLayer(contours); tgContours.classList.remove('active'); tgContours.textContent='Contours: Off'; contoursOn = false; }
    }
    tgBase.onclick = () => setBase(currentBase === 'imagery' ? 'voyager' : 'imagery');
    tgContours.onclick = () => setContours(!contoursOn);

    // Set initial states
    setBase('imagery');
    setContours(false);

    // SW
    if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js').catch(()=>{}); }
  </script>
</body>
</html>
