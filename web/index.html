<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DriveDen GPS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#14532d" />
  <link rel="manifest" href="/manifest.webmanifest">
  <link rel="icon" href="/icons/icon-192.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>

  <style>
    :root{
      --brand:#14532d; --brand-2:#166534; --accent:#15803d;
      --panel:#ffffffee; --text:#111827; --muted:#6b7280;
      --chip:#e6f6ea; --chipText:#14532d;
    }
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; position: relative; }

    .brand { position: fixed; top: 10px; left: 10px; z-index: 10000; background: var(--panel); padding: 6px 10px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); display:flex; align-items:center; gap:8px; }
    .brand img { height: 34px; }

    .holeWrap{ position: fixed; z-index:10000; left:50%; transform:translateX(-50%); top: 10px; display:flex; flex-direction:column; align-items:center; gap:8px; }
    .holeNav { background: var(--panel); padding: 6px 10px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; display:flex; align-items:center; gap:10px; min-width: 180px; justify-content: center; }
    .holeNav button { border:0; background:var(--accent); color:#fff; border-radius:8px; padding:4px 10px; font-size:16px; cursor:pointer; }
    .holeTitle { font-weight:600; }
    .scoreBtn { border:0; background:var(--brand-2); color:#fff; border-radius:8px; padding:6px 12px; font-size:14px; cursor:pointer; box-shadow: 0 6px 12px rgba(0,0,0,.15); }

    .windBox{ position: fixed; top: 10px; right: 10px; z-index: 10000; background: var(--panel); padding: 8px 10px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; display:flex; flex-direction:column; gap:8px; min-width: 160px; }
    .windRow { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .windLeft { display:flex; align-items:center; gap:8px; }
    .windSock { width:26px; height:26px; }
    .windData { display:flex; flex-direction:column; line-height:1.1; }
    .windSpeed { font-weight:600; }
    .windDirTxt { font-size:12px; color:var(--muted); }
    .windArrow { width:20px; height:20px; transform-origin:50% 50%; opacity:.85; }

    .distBox { position: fixed; top: 60px; left: 10px; z-index: 10000; background: var(--panel); padding: 10px 12px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; width: 190px; }
    .row { display:flex; justify-content:space-between; margin: 4px 0; font-size:14px; gap:6px; }
    .col { display:flex; flex-direction:column; align-items:flex-end; }
    .label { color:var(--muted); }
    .value { font-weight:700; }
    .delta { font-size:12px; color:var(--muted); }
    .muted { font-size: 12px; color:var(--muted); margin-top: 4px; }

    .footer { position: fixed; left: 10px; right: 10px; bottom: 10px; z-index: 10000; background: var(--panel); padding: 8px 12px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; display:flex; justify-content:center; gap:18px; font-size:14px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:var(--chip); color:var(--chipText); font-weight:700; }

    .panel { position: fixed; top: 80px; right: 10px; z-index: 10000; background: var(--panel); padding: 10px 12px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); width: 330px; max-width: calc(100% - 20px); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; max-height: 75vh; overflow: auto; transition: transform .25s ease, opacity .2s ease; }
    .panel.hidden { transform: translateY(16px); opacity:0; pointer-events:none; }
    .grid { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
    select, button, input { width: 100%; padding: 8px; font-size: 14px; }

    .fab { position: fixed; right: 12px; bottom: 12px; z-index: 10001; width: 52px; height: 52px; border-radius: 50%; border: 0; font-size: 22px; background: var(--accent); color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,.2); cursor: pointer; }
    .fab-left { position: fixed; left: 12px; bottom: 12px; z-index: 10001; width: 52px; height: 52px; border-radius: 50%; border: 0; font-size: 22px; background: var(--brand); color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,.2); cursor: pointer; display: none; }
    .fab-left svg { width:22px; height:22px; }

    /* Measure tool + second leg to green center */
    .dd-measure { pointer-events: auto; }
    .dd-measure .anchor-dot { position: absolute; left: -6px; top: -6px; width: 12px; height: 12px; border-radius: 50%; background: #111827; border: 2px solid #ffffff; box-shadow: 0 0 0 2px rgba(0,0,0,.25); }
    .dd-measure .bubble { position: absolute; transform: translate(8px, -28px); }
    .measure-bubble { background: rgba(17,24,39,.95); color: #fff; padding: 6px 8px; border-radius: 8px; font-size: 12px; display: inline-flex; align-items: center; gap: 8px; box-shadow: 0 6px 12px rgba(0,0,0,.25); user-select: none; }
    .measure-close { width: 24px; height: 24px; display: inline-flex; align-items: center; justify-content: center; background: rgba(255,255,255,.15); border-radius: 6px; cursor: pointer; font-weight: 700; }

    /* ===== Scorecard (grid: holes as columns) ===== */
    .scoreWrap{ position: fixed; left:50%; transform:translateX(-50%); bottom: 76px; z-index:10002; width:min(1200px, calc(100% - 20px)); display:none; }
    .scoreWrap.show{ display:block; }
    .scCard{ background:var(--panel); color:var(--text); border-radius:12px; box-shadow:0 14px 30px rgba(0,0,0,.25); padding:10px; }
    .scTop{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; }
    .scTop .left{ display:flex; align-items:center; gap:8px; }
    .scBtn{ background:var(--brand-2); color:#fff; border:0; border-radius:8px; padding:6px 10px; cursor:pointer; }
    .scGhost{ background:#e5e7eb; color:#111827; }
    .scGrid{ overflow:auto; }
    .scTable{ min-width:1024px; border-collapse:separate; border-spacing:6px; }
    .scTable th, .scTable td{ background:#f9fafb; padding:6px; border-radius:8px; text-align:center; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    .scHoles th{ background:#eef2ff; font-weight:700; }
    .scMeta th{ background:#f3f4f6; color:#374151; font-weight:600; font-size:12px; }
    .nameCell{ position:sticky; left:0; z-index:1; }
    .nameCell input{ width:120px; padding:6px 8px; border:1px solid #d1d5db; border-radius:8px; }
    .gross{ width:56px; padding:6px 8px; border:1px solid #d1d5db; border-radius:8px; text-align:center; font-size:14px; }
    .pts{ display:block; margin-top:4px; font-size:11px; font-weight:700; border-radius:999px; padding:2px 6px; }
    .pts.even{ background:#e5e7eb; color:#111827; }
    .pts.up{ background:#dcfce7; color:#065f46; }
    .pts.down{ background:#fee2e2; color:#7f1d1d; }
    .totCell{ min-width:56px; font-weight:700; background:#fff; }

    /* Setup modal */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:10003; }
    .modal.show{ display:flex; }
    .sheet{ width:min(560px, calc(100% - 24px)); background:#fff; border-radius:12px; box-shadow:0 18px 40px rgba(0,0,0,.35); padding:14px; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    .rowFlex{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .pRow{ display:flex; align-items:center; gap:8px; margin:8px 0; }
    .pRow input{ padding:8px; border:1px solid #d1d5db; border-radius:8px; }
    .pill{ background:#f3f4f6; padding:6px 10px; border-radius:999px; cursor:pointer; }
    .pill.on{ background:var(--accent); color:#fff; }
  </style>
</head>
<body>
  <div class="brand"><img src="driveden-logo.svg" alt="DriveDen"></div>

  <div class="holeWrap">
    <div class="holeNav">
      <button id="prevHole">◀</button>
      <div class="holeTitle" id="holeTitle">Hole –</div>
      <button id="nextHole">▶</button>
    </div>
    <button id="scoreToggle" class="scoreBtn">Scorecard</button>
  </div>

  <div class="windBox" id="windBox" title="10 m wind at 10 m height">
    <div class="windRow">
      <div class="windLeft">
        <svg class="windSock" viewBox="0 0 64 64" aria-hidden="true">
          <rect x="8" y="8" width="6" height="48" rx="3" fill="#1f2937"></rect>
          <polygon points="14,14 54,20 54,28 14,34" fill="#e11d48"></polygon>
          <line x1="14" y1="14" x2="14" y2="34" stroke="#111827" stroke-width="2"></line>
          <line x1="24" y1="16" x2="24" y2="32" stroke="#fff" stroke-width="3" opacity="0.7"></line>
          <line x1="36" y1="18" x2="36" y2="30" stroke="#fff" stroke-width="3" opacity="0.7"></line>
        </svg>
        <div class="windData">
          <div class="windSpeed" id="windSpeed">– m/s</div>
          <div class="windDirTxt" id="windDirTxt">–</div>
        </div>
      </div>
      <svg class="windArrow" id="windArrow" viewBox="0 0 24 24" aria-hidden="true">
        <polygon points="12,3 6,12 10,12 10,21 14,21 14,12 18,12" fill="#111827"></polygon>
      </svg>
    </div>
  </div>

  <div class="distBox">
    <div class="row"><span class="label">Front</span><span class="col"><span class="value" id="dFront">–</span><span class="delta" id="eFront">–</span></span></div>
    <div class="row"><span class="label">Mid</span><span class="col"><span class="value" id="dMid">–</span><span class="delta" id="eMid">–</span></span></div>
    <div class="row"><span class="label">Back</span><span class="col"><span class="value" id="dBack">–</span><span class="delta" id="eBack">–</span></span></div>
    <div class="muted" id="status">Getting GPS…</div>
  </div>

  <div class="footer">
    <div>Par <span class="badge" id="par">–</span></div>
    <div>Stroke <span class="badge" id="stroke">–</span></div>
  </div>

  <div id="map"></div>

  <div class="panel hidden" id="panel">
    <div><strong>Select course</strong></div>
    <div class="grid" style="margin-top:6px;">
      <select id="courseSelect"></select>
      <button id="btnLoadCourse">Load</button>
    </div>
    <div class="muted">Open with <code>?course=&lt;id&gt;</code> as well.</div>
    <div style="margin-top:10px;"><strong>Hole</strong></div>
    <div class="grid" style="margin-top:6px;">
      <select id="holes"></select><button id="btnGoHole">Go</button>
    </div>
  </div>

  <button id="panelToggle" class="fab">☰</button>
  <button id="recenterBtn" class="fab-left" title="Recenter">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <circle cx="12" cy="12" r="2" fill="#ffffff"/>
      <path d="M12 2v3M12 19v3M2 12h3M19 12h3" stroke="#ffffff" stroke-width="2" stroke-linecap="round"/>
      <circle cx="12" cy="12" r="7" fill="none" stroke="#ffffff" stroke-width="1.5" opacity=".7"/>
    </svg>
  </button>

  <!-- SCORECARD -->
  <div id="scoreWrap" class="scoreWrap">
    <div class="scCard">
      <div class="scTop">
        <div class="left">
          <strong>Scorecard</strong>
          <button id="scSetupBtn" class="scBtn scGhost" title="Players & handicaps">⚙</button>
        </div>
        <div class="right">
          <button id="scShare" class="scBtn scGhost">Save / Share</button>
          <button id="scClose" class="scBtn">Close</button>
        </div>
      </div>
      <div class="scGrid">
        <table class="scTable" id="scTable" aria-live="polite"></table>
      </div>
    </div>
  </div>

  <!-- Player setup modal -->
  <div id="setupModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="setupTitle">
    <div class="sheet">
      <h3 id="setupTitle" style="margin:0 0 8px 0;">Players & handicaps</h3>
      <div class="rowFlex" style="margin-bottom:8px;">
        <span id="hcToggle" class="pill">Include handicaps</span>
        <button id="addPlayer" class="scBtn scGhost" style="margin-left:auto;">+ Add player</button>
      </div>
      <div id="playerList"></div>
      <div class="rowFlex" style="justify-content:flex-end; margin-top:10px;">
        <button id="setupCancel" class="scBtn scGhost">Cancel</button>
        <button id="setupCreate" class="scBtn">Create scorecard</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>
  <script>
    /* ================= Base map ================= */
    const imagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: '&copy; Esri, Maxar, Earthstar Geographics' });
    const map = L.map('map', { zoomControl: true, layers: [imagery] });

    // cart icon
    const cartSvg = encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="40" height="32" viewBox="0 0 40 32"><rect x="5" y="10" width="24" height="10" rx="2" ry="2" fill="#1f2937"/><polygon points="5,10 15,4 29,4 29,10" fill="#0ea5b7"/><circle cx="13" cy="24" r="4" fill="#111827"/><circle cx="13" cy="24" r="2" fill="#e5e7eb"/><circle cx="27" cy="24" r="4" fill="#111827"/><circle cx="27" cy="24" r="2" fill="#e5e7eb"/><rect x="30" y="12" width="6" height="2" rx="1" fill="#111827"/><circle cx="34" cy="16" r="2" fill="#14b8a6"/></svg>`);
    const cartIcon = L.icon({ iconUrl: `data:image/svg+xml;utf8,${cartSvg}`, iconSize: [28,22], iconAnchor: [14,11] });
    const you = L.marker([0,0], { icon: cartIcon }).addTo(map);

    let lastPos=null, follow=true, movedOnce=false;
    map.setView([-25.7542, 28.2322], 15);

    /* ============= Helpers ============= */
    function meters(a,b){ const R=6371000,toRad=d=>d*Math.PI/180; const dLat=toRad(b.lat-a.lat),dLng=toRad(b.lng-a.lng); const s1=Math.sin(dLat/2),s2=Math.sin(dLng/2); const q=s1*s1+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2; return 2*R*Math.asin(Math.sqrt(q)); }
    function mstyle(n){ const p={front:['#059669','#10b981'],mid:['#b45309','#f59e0b'],back:['#b91c1c','#ef4444']}[n]||['#111827','#374151']; return {radius:7,weight:2,opacity:1,fillOpacity:.9,color:p[0],fillColor:p[1]}; }
    function fmtDelta(d){ if(d==null) return '–'; if(Math.abs(d)<0.5) return '±0 m'; return d>0?`↑ ${Math.round(d)} m`:`↓ ${Math.round(Math.abs(d))} m`; }

    /* ============= UI refs ============= */
    const status=document.getElementById('status');
    const dFront=document.getElementById('dFront'), dMid=document.getElementById('dMid'), dBack=document.getElementById('dBack');
    const eFront=document.getElementById('eFront'), eMid=document.getElementById('eMid'), eBack=document.getElementById('eBack');
    const parEl=document.getElementById('par'), strokeEl=document.getElementById('stroke');
    const holeTitle=document.getElementById('holeTitle');
    const recenterBtn=document.getElementById('recenterBtn');
    const panel=document.getElementById('panel'), toggleBtn=document.getElementById('panelToggle');
    const courseSel=document.getElementById('courseSelect'), holesSel=document.getElementById('holes');

    function setPanelHidden(h){ panel.classList.toggle('hidden',h); toggleBtn.textContent=h?'☰':'✕'; }
    setPanelHidden(true); toggleBtn.onclick=()=>setPanelHidden(!panel.classList.contains('hidden'));

    /* ============= Wind ============= */
    const windSpeedEl=document.getElementById('windSpeed'), windDirTxtEl=document.getElementById('windDirTxt'), windArrowEl=document.getElementById('windArrow');
    let windCache={ts:0,lat:null,lng:null,speed:null,dir:null}; const WIND_TTL=10*60*1000;
    function degToCompass(d){ const dirs=['N','NE','E','SE','S','SW','W','NW','N']; return dirs[Math.round(((d%360)/45))]; }
    async function fetchWind(lat,lng){ try{ const r=await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&windspeed_unit=ms`); const j=await r.json(); const cw=j?.current_weather; if(typeof cw?.windspeed==='number'&&typeof cw?.winddirection==='number') return {speed:cw.windspeed,dir:cw.winddirection}; }catch{} return {speed:null,dir:null}; }
    async function ensureWind(){ if(!lastPos)return; const now=Date.now(); if(now-windCache.ts>WIND_TTL){ const {speed,dir}=await fetchWind(lastPos.lat,lastPos.lng); windCache={ts:now,lat:lastPos.lat,lng:lastPos.lng,speed,dir}; } renderWind(); }
    function renderWind(){ const {speed,dir}=windCache; windSpeedEl.textContent=(typeof speed==='number')?`${speed.toFixed(1)} m/s`:'– m/s'; windDirTxtEl.textContent=(typeof dir==='number')?`${degToCompass(dir)} (${Math.round(dir)}°)`:'–'; windArrowEl.style.transform=`rotate(${(typeof dir==='number'?dir:0)}deg)`; }

    /* ============= Course state ============= */
    let holes=[], currentIndex=0, courseList=[];
    const markers={};
    function setMarker(n,pos,label){ if(!pos)return; if(markers[n]){markers[n].setLatLng([pos.lat,pos.lng]);return;} markers[n]=L.circleMarker([pos.lat,pos.lng],mstyle(n)).addTo(map); if(label)markers[n].bindTooltip(label); }
    function clearMarkers(){ ['front','mid','back'].forEach(n=>{ if(markers[n]){ map.removeLayer(markers[n]); delete markers[n]; }}); }

    // current elevation cache (for deltas)
    let lastElev=null,lastElevAt=0;
    async function fetchCurrentElevation(p){
      const now=Date.now();
      if(lastElev!==null && (now-lastElevAt)<30000) return lastElev;
      try{ const r=await fetch(`/elevation?lat=${p.lat}&lng=${p.lng}`); const js=await r.json(); const v=js?.results?.[0]?.elevation; if(typeof v==='number'){ lastElev=v; lastElevAt=now; return v; } }catch{} return null;
    }

    async function updateDistancesAndDeltas(){
      if(!lastPos || !holes.length) return;
      const h=holes[currentIndex]; const f=h.green.front||h.green.center, m=h.green.mid||h.green.center, b=h.green.back||h.green.center;
      dFront.textContent=Math.round(meters(lastPos,f));
      dMid.textContent  =Math.round(meters(lastPos,m));
      dBack.textContent =Math.round(meters(lastPos,b));
      const curElev=await fetchCurrentElevation(lastPos);
      const df=h.elevation?.front??null, dm=h.elevation?.mid??null, db=h.elevation?.back??null;
      eFront.textContent=(curElev!=null&&df!=null)?fmtDelta(df-curElev):'–';
      eMid.textContent  =(curElev!=null&&dm!=null)?fmtDelta(dm-curElev):'–';
      eBack.textContent =(curElev!=null&&db!=null)?fmtDelta(db-curElev):'–';
    }

    function updateHoleUI(center=true){
      if(!holes.length) return;
      const h=holes[currentIndex];
      clearMarkers();
      setMarker('front',h.green.front||h.green.center,'Front');
      setMarker('mid',  h.green.mid  ||h.green.center,'Mid');
      setMarker('back', h.green.back ||h.green.center,'Back');

      holeTitle.textContent=`Hole ${h.number}`;
      parEl.textContent=h.par??'–'; strokeEl.textContent=h.strokeIndex??'–';
      holesSel.value=String(h.number);

      if(center){ const pts=[h.green.front,h.green.mid,h.green.back,h.green.center].filter(Boolean); if(pts.length) map.fitBounds(L.latLngBounds(pts.map(p=>[p.lat,p.lng]))); }
      if(lastPos) updateDistancesAndDeltas();
      updateMeasure();
      highlightCurrentHoleHeader();
    }

    /* ============= Measure tool (with second leg to green center) ============= */
    let measureTarget=null, measureMarker=null, measureLine=null, toMidLine=null, toMidMarker=null, suppressClickUntil=0;
    function measureDistanceText(){ if(!measureTarget || !lastPos) return null; const d=meters(lastPos,measureTarget); return `${Math.round(d)} m`; }
    function toMidDistanceText(){ if(!measureTarget || !holes.length) return null; const m=holes[currentIndex]?.green?.mid||holes[currentIndex]?.green?.center; if(!m) return null; const d=meters(measureTarget,m); return `${Math.round(d)} m`; }
    function clearMeasure(){ measureTarget=null; [measureLine, toMidLine, measureMarker, toMidMarker].forEach(l=>{ if(l){ map.removeLayer(l); } }); measureLine=toMidLine=measureMarker=toMidMarker=null; }
    function setMeasure(latlng){
      measureTarget=latlng;
      if(measureLine) map.removeLayer(measureLine);
      if(lastPos){ measureLine=L.polyline([[lastPos.lat,lastPos.lng],[latlng.lat,latlng.lng]],{weight:3,opacity:.9}).addTo(map); }
      // bubble at clicked point
      const icon=L.divIcon({
        className:'dd-measure',
        html:`<div class="anchor-dot"></div><div class="bubble"><div class="measure-bubble"><span class="measure-text">${measureDistanceText()||'– m'}</span><span class="measure-close" aria-label="Clear">×</span></div></div>`,
        iconSize:[0,0], iconAnchor:[0,0]
      });
      if(measureMarker) map.removeLayer(measureMarker);
      measureMarker=L.marker([latlng.lat,latlng.lng],{icon,zIndexOffset:10000,interactive:true}).addTo(map);
      measureMarker.on('add',()=>{
        const el=measureMarker.getElement(); if(!el) return;
        L.DomEvent.disableClickPropagation(el);
        el.querySelectorAll('*').forEach(n=>L.DomEvent.on(n,'click',L.DomEvent.stopPropagation));
        const btn=el.querySelector('.measure-close');
        if(btn){ btn.addEventListener('click',(ev)=>{ ev.preventDefault(); ev.stopPropagation(); suppressClickUntil=Date.now()+250; clearMeasure(); }); }
      });

      // second leg to mid
      const mid=holes[currentIndex]?.green?.mid||holes[currentIndex]?.green?.center;
      if(mid){
        if(toMidLine) map.removeLayer(toMidLine);
        toMidLine=L.polyline([[latlng.lat,latlng.lng],[mid.lat,mid.lng]],{weight:3,opacity:.9,color:'#b91c1c',dashArray:'6 6'}).addTo(map);
        const icon2=L.divIcon({
          className:'dd-measure',
          html:`<div class="bubble" style="transform: translate(8px, -28px);"><div class="measure-bubble" style="background:#b91c1c;">→ green <span class="toMid-text" style="margin-left:6px;">${toMidDistanceText()||'– m'}</span></div></div>`,
          iconSize:[0,0], iconAnchor:[0,0]
        });
        if(toMidMarker) map.removeLayer(toMidMarker);
        // place bubble roughly half way
        const midLat=(latlng.lat+mid.lat)/2, midLng=(latlng.lng+mid.lng)/2;
        toMidMarker=L.marker([midLat,midLng],{icon,interactive:false}).addTo(map);
      }
    }
    function updateMeasure(){
      if(!measureTarget) return;
      if(measureLine && lastPos) measureLine.setLatLngs([[lastPos.lat,lastPos.lng],[measureTarget.lat,measureTarget.lng]]);
      const el=measureMarker?.getElement(); if(el){ const span=el.querySelector('.measure-text'); if(span) span.textContent=measureDistanceText()||'– m'; }
      const mid=holes[currentIndex]?.green?.mid||holes[currentIndex]?.green?.center;
      if(mid && toMidLine){ toMidLine.setLatLngs([[measureTarget.lat,measureTarget.lng],[mid.lat,mid.lng]]); const el2=toMidMarker?.getElement(); if(el2){ const s=el2.querySelector('.toMid-text'); if(s) s.textContent=toMidDistanceText()||'– m'; } }
    }
    function onMapClick(e){ if(Date.now()<suppressClickUntil) return; setMeasure({lat:e.latlng.lat,lng:e.latlng.lng}); }
    map.on('click', onMapClick);

    /* ============= Geolocation ============= */
    if('geolocation' in navigator){
      navigator.geolocation.watchPosition(async pos=>{
        const p={lat:pos.coords.latitude,lng:pos.coords.longitude};
        lastPos=p; you.setLatLng([p.lat,p.lng]);
        if(follow){ map.setView([p.lat,p.lng], map.getZoom()||17); recenterBtn.style.display='none'; }
        if(!movedOnce){ map.setView([p.lat,p.lng],17); movedOnce=true; }
        status.textContent=`Accuracy: ${Math.round(pos.coords.accuracy||0)} m`;
        await updateDistancesAndDeltas(); ensureWind(); updateMeasure();
      }, err=>{ status.textContent=err.message; }, {enableHighAccuracy:true, maximumAge:1000, timeout:10000});
    } else { status.textContent='Geolocation not supported'; }

    map.on('dragstart',()=>{follow=false;recenterBtn.style.display='block';});
    map.on('zoomstart',()=>{follow=false;recenterBtn.style.display='block';});
    recenterBtn.onclick=()=>{ if(!lastPos)return; follow=true; map.setView([lastPos.lat,lastPos.lng], map.getZoom()||17); recenterBtn.style.display='none'; };

    /* ============= Course list + load ============= */
    async function loadCourseList(){ try{ const r=await fetch('/courses/index.json'); const js=await r.json(); courseList=js.courses||[]; courseSel.innerHTML=''; courseList.forEach(c=>{const o=document.createElement('option');o.value=c.id;o.textContent=c.name||c.id;courseSel.appendChild(o);}); }catch{ courseSel.innerHTML=''; } }
    async function loadCourse(id){
      holes=[]; currentIndex=0; holesSel.innerHTML=''; clearMarkers(); holeTitle.textContent='Hole –'; parEl.textContent='–'; strokeEl.textContent='–';
      try{
        const r=await fetch(`/courses/${encodeURIComponent(id)}.json`); const raw=await r.json();
        const root=raw.course||raw;
        holes=(root.holes||[]).map(h=>({ number:(h.number??h.hole??h.holeNumber??null)*1, par:(h.par!=null?Number(h.par):null), strokeIndex:(h.strokeIndex??h.stroke??h.si??null)*1||null, green:{center:h.green?.center||h.green?.mid||null, front:h.green?.front||null, mid:h.green?.mid||null, back:h.green?.back||null}, elevation:{front:h.elevation?.front??null, mid:h.elevation?.mid??null, back:h.elevation?.back??null} })).filter(h=>Number.isFinite(h.number)).sort((a,b)=>a.number-b.number);

        holesSel.innerHTML=''; holes.forEach(h=>{const o=document.createElement('option');o.value=h.number;o.textContent=`Hole ${h.number}`;holesSel.appendChild(o);});
        if(holes.length){ currentIndex=0; updateHoleUI(true); }
        status.textContent=`Loaded course: ${root.name||id}`;

        await autofillElevationsForCourse(id); // fills missing F/M/B
        buildScorecardShell(root.name||id); loadSavedState(id); renderScoreTable(); highlightCurrentHoleHeader();
      }catch{ status.textContent=`Failed to load course ${id}`; }
    }
    document.getElementById('btnLoadCourse').onclick=()=>{ const id=courseSel.value; if(!id)return; loadCourse(id); };
    document.getElementById('btnGoHole').onclick=()=>{ const n=Number(holesSel.value); const idx=holes.findIndex(h=>h.number===n); if(idx>=0){ currentIndex=idx; updateHoleUI(true); highlightCurrentHoleHeader(); } };
    document.getElementById('prevHole').onclick=()=>{ if(!holes.length)return; currentIndex=(currentIndex-1+holes.length)%holes.length; updateHoleUI(true); highlightCurrentHoleHeader(); };
    document.getElementById('nextHole').onclick=()=>{ if(!holes.length)return; currentIndex=(currentIndex+1)%holes.length; updateHoleUI(true); highlightCurrentHoleHeader(); };

    /* ===== Elevation autofill cache via /elevation proxy ===== */
    const ELEV_CACHE_TTL=1000*60*60*24*30;
    function loadElevCache(courseId){ try{ const raw=localStorage.getItem('dd_elev_'+courseId); const obj=raw?JSON.parse(raw):null; if(!obj||!obj.ts||(Date.now()-obj.ts)>ELEV_CACHE_TTL) return {ts:Date.now(),holes:{}}; return obj; }catch{return {ts:Date.now(),holes:{}};} }
    function saveElevCache(courseId,cache){ try{ cache.ts=Date.now(); localStorage.setItem('dd_elev_'+courseId, JSON.stringify(cache)); }catch{} }
    async function fetchElevPoint(lat,lng){ try{ const r=await fetch(`/elevation?lat=${lat}&lng=${lng}`); if(r.ok){ const j=await r.json(); const v=j?.results?.[0]?.elevation; if(typeof v==='number') return v; } }catch{} return null; }
    async function autofillElevationsForCourse(courseId){
      if(!holes.length) return;
      const cache=loadElevCache(courseId);
      holes.forEach(h=>{ const ch=cache.holes?.[h.number]; if(ch){ h.elevation=h.elevation||{}; ['front','mid','back'].forEach(k=>{ if(ch[k]!=null && h.elevation[k]==null) h.elevation[k]=ch[k]; }); } });
      const jobs=[];
      for(const h of holes){
        const pts=[['front',h.green.front],['mid',h.green.mid||h.green.center],['back',h.green.back]];
        for(const [key,pt] of pts){ if(!pt) continue; if(h.elevation?.[key]==null) jobs.push({hole:h,key,lat:pt.lat,lng:pt.lng}); }
      }
      for(const job of jobs){
        const v=await fetchElevPoint(job.lat,job.lng);
        if(!job.hole.elevation) job.hole.elevation={};
        if(v!=null) job.hole.elevation[job.key]=v;
        const entry=cache.holes[job.hole.number]||{}; if(v!=null) entry[job.key]=v; cache.holes[job.hole.number]=entry;
        if(job.hole===holes[currentIndex]) updateDistancesAndDeltas();
      }
      saveElevCache(courseId,cache); updateHoleUI(false);
    }

    /* =================== SCORECARD =================== */
    const scoreToggle=document.getElementById('scoreToggle');
    const scoreWrap=document.getElementById('scoreWrap');
    const scTable=document.getElementById('scTable');
    const scClose=document.getElementById('scClose');
    const scShare=document.getElementById('scShare');
    const scSetupBtn=document.getElementById('scSetupBtn');

    // setup modal
    const setupModal=document.getElementById('setupModal');
    const hcToggle=document.getElementById('hcToggle');
    const addPlayerBtn=document.getElementById('addPlayer');
    const playerList=document.getElementById('playerList');
    const setupCancel=document.getElementById('setupCancel');
    const setupCreate=document.getElementById('setupCreate');

    // score state
    let courseIdForScores=null, courseNameForScores='Course';
    let includeHc=false;
    let players=[]; // [{name:'P1', h:0}]
    let scores=[];  // [player][18] = number|null

    function persistAll(){
      if(!courseIdForScores) return;
      const save={ includeHc, players, scores };
      localStorage.setItem(`dd_sc_state_${courseIdForScores}`, JSON.stringify(save));
    }
    function loadSavedState(cid){
      courseIdForScores=cid;
      try{
        const raw=localStorage.getItem(`dd_sc_state_${cid}`);
        if(raw){
          const obj=JSON.parse(raw);
          includeHc=!!obj.includeHc;
          players=Array.isArray(obj.players)&&obj.players.length?obj.players:[{name:'Player 1',h:0}];
          scores=Array.isArray(obj.scores)&&obj.scores.length?obj.scores:Array.from({length:players.length},()=>Array(18).fill(null));
        }else{
          includeHc=false; players=[{name:'Player 1',h:0}]; scores=[Array(18).fill(null)];
        }
      }catch{ includeHc=false; players=[{name:'Player 1',h:0}]; scores=[Array(18).fill(null)]; }
    }

    function strokesForHole(hcap, si){
      if(!includeHc) return 0;
      hcap = Math.max(0, Math.min(54, Number(hcap)||0));
      si = Math.max(1, Math.min(18, Number(si)||18));
      const extra = Math.floor(hcap / 18);
      const remainder = hcap % 18;
      return extra + (si <= remainder ? 1 : 0);
    }
    function stablefordPoints(gross, par, si, hcap){
      if(gross==null || par==null) return null;
      const strokes = strokesForHole(hcap, si);
      const net = gross - strokes;
      const diff = net - par; // +1 = bogey, 0 = par, -1 = birdie …
      if(diff >= 2) return 0;
      if(diff === 1) return 1;
      if(diff === 0) return 2;
      if(diff === -1) return 3;
      if(diff === -2) return 4;
      return 5; // -3 or better
    }
    function ptsClass(p){ if(p==null) return 'even'; if(p>2) return 'up'; if(p<2) return 'down'; return 'even'; }

    function buildScorecardShell(name){
      courseNameForScores=name||'Course';
      // build header rows (holes / par / stroke)
      scTable.innerHTML='';
      const trH=document.createElement('tr'); trH.className='scHoles';
      const thName=document.createElement('th'); thName.className='nameCell'; thName.textContent='Player';
      trH.appendChild(thName);
      for(let i=0;i<18;i++){ const th=document.createElement('th'); th.textContent=String(i+1); trH.appendChild(th); }
      ['OUT','IN','TOT','NET'].forEach(t=>{ const th=document.createElement('th'); th.textContent=t; trH.appendChild(th); });
      scTable.appendChild(trH);

      const trPar=document.createElement('tr'); trPar.className='scMeta';
      trPar.appendChild(document.createElement('th')).textContent='Par';
      for(let i=0;i<18;i++){ const th=document.createElement('th'); th.textContent=(holes[i]?.par??'-'); trPar.appendChild(th); }
      for(let i=0;i<4;i++){ trPar.appendChild(document.createElement('th')); }
      scTable.appendChild(trPar);

      const trSi=document.createElement('tr'); trSi.className='scMeta';
      trSi.appendChild(document.createElement('th')).textContent='Stroke';
      for(let i=0;i<18;i++){ const th=document.createElement('th'); th.textContent=(holes[i]?.strokeIndex??'-'); trSi.appendChild(th); }
      for(let i=0;i<4;i++){ trSi.appendChild(document.createElement('th')); }
      scTable.appendChild(trSi);
    }

    function renderScoreTable(){
      // remove old player rows
      const rows=[...scTable.querySelectorAll('.plRow')];
      rows.forEach(r=>r.remove());

      players.forEach((pl,pIdx)=>{
        const tr=document.createElement('tr'); tr.className='plRow';
        // name
        const nameTh=document.createElement('th'); nameTh.className='nameCell';
        const nameInput=document.createElement('input'); nameInput.value=pl.name||`Player ${pIdx+1}`;
        nameInput.oninput=()=>{ players[pIdx].name=nameInput.value; persistAll(); };
        nameTh.appendChild(nameInput); tr.appendChild(nameTh);

        // 18 holes inputs + points badge
        for(let h=0;h<18;h++){
          const td=document.createElement('td');
          const input=document.createElement('input'); input.type='number'; input.min='1'; input.className='gross';
          input.value = scores[pIdx]?.[h] ?? '';
          const badge=document.createElement('span'); badge.className='pts even'; badge.textContent='';
          function recompute(){
            const v=(input.value===''?null:Number(input.value));
            if(!scores[pIdx]) scores[pIdx]=Array(18).fill(null);
            scores[pIdx][h]=v;
            const par=holes[h]?.par??null, si=holes[h]?.strokeIndex??null;
            const pts=stablefordPoints(v,par,si,players[pIdx]?.h||0);
            badge.textContent = (pts==null?'': `${pts} pts`);
            badge.className='pts '+ptsClass(pts);
            updateTotalsCells(tr, pIdx);
            persistAll();
            // auto-advance on Player 1 current hole
            if(pIdx===0 && h===currentIndex && v!=null){
              currentIndex=(currentIndex+1)%holes.length; updateHoleUI(true); highlightCurrentHoleHeader();
            }
          }
          input.addEventListener('input', recompute);
          input.addEventListener('change', recompute);
          td.appendChild(input); td.appendChild(badge); tr.appendChild(td);
        }

        // trailing totals
        for(const kind of ['OUT','IN','TOT','NET']){
          const td=document.createElement('td'); td.className='totCell'; td.dataset.kind=kind; tr.appendChild(td);
        }
        scTable.appendChild(tr);
        updateTotalsCells(tr, pIdx);
      });
    }

    function sumRange(arr, a,b){ let t=0; for(let i=a;i<=b;i++){ const v=arr[i]; if(typeof v==='number') t+=v; } return t; }
    function stablefordSum(pIdx, a,b){
      let t=0;
      for(let i=a;i<=b;i++){
        const v=scores[pIdx]?.[i]; const par=holes[i]?.par??null; const si=holes[i]?.strokeIndex??null;
        const pts=stablefordPoints(v,par,si,players[pIdx]?.h||0);
        if(typeof pts==='number') t+=pts;
      }
      return t;
    }
    function totalGross(pIdx){ return sumRange(scores[pIdx]||[],0,17); }

    function updateTotalsCells(tr, pIdx){
      const cells=tr.querySelectorAll('.totCell');
      const outGross=sumRange(scores[pIdx]||[],0,8);
      const inGross =sumRange(scores[pIdx]||[],9,17);
      const totGross=(typeof outGross==='number'?outGross:0)+(typeof inGross==='number'?inGross:0);
      const net = totGross - (includeHc ? (Number(players[pIdx]?.h)||0) : 0);
      cells[0].textContent = outGross||0;
      cells[1].textContent = inGross||0;
      cells[2].textContent = totGross||0;
      cells[3].textContent = net||0;
    }

    // highlight the current hole header cell
    function highlightCurrentHoleHeader(){
      const ths=[...scTable.querySelectorAll('.scHoles th')];
      ths.forEach((th,i)=>{ th.style.outline='none'; if(i-1===currentIndex) th.style.outline='2px solid var(--accent)'; });
    }

    // open/close scorecard
    scoreToggle.onclick=()=>{ scoreWrap.classList.toggle('show'); highlightCurrentHoleHeader(); };
    scClose.onclick=()=>scoreWrap.classList.remove('show');

    // setup modal logic
    function renderSetup(){
      hcToggle.classList.toggle('on', includeHc);
      playerList.innerHTML='';
      players.forEach((pl,idx)=>{
        const row=document.createElement('div'); row.className='pRow';
        const nm=document.createElement('input'); nm.placeholder=`Player ${idx+1}`; nm.value=pl.name||''; nm.oninput=()=>{ players[idx].name=nm.value; persistAll(); };
        const hc=document.createElement('input'); hc.type='number'; hc.min='0'; hc.max='54'; hc.placeholder='HC'; hc.style.width='80px'; hc.value=pl.h||0; hc.oninput=()=>{ players[idx].h=Number(hc.value)||0; persistAll(); };
        const del=document.createElement('button'); del.className='scBtn scGhost'; del.textContent='Remove'; del.onclick=()=>{ players.splice(idx,1); scores.splice(idx,1); if(players.length===0){ players=[{name:'Player 1',h:0}]; scores=[Array(18).fill(null)]; } renderSetup(); persistAll(); renderScoreTable(); };
        row.appendChild(nm);
        if(includeHc) row.appendChild(hc);
        row.appendChild(del);
        playerList.appendChild(row);
      });
    }
    scSetupBtn.onclick=()=>{ setupModal.classList.add('show'); renderSetup(); };
    scoreToggle.addEventListener('dblclick', ()=>{ setupModal.classList.add('show'); renderSetup(); }); // quick access if empty
    hcToggle.onclick=()=>{ includeHc=!includeHc; renderSetup(); persistAll(); renderScoreTable(); };
    addPlayerBtn.onclick=()=>{ if(players.length>=4) return; players.push({name:`Player ${players.length+1}`,h:0}); scores.push(Array(18).fill(null)); renderSetup(); persistAll(); renderScoreTable(); };
    setupCancel.onclick=()=>setupModal.classList.remove('show');
    setupCreate.onclick=()=>{ setupModal.classList.remove('show'); renderScoreTable(); persistAll(); scoreWrap.classList.add('show'); };

    // share/save
    scShare.onclick=async ()=>{
      const online = navigator.onLine;
      const lines=[];
      lines.push(`${courseNameForScores} — Scorecard`);
      const now=new Date(); lines.push(`${now.toDateString()} ${now.toLocaleTimeString()}`);
      lines.push('');
      players.forEach((pl,pi)=>{
        const out=sumRange(scores[pi]||[],0,8), inn=sumRange(scores[pi]||[],9,17), tot=(out||0)+(inn||0);
        const net= tot - (includeHc ? (Number(pl.h)||0) : 0);
        const st= stablefordSum(pi,0,17);
        lines.push(`${pl.name||'Player'}: OUT ${out||0}  IN ${inn||0}  TOT ${tot||0}  NET ${net||0}  Stableford ${st||0}${includeHc?`  (HC ${pl.h||0})`:''}`);
      });
      const text=lines.join('\n');

      if(!online){
        alert('Please advance to clubhouse or network area first.');
        try{ await navigator.clipboard.writeText(text); alert('Summary copied. You can paste and share later.'); }catch{}
        return;
      }
      if(navigator.share){
        try{ await navigator.share({ title:`${courseNameForScores} — Scorecard`, text }); }catch{}
      }else{
        try{ await navigator.clipboard.writeText(text); alert('Summary copied. You can paste into WhatsApp/Email.'); }catch{ alert('Copy failed.'); }
      }
    };

    /* ============= Init ============= */
    loadCourseList();
    const cid=new URLSearchParams(location.search).get('course');
    if(cid){ loadCourse(cid).then(()=>{ setTimeout(()=>{ const f=courseList.find(c=>c.id===cid); if(f) courseSel.value=cid; },300); }); }
  </script>
</body>
</html>
