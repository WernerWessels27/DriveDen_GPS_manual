<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DriveDen GPS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#14532d" />
  <!-- PWA hooks -->
  <link rel="manifest" href="/manifest.webmanifest">
  <link rel="icon" href="/icons/icon-192.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>

  <style>
    :root{
      --brand:#14532d; --brand-2:#166534; --accent:#15803d;
      --panel:#ffffffee; --text:#111827; --muted:#6b7280;
      --chip:#e6f6ea; --chipText:#14532d;
    }
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; position: relative; }

    .brand { position: fixed; top: 10px; left: 10px; z-index: 10000; background: var(--panel); padding: 6px 10px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); display:flex; align-items:center; gap:8px; }
    .brand img { height: 34px; }

    .holeWrap{ position: fixed; z-index:10000; left:50%; transform:translateX(-50%); top: 10px; display:flex; flex-direction:column; align-items:center; gap:8px; }
    .holeNav { background: var(--panel); padding: 6px 10px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; display:flex; align-items:center; gap:10px; min-width: 180px; justify-content: center; }
    .holeNav button { border:0; background:var(--accent); color:#fff; border-radius:8px; padding:4px 10px; font-size:16px; cursor:pointer; }
    .holeTitle { font-weight:600; }
    .scoreBtn { border:0; background:var(--brand-2); color:#fff; border-radius:8px; padding:6px 12px; font-size:14px; cursor:pointer; box-shadow: 0 6px 12px rgba(0,0,0,.15); }

    .windBox{ position: fixed; top: 10px; right: 10px; z-index: 10000; background: var(--panel); padding: 8px 10px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; display:flex; flex-direction:column; gap:8px; min-width: 160px; }
    .windRow { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .windLeft { display:flex; align-items:center; gap:8px; }
    .windSock { width:26px; height:26px; }
    .windData { display:flex; flex-direction:column; line-height:1.1; }
    .windSpeed { font-weight:600; }
    .windDirTxt { font-size:12px; color:var(--muted); }
    .windArrow { width:20px; height:20px; transform-origin:50% 50%; opacity:.85; }

    .distBox { position: fixed; top: 60px; left: 10px; z-index: 10000; background: var(--panel); padding: 10px 12px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; width: 190px; }
    .row { display:flex; justify-content:space-between; margin: 4px 0; font-size:14px; gap:6px; }
    .col { display:flex; flex-direction:column; align-items:flex-end; }
    .label { color:var(--muted); }
    .value { font-weight:700; }
    .delta { font-size:12px; color:var(--muted); }
    .muted { font-size: 12px; color:var(--muted); margin-top: 4px; }

    .footer { position: fixed; left: 10px; right: 10px; bottom: 10px; z-index: 10000; background: var(--panel); padding: 8px 12px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; display:flex; justify-content:center; gap:18px; font-size:14px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:var(--chip); color:var(--chipText); font-weight:700; }

    .panel { position: fixed; top: 80px; right: 10px; z-index: 10000; background: var(--panel); padding: 10px 12px; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,.15); width: 330px; max-width: calc(100% - 20px); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; max-height: 75vh; overflow: auto; transition: transform .25s ease, opacity .2s ease; }
    .panel.hidden { transform: translateY(16px); opacity:0; pointer-events:none; }
    .grid { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
    select, button, input { width: 100%; padding: 8px; font-size: 14px; }

    .fab { position: fixed; right: 12px; bottom: 12px; z-index: 10001; width: 52px; height: 52px; border-radius: 50%; border: 0; font-size: 22px; background: var(--accent); color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,.2); cursor: pointer; }
    .fab-left { position: fixed; left: 12px; bottom: 12px; z-index: 10001; width: 52px; height: 52px; border-radius: 50%; border: 0; font-size: 22px; background: var(--brand); color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,.2); cursor: pointer; display: none; }
    .fab-left svg { width:22px; height:22px; }

    /* Measure bubble */
    .dd-measure .anchor-dot { position: absolute; left: -6px; top: -6px; width: 12px; height: 12px; border-radius: 50%; background: #111827; border: 2px solid #ffffff; box-shadow: 0 0 0 2px rgba(0,0,0,.25); }
    .dd-measure .bubble { position: absolute; transform: translate(8px, -28px); }
    .measure-bubble { background: rgba(17,24,39,.95); color: #fff; padding: 6px 8px; border-radius: 8px; font-size: 12px; display: inline-flex; align-items: center; gap: 8px; box-shadow: 0 6px 12px rgba(0,0,0,.25); user-select: none; }
    .measure-close { width: 24px; height: 24px; display: inline-flex; align-items: center; justify-content: center; background: rgba(255,255,255,.15); border-radius: 6px; cursor: pointer; font-weight: 700; }

    /* Scorecard */
    .scorecard{
      position: fixed; left: 50%; bottom: 76px; transform: translateX(-50%);
      width: min(940px, calc(100% - 20px)); max-height: 70vh; overflow: auto;
      background: var(--panel); color: var(--text); border-radius: 12px;
      box-shadow: 0 14px 30px rgba(0,0,0,.25); padding: 12px; z-index: 10002; display: none;
    }
    .scorecard.show{ display: block; }
    .sc-players{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin-bottom:8px; }
    .sc-tools{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin:6px 0 10px; }
    .sc-button{ background: var(--brand-2); color:#fff; border:0; border-radius:8px; padding:6px 10px; cursor:pointer; }
    .sc-muted{ font-size:12px; color:var(--muted); }
    .sc-row{ display:grid; grid-template-columns: 38px 46px repeat(4, minmax(82px, 1fr)); gap:8px; align-items:center; padding: 4px 0; border-bottom: 1px solid #e5e7eb; }
    .sc-head{ font-weight:700; background: #f9fafb; border-radius:8px; padding:6px 8px; }
    .sc-hole{ text-align:center; } .sc-par{ text-align:center; }
    .sc-cell{ display:flex; align-items:center; gap:8px; }
    .sc-score{ width: 64px; padding:6px 8px; border:1px solid #d1d5db; border-radius:8px; font-size:14px; }
    .sc-chip{ min-width: 34px; text-align:center; border-radius:999px; padding:3px 8px; font-weight:700; font-size:12px; background:#e5e7eb; color:#111827; }
    .sc-chip.under{ background:#dcfce7; color:#065f46; } .sc-chip.over{ background:#fee2e2; color:#7f1d1d; } .sc-chip.even{ background:#e5e7eb; color:#111827; }
    .sc-totals{ margin-top:10px; font-weight:600; text-align:center; background:#f3f4f6; border-radius:8px; padding:8px; }
  </style>
</head>
<body>
  <div class="brand"><img src="driveden-logo.svg" alt="DriveDen"></div>

  <div class="holeWrap">
    <div class="holeNav">
      <button id="prevHole">◀</button>
      <div class="holeTitle" id="holeTitle">Hole –</div>
      <button id="nextHole">▶</button>
    </div>
    <button id="scoreToggle" class="scoreBtn">Scorecard</button>
  </div>

  <div class="windBox" id="windBox" title="10 m wind at 10 m height">
    <div class="windRow">
      <div class="windLeft">
        <svg class="windSock" viewBox="0 0 64 64" aria-hidden="true">
          <rect x="8" y="8" width="6" height="48" rx="3" fill="#1f2937"></rect>
          <polygon points="14,14 54,20 54,28 14,34" fill="#e11d48"></polygon>
          <line x1="14" y1="14" x2="14" y2="34" stroke="#111827" stroke-width="2"></line>
          <line x1="24" y1="16" x2="24" y2="32" stroke="#fff" stroke-width="3" opacity="0.7"></line>
          <line x1="36" y1="18" x2="36" y2="30" stroke="#fff" stroke-width="3" opacity="0.7"></line>
        </svg>
        <div class="windData">
          <div class="windSpeed" id="windSpeed">– m/s</div>
          <div class="windDirTxt" id="windDirTxt">–</div>
        </div>
      </div>
      <svg class="windArrow" id="windArrow" viewBox="0 0 24 24" aria-hidden="true">
        <polygon points="12,3 6,12 10,12 10,21 14,21 14,12 18,12" fill="#111827"></polygon>
      </svg>
    </div>
  </div>

  <div class="distBox">
    <div class="row"><span class="label">Front</span><span class="col"><span class="value" id="dFront">–</span><span class="delta" id="eFront">–</span></span></div>
    <div class="row"><span class="label">Mid</span><span class="col"><span class="value" id="dMid">–</span><span class="delta" id="eMid">–</span></span></div>
    <div class="row"><span class="label">Back</span><span class="col"><span class="value" id="dBack">–</span><span class="delta" id="eBack">–</span></span></div>
    <div class="muted" id="status">Getting GPS…</div>
  </div>

  <div class="footer">
    <div>Par <span class="badge" id="par">–</span></div>
    <div>Stroke <span class="badge" id="stroke">–</span></div>
  </div>

  <div id="map"></div>

  <div class="panel hidden" id="panel">
    <div><strong>Select course</strong></div>
    <div class="grid" style="margin-top:6px;">
      <select id="courseSelect"></select>
      <button id="btnLoadCourse">Load</button>
    </div>
    <div class="muted">Open with <code>?course=&lt;id&gt;</code> as well.</div>
    <div style="margin-top:10px;"><strong>Hole</strong></div>
    <div class="grid" style="margin-top:6px;">
      <select id="holes"></select><button id="btnGoHole">Go</button>
    </div>
  </div>

  <button id="panelToggle" class="fab">☰</button>
  <button id="recenterBtn" class="fab-left" title="Recenter">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <circle cx="12" cy="12" r="2" fill="#ffffff"/>
      <path d="M12 2v3M12 19v3M2 12h3M19 12h3" stroke="#ffffff" stroke-width="2" stroke-linecap="round"/>
      <circle cx="12" cy="12" r="7" fill="none" stroke="#ffffff" stroke-width="1.5" opacity=".7"/>
    </svg>
  </button>

  <!-- SCORECARD -->
  <div id="scorecard" class="scorecard" aria-live="polite">
    <div class="sc-players">
      <strong>Players:</strong>
      <select id="scCount" style="width:80px"><option>1</option><option>2</option><option>3</option><option>4</option></select>
      <input id="p1" placeholder="Player 1" />
      <input id="p2" placeholder="Player 2" style="display:none"/>
      <input id="p3" placeholder="Player 3" style="display:none"/>
      <input id="p4" placeholder="Player 4" style="display:none"/>
    </div>
    <div class="sc-tools">
      <button id="scClear" class="sc-button" style="background:#b91c1c">Clear</button>
      <button id="scClose" class="sc-button">Close</button>
      <div class="sc-muted">Tap a score to edit. Colors: green = under par, grey = par, red = over.</div>
    </div>
    <div class="sc-row sc-head">
      <div class="sc-hole">H</div><div class="sc-par">Par</div>
      <div class="sc-hole" id="hP1">P1</div><div class="sc-hole" id="hP2" style="display:none">P2</div>
      <div class="sc-hole" id="hP3" style="display:none">P3</div><div class="sc-hole" id="hP4" style="display:none">P4</div>
    </div>
    <div id="scBody"></div>
    <div class="sc-totals" id="scTotals">Totals…</div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>
  <script>
    /* Base map: imagery only */
    const esriImagery = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, attribution: '&copy; Esri, Maxar, Earthstar Geographics' }
    );
    const map = L.map('map', { zoomControl: true, layers: [esriImagery] });

    /* Cart icon */
    const cartSvg = encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="40" height="32" viewBox="0 0 40 32"><rect x="5" y="10" width="24" height="10" rx="2" ry="2" fill="#1f2937"/><polygon points="5,10 15,4 29,4 29,10" fill="#0ea5b7"/><circle cx="13" cy="24" r="4" fill="#111827"/><circle cx="13" cy="24" r="2" fill="#e5e7eb"/><circle cx="27" cy="24" r="4" fill="#111827"/><circle cx="27" cy="24" r="2" fill="#e5e7eb"/><rect x="30" y="12" width="6" height="2" rx="1" fill="#111827"/><circle cx="34" cy="16" r="2" fill="#14b8a6"/></svg>`);
    const cartIcon = L.icon({ iconUrl: `data:image/svg+xml;utf8,${cartSvg}`, iconSize: [28,22], iconAnchor: [14,11] });
    const you = L.marker([0,0], { icon: cartIcon }).addTo(map);

    /* State */
    let lastPos=null, follow=true, movedOnce=false;
    let holes=[], currentIndex=0, courseList=[];
    const markers={};

    // measure state (two-leg)
    let measureTarget=null, measureLineA=null, measureLineB=null, bubbleMarkerA=null, bubbleMarkerB=null;
    let suppressClickUntil=0;

    /* UI refs */
    const status=document.getElementById('status');
    const dFront=document.getElementById('dFront'), dMid=document.getElementById('dMid'), dBack=document.getElementById('dBack');
    const eFront=document.getElementById('eFront'), eMid=document.getElementById('eMid'), eBack=document.getElementById('eBack');
    const parEl=document.getElementById('par'), strokeEl=document.getElementById('stroke');
    const holeTitle=document.getElementById('holeTitle');
    const recenterBtn=document.getElementById('recenterBtn');
    const panel=document.getElementById('panel'), toggleBtn=document.getElementById('panelToggle');
    const courseSel=document.getElementById('courseSelect'), holesSel=document.getElementById('holes');

    /* Wind */
    const windSpeedEl=document.getElementById('windSpeed'), windDirTxtEl=document.getElementById('windDirTxt'), windArrowEl=document.getElementById('windArrow');
    let windCache={ts:0,lat:null,lng:null,speed:null,dir:null}; const WIND_TTL=10*60*1000;
    function degToCompass(d){ const dirs=['N','NE','E','SE','S','SW','W','NW','N']; return dirs[Math.round(((d%360)/45))]; }
    async function fetchWind(lat,lng){
      try{
        const r=await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&windspeed_unit=ms`);
        const j=await r.json(); const cw=j?.current_weather;
        if(typeof cw?.windspeed==='number'&&typeof cw?.winddirection==='number') return {speed:cw.windspeed,dir:cw.winddirection};
      }catch{}
      return {speed:null,dir:null};
    }
    async function ensureWind(){ if(!lastPos)return; const now=Date.now(); if(now-windCache.ts>WIND_TTL){ const {speed,dir}=await fetchWind(lastPos.lat,lastPos.lng); windCache={ts:now,lat:lastPos.lat,lng:lastPos.lng,speed,dir}; } renderWind(); }
    function renderWind(){ const {speed,dir}=windCache; windSpeedEl.textContent=(typeof speed==='number')?`${speed.toFixed(1)} m/s`:'– m/s'; windDirTxtEl.textContent=(typeof dir==='number')?`${degToCompass(dir)} (${Math.round(dir)}°)`:'–'; windArrowEl.style.transform=`rotate(${(typeof dir==='number'?dir:0)}deg)`; }

    /* Panel toggle */
    function setPanelHidden(h){ panel.classList.toggle('hidden',h); toggleBtn.textContent=h?'☰':'✕'; }
    setPanelHidden(true); toggleBtn.onclick=()=>setPanelHidden(!panel.classList.contains('hidden'));

    /* Map start */
    map.setView([-25.7542, 28.2322], 15);

    /* Helpers */
    function mstyle(n){ const p={front:['#059669','#10b981'],mid:['#b45309','#f59e0b'],back:['#b91c1c','#ef4444']}[n]||['#111827','#374151']; return {radius:7,weight:2,opacity:1,fillOpacity:.9,color:p[0],fillColor:p[1]}; }
    function setMarker(n,pos,label){ if(!pos)return; if(markers[n]){markers[n].setLatLng([pos.lat,pos.lng]);return;} markers[n]=L.circleMarker([pos.lat,pos.lng],mstyle(n)).addTo(map); if(label)markers[n].bindTooltip(label); }
    function clearMarkers(){ ['front','mid','back'].forEach(n=>{ if(markers[n]){ map.removeLayer(markers[n]); delete markers[n]; }}); }
    function meters(a,b){ const R=6371000,toRad=d=>d*Math.PI/180; const dLat=toRad(b.lat-a.lat),dLng=toRad(b.lng-a.lng); const s1=Math.sin(dLat/2),s2=Math.sin(dLng/2); const q=s1*s1+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2; return 2*R*Math.asin(Math.sqrt(q)); }
    function midpoint(a,b){ return { lat:(a.lat+b.lat)/2, lng:(a.lng+b.lng)/2 }; }
    function bubbleIcon(html){ return L.divIcon({ className:'dd-measure', html:`<div class="bubble"><div class="measure-bubble">${html}</div></div>`, iconSize:[0,0], iconAnchor:[0,0] }); }

    /* Elevation fetch via server proxy + sanity */
    let lastElev=null,lastElevAt=0;
    async function fetchCurrentElevation(p){
      const now=Date.now();
      if(lastElev!==null && (now-lastElevAt)<30000) return lastElev;
      try{
        const r=await fetch(`/elevation?lat=${p.lat}&lng=${p.lng}`);
        if(r.ok){
          const js=await r.json();
          let v=js?.results?.[0]?.elevation;
          if(typeof v==='number'){
            if(v < -200 || v > 4000) v=null;
            if(v!=null){ lastElev=v; lastElevAt=now; return v; }
          }
        }
      }catch{}
      return null;
    }
    function fmtDelta(d){ if(d==null) return '–'; const dd=Math.round(d); if(Math.abs(dd)<=0) return '±0 m'; return dd>0?`↑ ${dd} m`:`↓ ${Math.abs(dd)} m`; }

    function updateHoleUI(center=true){
      if(!holes.length) return;
      const h=holes[currentIndex];
      clearMarkers();
      setMarker('front',h.green.front||h.green.center,'Front');
      setMarker('mid',  h.green.mid  ||h.green.center,'Mid');
      setMarker('back', h.green.back ||h.green.center,'Back');

      holeTitle.textContent=`Hole ${h.number}`;
      parEl.textContent=h.par??'–'; strokeEl.textContent=h.strokeIndex??'–';
      holesSel.value=String(h.number);

      if(center){
        const pts=[h.green.front,h.green.mid,h.green.back,h.green.center].filter(Boolean);
        if(pts.length) map.fitBounds(L.latLngBounds(pts.map(p=>[p.lat,p.lng])));
      }
      if(lastPos) updateDistancesAndDeltas();
      updateMeasure();
      highlightCurrentRow();
    }

    async function updateDistancesAndDeltas(){
      if(!lastPos || !holes.length) return;
      const h=holes[currentIndex]; const f=h.green.front||h.green.center, m=h.green.mid||h.green.center, b=h.green.back||h.green.center;
      dFront.textContent=Math.round(meters(lastPos,f));
      dMid.textContent  =Math.round(meters(lastPos,m));
      dBack.textContent =Math.round(meters(lastPos,b));

      const curElev=await fetchCurrentElevation(lastPos);
      const df=(h.elevation?.front!=null ? h.elevation.front : null);
      const dm=(h.elevation?.mid  !=null ? h.elevation.mid   : null);
      const db=(h.elevation?.back !=null ? h.elevation.back  : null);

      const safe = (v)=> (v!=null && v>-200 && v<4000) ? v : null;
      eFront.textContent=(safe(curElev)!=null&&safe(df)!=null)?fmtDelta(df-curElev):'–';
      eMid.textContent  =(safe(curElev)!=null&&safe(dm)!=null)?fmtDelta(dm-curElev):'–';
      eBack.textContent =(safe(curElev)!=null&&safe(db)!=null)?fmtDelta(db-curElev):'–';
    }

    /* ---------- Measure tool (two-leg: You→Layup and Layup→Mid) ---------- */
    function textA(){ // You → Layup
      if(!lastPos || !measureTarget) return null;
      return `${Math.round(meters(lastPos, measureTarget))} m`;
    }
    function textB(){ // Layup → Mid
      if(!measureTarget || !holes.length) return null;
      const h=holes[currentIndex];
      const mid = h?.green?.mid || h?.green?.center;
      if(!mid) return null;
      return `${Math.round(meters(measureTarget, mid))} m`;
    }
    function setMeasure(latlng){
      measureTarget = { lat: latlng.lat, lng: latlng.lng };
      // clear previous
      if(measureLineA) { map.removeLayer(measureLineA); measureLineA=null; }
      if(measureLineB) { map.removeLayer(measureLineB); measureLineB=null; }
      if(bubbleMarkerA){ map.removeLayer(bubbleMarkerA); bubbleMarkerA=null; }
      if(bubbleMarkerB){ map.removeLayer(bubbleMarkerB); bubbleMarkerB=null; }

      // Leg A: You → Layup
      if(lastPos){
        measureLineA = L.polyline(
          [[lastPos.lat,lastPos.lng],[measureTarget.lat,measureTarget.lng]],
          {weight:3,opacity:.95,color:'#111827'}
        ).addTo(map);
        const midA = midpoint(lastPos, measureTarget);
        bubbleMarkerA = L.marker([midA.lat, midA.lng], {
          icon: bubbleIcon(`<span class="measure-text">${textA()||'– m'}</span>
            <span class="measure-close" aria-label="Clear">×</span>`)
        }).addTo(map);
        bubbleMarkerA.on('add', () => {
          const el = bubbleMarkerA.getElement(); if(!el) return;
          L.DomEvent.disableClickPropagation(el);
          el.querySelectorAll('*').forEach(n=>L.DomEvent.on(n,'click',L.DomEvent.stopPropagation));
          const btn = el.querySelector('.measure-close');
          if(btn){
            btn.addEventListener('click',(ev)=>{
              ev.preventDefault(); ev.stopPropagation();
              suppressClickUntil=Date.now()+250;
              clearMeasure();
            });
          }
        });
      }

      // Leg B: Layup → Mid
      const h=holes[currentIndex];
      const mid = h?.green?.mid || h?.green?.center;
      if(mid){
        measureLineB = L.polyline(
          [[measureTarget.lat,measureTarget.lng],[mid.lat,mid.lng]],
          {weight:3,opacity:.9,color:'#374151',dashArray:'6 6'}
        ).addTo(map);
        const midB = midpoint(measureTarget, mid);
        bubbleMarkerB = L.marker([midB.lat, midB.lng], {
          icon: bubbleIcon(`<span class="measure-text-b">${textB()||'– m'}</span>`)
        }).addTo(map);
      }
    }
    function updateMeasure(){
      if(!measureTarget) return;

      // Update Leg A
      if(measureLineA && lastPos){
        measureLineA.setLatLngs([[lastPos.lat,lastPos.lng],[measureTarget.lat,measureTarget.lng]]);
        if(bubbleMarkerA){
          const midA = midpoint(lastPos, measureTarget);
          bubbleMarkerA.setLatLng([midA.lat, midA.lng]);
          const el = bubbleMarkerA.getElement();
          if(el){ const span = el.querySelector('.measure-text'); if(span) span.textContent = textA() || '– m'; }
        }
      }

      // Update Leg B (depends on current hole mid/center)
      const h=holes[currentIndex];
      const mid = h?.green?.mid || h?.green?.center;
      if(mid){
        if(!measureLineB){
          measureLineB = L.polyline(
            [[measureTarget.lat,measureTarget.lng],[mid.lat,mid.lng]],
            {weight:3,opacity:.9,color:'#374151',dashArray:'6 6'}
          ).addTo(map);
        } else {
          measureLineB.setLatLngs([[measureTarget.lat,measureTarget.lng],[mid.lat,mid.lng]]);
        }
        const midB = midpoint(measureTarget, mid);
        if(!bubbleMarkerB){
          bubbleMarkerB = L.marker([midB.lat, midB.lng], {
            icon: bubbleIcon(`<span class="measure-text-b">${textB()||'– m'}</span>`)
          }).addTo(map);
        } else {
          bubbleMarkerB.setLatLng([midB.lat, midB.lng]);
          const el = bubbleMarkerB.getElement();
          if(el){ const span = el.querySelector('.measure-text-b'); if(span) span.textContent = textB() || '– m'; }
        }
      } else {
        if(measureLineB){ map.removeLayer(measureLineB); measureLineB=null; }
        if(bubbleMarkerB){ map.removeLayer(bubbleMarkerB); bubbleMarkerB=null; }
      }
    }
    function clearMeasure(){
      measureTarget=null;
      if(measureLineA){ map.removeLayer(measureLineA); measureLineA=null; }
      if(measureLineB){ map.removeLayer(measureLineB); measureLineB=null; }
      if(bubbleMarkerA){ map.removeLayer(bubbleMarkerA); bubbleMarkerA=null; }
      if(bubbleMarkerB){ map.removeLayer(bubbleMarkerB); bubbleMarkerB=null; }
    }
    function onMapClick(e){
      if(Date.now()<suppressClickUntil) return; // ignore synthetic click after [×]
      setMeasure(e.latlng);
    }
    map.on('click', onMapClick);

    /* GPS */
    if('geolocation' in navigator){
      navigator.geolocation.watchPosition(async pos=>{
        const p={lat:pos.coords.latitude,lng:pos.coords.longitude};
        lastPos=p; you.setLatLng([p.lat,p.lng]);
        if(follow){ map.setView([p.lat,p.lng], map.getZoom()||17); recenterBtn.style.display='none'; }
        if(!movedOnce){ map.setView([p.lat,p.lng],17); movedOnce=true; }
        status.textContent=`Accuracy: ${Math.round(pos.coords.accuracy||0)} m`;
        await updateDistancesAndDeltas(); ensureWind(); updateMeasure();
      }, err=>{ status.textContent=err.message; }, {enableHighAccuracy:true, maximumAge:1000, timeout:10000});
    } else { status.textContent='Geolocation not supported'; }

    map.on('dragstart',()=>{follow=false;recenterBtn.style.display='block';});
    map.on('zoomstart',()=>{follow=false;recenterBtn.style.display='block';});
    recenterBtn.onclick=()=>{ if(!lastPos)return; follow=true; map.setView([lastPos.lat,lastPos.lng], map.getZoom()||17); recenterBtn.style.display='none'; };

    /* Course list + load */
    async function loadCourseList(){
      try{
        const r=await fetch('/courses/index.json');
        const js=await r.json();
        courseList=js.courses||[];
        courseSel.innerHTML='';
        courseList.forEach(c=>{const o=document.createElement('option');o.value=c.id;o.textContent=c.name||c.id;courseSel.appendChild(o);});
      }catch{ courseSel.innerHTML=''; }
    }
    async function loadCourse(id){
      holes=[]; currentIndex=0; holesSel.innerHTML=''; clearMarkers(); holeTitle.textContent='Hole –'; parEl.textContent='–'; strokeEl.textContent='–';
      try{
        const r=await fetch(`/courses/${encodeURIComponent(id)}.json`);
        const raw=await r.json();
        const root=raw.course||raw;
        holes=(root.holes||[]).map(h=>({
          number:(h.number??h.hole??h.holeNumber??null)*1,
          par:(h.par!=null?Number(h.par):null),
          strokeIndex:(h.strokeIndex??h.stroke??h.si??null)*1||null,
          green:{
            center:h.green?.center||h.green?.mid||null,
            front:h.green?.front||null,
            mid:h.green?.mid||null,
            back:h.green?.back||null
          },
          elevation:{
            front:h.elevation?.front??null,
            mid:h.elevation?.mid??null,
            back:h.elevation?.back??null
          }
        }))
        .filter(h=>Number.isFinite(h.number))
        .sort((a,b)=>a.number-b.number);

        holesSel.innerHTML='';
        holes.forEach(h=>{const o=document.createElement('option');o.value=h.number;o.textContent=`Hole ${h.number}`;holesSel.appendChild(o);});
        if(holes.length){ currentIndex=0; updateHoleUI(true); }
        status.textContent=`Loaded course: ${root.name||id}`;

        await autofillElevationsForCourse(id);
        buildScorecard(); loadSavedScores(id);
      }catch{ status.textContent=`Failed to load course ${id}`; }
    }
    document.getElementById('btnLoadCourse').onclick=()=>{ const id=courseSel.value; if(!id)return; loadCourse(id); };
    document.getElementById('btnGoHole').onclick=()=>{ const n=Number(holesSel.value); const idx=holes.findIndex(h=>h.number===n); if(idx>=0){ currentIndex=idx; updateHoleUI(true);} };
    document.getElementById('prevHole').onclick=()=>{ if(!holes.length)return; currentIndex=(currentIndex-1+holes.length)%holes.length; updateHoleUI(true); };
    document.getElementById('nextHole').onclick=()=>{ if(!holes.length)return; currentIndex=(currentIndex+1)%holes.length; updateHoleUI(true); };

    /* Elevation cache + autofill */
    const ELEV_CACHE_TTL=1000*60*60*24*30;
    function loadElevCache(courseId){ try{ const raw=localStorage.getItem('dd_elev_'+courseId); const obj=raw?JSON.parse(raw):null; if(!obj||!obj.ts||(Date.now()-obj.ts)>ELEV_CACHE_TTL) return {ts:Date.now(),holes:{}}; return obj; }catch{return {ts:Date.now(),holes:{}};} }
    function saveElevCache(courseId,cache){ try{ cache.ts=Date.now(); localStorage.setItem('dd_elev_'+courseId, JSON.stringify(cache)); }catch{} }
    async function fetchElevPoint(lat,lng){
      try{
        const r=await fetch(`/elevation?lat=${lat}&lng=${lng}`);
        if(r.ok){ const j=await r.json(); let v=j?.results?.[0]?.elevation;
          if(typeof v==='number' && v>-200 && v<4000) return v;
        }
      }catch{}
      return null;
    }
    async function autofillElevationsForCourse(courseId){
      if(!holes.length) return;
      const cache=loadElevCache(courseId);
      holes.forEach(h=>{
        const ch=cache.holes?.[h.number];
        if(ch){
          h.elevation=h.elevation||{};
          ['front','mid','back'].forEach(k=>{
            if(ch[k]!=null && h.elevation[k]==null) h.elevation[k]=ch[k];
          });
        }
      });
      const jobs=[];
      for(const h of holes){
        const pts=[['front',h.green.front],['mid',h.green.mid||h.green.center],['back',h.green.back]];
        for(const [key,pt] of pts){ if(!pt) continue; if(h.elevation?.[key]==null) jobs.push({hole:h,key,lat:pt.lat,lng:pt.lng}); }
      }
      if(!jobs.length){ updateHoleUI(false); return; }
      for(const job of jobs){
        const v=await fetchElevPoint(job.lat,job.lng);
        if(!job.hole.elevation) job.hole.elevation={};
        if(v!=null) job.hole.elevation[job.key]=v;
        const entry=cache.holes[job.hole.number]||{}; if(v!=null) entry[job.key]=v; cache.holes[job.hole.number]=entry;
        if(job.hole===holes[currentIndex]) updateDistancesAndDeltas();
      }
      saveElevCache(courseId,cache); updateHoleUI(false);
    }

    /* SCORECARD (unchanged) */
    const scoreToggle=document.getElementById('scoreToggle'), scorecard=document.getElementById('scorecard');
    const scBody=document.getElementById('scBody'), scTotals=document.getElementById('scTotals'), scCount=document.getElementById('scCount');
    const nameEls=[document.getElementById('p1'),document.getElementById('p2'),document.getElementById('p3'),document.getElementById('p4')];
    const headEls=[document.getElementById('hP1'),document.getElementById('hP2'),document.getElementById('hP3'),document.getElementById('hP4')];
    const scClose=document.getElementById('scClose'), scClear=document.getElementById('scClear');
    let playerCount=1, scores=[], courseIdForScores=null;

    scoreToggle.onclick=()=>{ scorecard.classList.toggle('show'); highlightCurrentRow(); };
    scClose.onclick=()=>scorecard.classList.remove('show');
    scClear.onclick=()=>{ if(!confirm('Clear all scores for this course?')) return; scores=Array.from({length:4},()=>Array(holes.length).fill(null)); persistScores(); renderScores(); };
    scCount.onchange=()=>{ playerCount=Number(scCount.value); for(let i=0;i<4;i++){ nameEls[i].style.display=(i<playerCount)?'':'none'; headEls[i].style.display=(i<playerCount)?'':'none'; } persistScoresMeta(); renderScores(); };
    nameEls.forEach((inp,idx)=>{ inp.addEventListener('input',()=>{ headEls[idx].textContent=inp.value||`P${idx+1}`; persistScoresMeta(); }); });

    function buildScorecard(){
      playerCount=Number(scCount.value);
      for(let i=0;i<4;i++){ nameEls[i].style.display=(i<playerCount)?'':'none'; headEls[i].style.display=(i<playerCount)?'':'none'; headEls[i].textContent=nameEls[i].value||`P${i+1}`; }
      scBody.innerHTML='';
      holes.forEach((h,idx)=>{
        const row=document.createElement('div'); row.className='sc-row'; row.dataset.hole=h.number;
        const cellHole=document.createElement('div'); cellHole.className='sc-hole'; cellHole.textContent=h.number;
        const cellPar=document.createElement('div'); cellPar.className='sc-par'; cellPar.textContent=h.par??'-';
        row.appendChild(cellHole); row.appendChild(cellPar);
        for(let p=0;p<4;p++){
          const wrap=document.createElement('div'); wrap.className='sc-cell'; wrap.style.display=(p<playerCount)?'flex':'none';
          const input=document.createElement('input'); input.className='sc-score'; input.type='number'; input.min='1'; input.placeholder='–';
          input.addEventListener('input',()=>{ onScoreChange(p,idx,input.value?Number(input.value):null); });
          const chip=document.createElement('span'); chip.className='sc-chip even'; chip.textContent='E';
          wrap.appendChild(input); wrap.appendChild(chip); row.appendChild(wrap);
        }
        scBody.appendChild(row);
      });
      if(!scores.length||scores[0].length!==holes.length) scores=Array.from({length:4},()=>Array(holes.length).fill(null));
      renderScores();
    }
    function relationToPar(score,par){ if(score==null||par==null) return {cls:'even',txt:'–'}; const d=score-par; if(d===0) return {cls:'even',txt:'E'}; if(d<0) return {cls:'under',txt:(d===-1?'−1':`−${Math.abs(d)}`)}; return {cls:'over',txt:(d===1?'+1':`+${d}`)}; }
    function renderScores(){
      scBody.querySelectorAll('.sc-row').forEach((row,idx)=>{ const par=holes[idx]?.par??null; row.querySelectorAll('.sc-cell').forEach((cell,p)=>{ if(p>=playerCount){cell.style.display='none';return;} cell.style.display='flex'; const input=cell.querySelector('.sc-score'); const chip=cell.querySelector('.sc-chip'); const v=scores[p][idx]; input.value=v??''; const rel=relationToPar(v,par); chip.className=`sc-chip ${rel.cls}`; chip.textContent=rel.txt; }); });
      const parts=[]; for(let p=0;p<playerCount;p++){ let t=0,d=0; for(let i=0;i<holes.length;i++){ const v=scores[p][i]; const par=holes[i]?.par??null; if(v!=null){ t+=v; if(par!=null) d+=(v-par); } } const nm=(nameEls[p].value||`P${p+1}`); const tag=d===0?'E':(d>0?`+${d}`:`${d}`); parts.push(`${nm}: ${t||0} (${tag})`); } scTotals.textContent=parts.join('   •   ');
    }
    function onScoreChange(p,i,val){ scores[p][i]=(typeof val==='number'&&!Number.isNaN(val))?val:null; persistScores(); renderScores(); }
    function highlightCurrentRow(){ const rows=scBody.querySelectorAll('.sc-row'); rows.forEach(r=>r.style.outline='none'); const row=rows[currentIndex]; if(row){ row.style.outline='2px solid var(--accent)'; row.scrollIntoView({block:'nearest'}); } }
    function persistScoresMeta(){ if(!courseIdForScores) return; const meta={count:playerCount, names:nameEls.map((el,i)=> i<playerCount?(el.value||`P${i+1}`):null)}; localStorage.setItem(`dd_scores_meta_${courseIdForScores}`, JSON.stringify(meta)); }
    function persistScores(){ if(!courseIdForScores) return; localStorage.setItem(`dd_scores_${courseIdForScores}`, JSON.stringify(scores)); persistScoresMeta(); }
    function loadSavedScores(id){ courseIdForScores=id; try{ const meta=JSON.parse(localStorage.getItem(`dd_scores_meta_${id}`)||'null'); if(meta){ scCount.value=String(meta.count||1); playerCount=Number(scCount.value); meta.names?.forEach((nm,i)=>{ if(nm!=null){ nameEls[i].value=nm; headEls[i].textContent=nm; }}); for(let i=0;i<4;i++){ nameEls[i].style.display=(i<playerCount)?'':'none'; headEls[i].style.display=(i<playerCount)?'':'none'; } } }catch{} try{ const saved=JSON.parse(localStorage.getItem(`dd_scores_${id}`)||'null'); if(saved&&Array.isArray(saved)&&saved.length===4&&saved[0].length===holes.length){ scores=saved; } else { scores=Array.from({length:4},()=>Array(holes.length).fill(null)); } }catch{ scores=Array.from({length:4},()=>Array(holes.length).fill(null)); } renderScores(); }

    /* Init */
    loadCourseList();
    const cid=new URLSearchParams(location.search).get('course');
    if(cid){ loadCourse(cid).then(()=>{ setTimeout(()=>{ const f=courseList.find(c=>c.id===cid); if(f) courseSel.value=cid; },300); }); }

    /* Register SW for PWA */
    if('serviceWorker' in navigator){ navigator.serviceWorker.register('/sw.js').catch(()=>{}); }
  </script>
</body>
</html>
